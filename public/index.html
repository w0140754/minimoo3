<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini MMO</title>
  <style>
    body { background:#222; color:#ddd; font-family: system-ui, sans-serif; }
    canvas { border: 1px solid #555; image-rendering: pixelated; }
  
/* --- HUD button (hamburger inventory) --- */
.game-wrap { position: relative; display: inline-block; }
.hud-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 38px;
  height: 38px;
  border-radius: 12px;
  background: rgba(0,0,0,0.55);
  border: 1px solid rgba(255,255,255,0.18);
  color: #fff;
  font-size: 22px;
  line-height: 1;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}
.hud-btn:hover { background: rgba(0,0,0,0.70); }
.hud-btn:active { transform: translateY(1px); }
.hud-btn:focus { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

  
/* --- Main menu dropdown (hamburger) --- */
.main-menu {
  position: absolute;
  top: 54px;          /* below the ☰ button */
  right: 10px;
  min-width: 160px;
  padding: 8px;
  border-radius: 14px;
  background: rgba(0,0,0,0.72);
  border: 1px solid rgba(255,255,255,0.16);
  box-shadow: 0 10px 26px rgba(0,0,0,0.35);
  display: none;
  z-index: 30;
}
.main-menu.open { display: block; }
.main-menu-item {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 10px;
  margin: 0;
  border: 0;
  border-radius: 12px;
  background: rgba(255,255,255,0.06);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  user-select: none;
}
.main-menu-item + .main-menu-item { margin-top: 6px; }
.main-menu-item:hover { background: rgba(255,255,255,0.10); }
.main-menu-item:active { transform: translateY(1px); }
.main-menu-item:focus { outline: 2px solid rgba(255,255,255,0.28); outline-offset: 2px; }
.main-menu-item .hint {
  font-size: 12px;
  opacity: 0.75;
}
.main-menu-item.disabled,
.main-menu-item:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}

  </style>
</head>
<body>
  <h1>Mini MMO</h1>
  <p>WASD / Arrow keys • Press <b>E</b> near NPC / portal • Left-click to attack • Press <b>I</b> (or ☰) for inventory • Press <b>K</b> for skills</p>
  <div id="gameWrap" class="game-wrap">
    <button id="invBtn" class="hud-btn" type="button" aria-label="Open inventory (I)" aria-expanded="false">☰</button>
    <div id="mainMenu" class="main-menu" role="menu" aria-label="Game menu">
      <button class="main-menu-item" type="button" data-action="items" role="menuitem">Items <span class="hint">I</span></button>
      <button class="main-menu-item" type="button" data-action="skills" role="menuitem">Skills <span class="hint">K</span></button>
      <button class="main-menu-item disabled" type="button" data-action="quests" role="menuitem" aria-disabled="true" disabled>Quests <span class="hint">Soon</span></button>
      <button class="main-menu-item disabled" type="button" data-action="settings" role="menuitem" aria-disabled="true" disabled>Settings <span class="hint">Soon</span></button>
    </div>
    <canvas id="c" width="800" height="600"></canvas>
  </div>

<script>
"use strict";

/* ==========================================================
   DEV / READABILITY HELPERS
   - Toggle logging by running:   __DEV__.log = true
   - Keep this OFF in production; it can be noisy.
========================================================== */
const __DEV__ = { log: false };
function dlog(...args) { if (__DEV__.log) console.log(...args); }

/* ======================
   CONFIG
====================== */
let TILE_SIZE = 64;
let PORTAL_TILE = 3;
// Debug: collision visuals (client-only). Toggle with F3.
let debugHitboxes = false;
const DBG_PLAYER_R = 14;       // matches server PLAYER_FOOT_RADIUS
const DBG_PLAYER_FOOT_Y = 22;  // matches server PLAYER_FOOT_OFFSET_Y
const DBG_MOB_R = 16;          // matches server MOB_RADIUS
const DBG_SWORD_OFFSET = 40;   // matches server melee constants
const DBG_SWORD_R = 55;
const DBG_SPEAR_OFFSET = 50;
const DBG_SPEAR_R = 32;

// Corpse animation
const CORPSE_TOTAL_MS = 2000;
const CORPSE_FADE_MS = 650; // last part fades out


const PLAYER_FRAME_W = 64;
const PLAYER_FRAME_H = 64;

// Most existing spritesheets in this project are still 48x48.
// We keep their sizes separate so changing the player doesn't break NPCs/mobs/tiles.
const NPC_FRAME_W = 48;
const NPC_FRAME_H = 48;
const MOB_FRAME_W = 48;
const MOB_FRAME_H = 48;

// Auto-detect mob frame size from the spritesheet image.
// Assumes mobs are laid out as 3 columns (frames) x 4 rows (directions).
function getMobFrameSize(img) {
  // Fallback to legacy defaults until the image is loaded.
  if (!img || !img.complete || img.naturalWidth === 0) return { w: MOB_FRAME_W, h: MOB_FRAME_H };
  const w = Math.floor(img.naturalWidth / COLS); // COLS = 3
  const h = Math.floor(img.naturalHeight / 4);   // 4 direction rows
  return { w, h };
}


const COLS = 3; // columns per row in your 3-frame spritesheets
const WALK_SEQ = [0, 1, 0, 2]; // frame order: 1,2,1,3 (0-based cols)
const IDLE_FRAME_TIME = 0.7; // seconds per idle frame (~1.4 FPS)

const SNAPSHOT_HZ = 30;
const SNAPSHOT_DT = 1 / SNAPSHOT_HZ;
const INTERP_DELAY = SNAPSHOT_DT * 1.5;

const INTERACT_DIST = 80;
const MOB_HPBAR_DIST = 220; // px: only show enemy HP bars within this distance

// ======================
// SKILLS (client-side UI/state)
// ======================
const SKILL1_RANGE_PX = 200; // targeting preview radius
const SKILL1_EFFECT_RADIUS_PX = 200; // effect radius (server also sends w.rad)
let skill1Primed = false;

// Hotbar feedback when player tries to use Skill 1 while it is not available
let skill1HotbarNackUntilMs = 0;   // UI time (performance.now)
let skill1HotbarShakeUntilMs = 0;  // UI time (performance.now)
let skill1HotbarShakeSeed = 0;

function triggerSkill1HotbarNack() {
  const now = performance.now();
  skill1HotbarNackUntilMs = now + 420;
  skill1HotbarShakeUntilMs = now + 420;
  skill1HotbarShakeSeed = Math.random() * 1000;
}


// Server-authoritative timers for local player (updated via ws messages)
let skill1ActiveUntilMs = 0; // while whirlpool is running
let skill1CdUntilMs = 0;     // when the skill can be cast again (cooldown timer (server))
let skill1ActiveTotalMs = 0; // client-learned total active duration (for UI)
let skill1CdTotalMs = 0;     // client-learned total cooldown duration (for UI)
let _lastSkill1ActiveUntilMs = 0;
let _lastSkill1CdUntilMs = 0;


// ===== Skill 2: Double Stab (spear-only) =====
let skill2CdUntilMs = 0;
let skill2CdTotalMs = 0;
let _lastSkill2CdUntilMs = 0;

// Hotbar feedback when player tries to use Skill 2 while it is not available
let skill2HotbarNackUntilMs = 0;   // UI time (performance.now)
let skill2HotbarShakeUntilMs = 0;  // UI time (performance.now)
let skill2HotbarShakeSeed = 0;

function triggerSkill2HotbarNack() {
  const now = performance.now();
  skill2HotbarNackUntilMs = now + 420;
  skill2HotbarShakeUntilMs = now + 420;
  skill2HotbarShakeSeed = Math.random() * 1000;
}

// For spear scaling/jut visuals during the double-stab window (map-scoped)
const skill2FxByCaster = new Map(); // casterId -> { startMs }
const SKILL2_GAP_MS = 120;
const SKILL2_VIS_MS = 360;

const TILE_PAD = 1;
const TILESET_COLS = 5; // tiles per row in tiles.png and tiles_objects.png
// Convention: odd rows in tiles.png are passable; even rows are blocked.
const WALL_TILE = TILESET_COLS; // row 2, col 1 (1-based) when cols=5

const LOCAL_SWING_DUR = 0.18; // must match server p.atkAnim start value
const ATTACK_DELAY_MS = 300; // local input throttle (server also enforces)

let nextAttackAtMs = 0; // local send throttle (server also enforces)


let inventoryOpen = false;
let skillsOpen = false;

// ======================
// HOTBAR (1–6)
// - Press 1..6 to use a bound skill/item (initially: 1=Skill1, 2=Skill2)
// - (Optional binding now) Ctrl+1..6 while hovering an inventory item binds that item
// ======================
const HOTBAR_SIZE = 6;

// Client-side hint for "consumable" items (used for inventory submenu + hotbar binding UI).
// Keep this list in sync with server.js ITEMS that have an onUse().
const CONSUMABLE_ITEM_IDS = new Set([
  "potion_small",
  "potion_green",
  "potion_purple",
]);

function isConsumableItemId(itemId) {
  if (!itemId) return false;
  return CONSUMABLE_ITEM_IDS.has(itemId) || itemId.startsWith("potion_");
}

let hotbarSlots = [
  { type: "skill", id: "skill1" },
  { type: "skill", id: "skill2" },
  null, null, null, null,
];

// Quick visual feedback when a hotbar slot is successfully used
const HOTBAR_FLASH_MS = 140;
const hotbarFlashUntilMs = new Array(HOTBAR_SIZE).fill(0);

function triggerHotbarFlashByIndex(idx) {
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarFlashUntilMs[idx] = performance.now() + HOTBAR_FLASH_MS;
}


function hotbarToast(msg, ms = 1400) {
  // Uses your existing toast if present; otherwise falls back to console
  if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
    levelToastText = msg;
    levelToastUntilMs = performance.now() + ms;
  } else {
    console.log("[hotbar]", msg);
  }
}

function resolveInventorySlotIndex(itemId, preferred) {
  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
  const slots = me?.inventory?.slots;
  if (!slots) return -1;

  if (preferred != null && preferred >= 0 && preferred < slots.length) {
    const s = slots[preferred];
    if (s && s.id === itemId) return preferred;
  }
  for (let i = 0; i < slots.length; i++) {
    const s = slots[i];
    if (s && s.id === itemId) return i;
  }
  return -1;
}

function activateSkillById(skillId) {
  // Skill1: your existing wand skill (arms the next shot)
  if (skillId === "skill1") {
    // If you already have a dedicated function, prefer it
    if (typeof activateSkill1 === "function") { activateSkill1(); return true; }

    // Minimal safe implementation using your existing variables/functions
    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();

    if (typeof skill1ActiveUntilMs !== "undefined" && nowAbs < skill1ActiveUntilMs) {
      if (typeof triggerSkill1HotbarNack === "function") triggerSkill1HotbarNack();
      return false;
    }
    if (typeof skill1CdUntilMs !== "undefined" && nowAbs < skill1CdUntilMs) {
      if (typeof triggerSkill1HotbarNack === "function") triggerSkill1HotbarNack();
      return false;
    }

    // Match the old click-to-cast behavior: Skill 1 requires a wand equipped
    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
        levelToastText = "Equip a wand to use Skill 1";
        levelToastUntilMs = performance.now() + 1500;
      } else {
        hotbarToast("Equip a wand to use Skill 1");
      }
      return false;
    }

    // Aim at the last mouse position (no click required). If we don't have a mouse yet, fire forward.
    let wx = null, wy = null, mx = null, my = null;
    if (typeof lastAim !== "undefined" && lastAim && lastAim.has) {
      wx = lastAim.wx; wy = lastAim.wy; mx = lastAim.mx; my = lastAim.my;
    } else {
      const px = me?.x ?? 0;
      const py = me?.y ?? 0;
      const fx = me?.facing?.x ?? 0;
      const fy = me?.facing?.y ?? 1;
      const len = Math.hypot(fx, fy) || 1;
      const dirx = fx / len, diry = fy / len;
      const range = 220;
      wx = px + dirx * range;
      wy = py + diry * range;
    }

    // Arm + immediately fire (no extra click)
    if (typeof sendSkill1Arm === "function") sendSkill1Arm();
    if (typeof sendAttackAtWorld === "function") {
      sendAttackAtWorld(wx, wy, mx, my, { skill1: true });
    } else {
      hotbarToast("Skill1 not available (sendAttackAtWorld missing)");
      return false;
    }

    // Ensure we don't leave a primed state hanging around
    if (typeof skill1Primed !== "undefined") skill1Primed = false;
    if (typeof skill1PrimedUntilMs !== "undefined") skill1PrimedUntilMs = 0;

    return true;
  }

  // Skill2: your spear double-stab
  if (skillId === "skill2") {
    if (typeof activateSkill2 === "function") { activateSkill2(); return true; }

    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
    if (typeof skill2ActiveUntilMs !== "undefined" && nowAbs < skill2ActiveUntilMs) {
      if (typeof triggerSkill2HotbarNack === "function") triggerSkill2HotbarNack();
      return false;
    }
    if (typeof skill2CdUntilMs !== "undefined" && nowAbs < skill2CdUntilMs) {
      if (typeof triggerSkill2HotbarNack === "function") triggerSkill2HotbarNack();
      return false;
    }

    if (typeof sendSkill2DoubleStabAtWorld === "function" && typeof lastAim !== "undefined" && lastAim?.has) {
      sendSkill2DoubleStabAtWorld(lastAim.wx, lastAim.wy, lastAim.mx, lastAim.my);
      return true;
    }
    if (typeof sendSkill2DoubleStab === "function") {
      sendSkill2DoubleStab();
      return true;
    }
    hotbarToast("Skill2 not available (sendSkill2DoubleStab missing)");
    return false;
  }

  hotbarToast(`Unknown skill: ${skillId}`);
  return false;
}

function useHotbarSlot(n1) {
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;

  const slot = hotbarSlots[idx];
  if (!slot) {
    hotbarToast(`Hotbar ${n1}: empty`);
    return;
  }

  if (slot.type === "skill") {
    const ok = activateSkillById(slot.id);
    if (ok) triggerHotbarFlashByIndex(idx);
    return;
  }

  if (slot.type === "item") {
    const si = resolveInventorySlotIndex(slot.itemId, slot.preferSlot);
    if (si < 0) {
      hotbarToast(`Hotbar ${n1}: item not found`);
      return;
    }
    if (typeof sendInvClick === "function") {
      sendInvClick(si);
      triggerHotbarFlashByIndex(idx);
    } else {
      hotbarToast("Item use not available (sendInvClick missing)");
    }
    return;
  }

  hotbarToast(`Hotbar ${n1}: invalid`);
}

function bindHotbarItem(n1, itemId, preferSlot) {
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarSlots[idx] = { type: "item", itemId, preferSlot };
  hotbarToast(`Bound ${n1} → item`);
}

function bindHotbarSkill(n1, skillId) {
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarSlots[idx] = { type: "skill", id: skillId };
  hotbarToast(`Bound ${n1} → ${skillId}`);
}

function hotbarKeyForSkill(skillId) {
  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const s = hotbarSlots[i];
    if (s && s.type === "skill" && s.id === skillId) return String(i + 1);
  }
  return "";
}

// When binding from the Skills menu, we enter a "press 1–6" capture mode.
let pendingSkillBind = null; // { skillId }
let pendingItemBind = null; // { itemId, preferSlot }


// Draw a simple hotbar at the bottom (text-only labels for now)
function drawHotbar() {
  if (typeof ctx === "undefined" || typeof canvas === "undefined") return;

  const box = 44, gap = 6;
  const totalW = HOTBAR_SIZE * box + (HOTBAR_SIZE - 1) * gap;
  const x0 = Math.round(canvas.width / 2 - totalW / 2);
  const y0 = Math.round(canvas.height - box - 12);

  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
    ? worldPlayers?.[myId]
    : null;
  const invSlots = me?.inventory?.slots || [];

  const nowUiMs = performance.now();
  const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();

  ctx.save();

  // slot visuals
  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const x = x0 + i * (box + gap);
    const y = y0;

    // background box
    ctx.fillStyle = "rgba(0,0,0,0.50)";
    ctx.fillRect(x, y, box, box);
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.strokeRect(x + 0.5, y + 0.5, box - 1, box - 1);

    const slot = hotbarSlots[i];

    // Draw icon if assigned
    let drewIcon = false;

    if (slot && slot.type === "skill") {
      const iconImg = hotbarSkillIcons?.[slot.id] || null;
      if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
        const ICON = 30;
        const ix = Math.round(x + (box - ICON) / 2);
        const iy = Math.round(y + (box - ICON) / 2);
        ctx.drawImage(iconImg, ix, iy, ICON, ICON);
        drewIcon = true;
      }
    } else if (slot && slot.type === "item") {
      const si = resolveInventorySlotIndex(slot.itemId, slot.preferSlot);
      const it = (si >= 0) ? invSlots[si] : null;
      const qty = Number(it?.qty || 0);
      const outOfStock = (si < 0) || (qty <= 0);

      const itemId = it?.id || slot.itemId;
      const img = getItemIconImage(itemId);

      // icon (dim if out of stock)
      if (img && img.complete && img.naturalWidth > 0) {
        const ICON = 30;
        const ix = Math.round(x + (box - ICON) / 2);
        const iy = Math.round(y + (box - ICON) / 2);
        ctx.save();
        if (outOfStock) ctx.globalAlpha = 0.35;
        ctx.drawImage(img, ix, iy, ICON, ICON);
        ctx.restore();
        drewIcon = true;
      } else {
        // fallback label if icon missing
        ctx.save();
        ctx.fillStyle = outOfStock ? "rgba(255,255,255,0.35)" : "rgba(255,255,255,0.85)";
        ctx.font = "11px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Item", x + box / 2, y + box / 2);
        ctx.restore();
      }

      // stack count (consumables) — only when we actually have stock > 1
      if (!outOfStock && qty > 1) {
        ctx.save();
        const txt = `x${qty}`;
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + box - 4;
        const ty = y + box - 3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.80)";
        ctx.strokeText(txt, tx, ty);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(txt, tx, ty);
        ctx.restore();
      }

      // out-of-stock indicator (hotkeyed, but none in inventory)
      if (outOfStock) {
        ctx.save();
        // subtle dark veil
        ctx.fillStyle = "rgba(0,0,0,0.40)";
        ctx.fillRect(x + 2, y + 2, box - 4, box - 4);

        // "0" in corner
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + box - 4;
        const ty = y + box - 3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.85)";
        ctx.strokeText("0", tx, ty);
        ctx.fillStyle = "rgba(255,150,150,0.98)";
        ctx.fillText("0", tx, ty);
        ctx.restore();
      }
    }


    // Cooldown overlay (skills)
    if (slot && slot.type === "skill") {
      let lockUntil = 0;
      let totalMs = 0;

      if (slot.id === "skill1") {
        // skill1 has an "active" window and a cooldown window; either blocks re-use
        if (typeof skill1ActiveUntilMs === "number" && nowAbs < skill1ActiveUntilMs) {
          lockUntil = Math.max(lockUntil, skill1ActiveUntilMs);
          totalMs = Math.max(totalMs, Number(skill1ActiveTotalMs || 0));
        }
        if (typeof skill1CdUntilMs === "number" && nowAbs < skill1CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill1CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill1CdTotalMs || 0));
        }
      } else if (slot.id === "skill2") {
        if (typeof skill2CdUntilMs === "number" && nowAbs < skill2CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill2CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill2CdTotalMs || 0));
        }
      }

      const remainMs = Math.max(0, lockUntil - nowAbs);

      if (remainMs > 0) {
        const pct = (totalMs > 0) ? Math.max(0, Math.min(1, remainMs / totalMs)) : 1;

        // darken the whole slot a bit
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(x, y, box, box);

        // thicker fill from bottom indicating time remaining
        const h = Math.max(0, Math.min(box, Math.ceil(box * pct)));
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(x, y + (box - h), box, h);

        // remaining time text
        const sec = remainMs / 1000;
        const txt = (sec < 10) ? sec.toFixed(1) : String(Math.ceil(sec));
        ctx.save();
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.85)";
        ctx.strokeText(txt, x + box / 2, y + box / 2);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(txt, x + box / 2, y + box / 2);
        ctx.restore();
      }
    }

    // Hotbar "used" flash feedback
    const flashRemain = (hotbarFlashUntilMs[i] || 0) - nowUiMs;
    if (flashRemain > 0) {
      const a = Math.max(0, Math.min(1, flashRemain / HOTBAR_FLASH_MS));
      ctx.fillStyle = `rgba(255,255,255,${(0.55 * a).toFixed(3)})`;
      ctx.fillRect(x, y, box, box);
    }

    // Key label (always)
    ctx.font = "11px system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText(String(i + 1), x + 4, y + 3);

    // If empty or no icon available, show a subtle placeholder
    if (!slot || !drewIcon) {
      ctx.font = "10px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = slot ? "rgba(255,255,255,0.55)" : "rgba(255,255,255,0.25)";

      let label = "";
      if (slot?.type === "skill") label = (slot.id || "Skill");
      else if (slot?.type === "item") label = "Item";

      if (label) {
        if (label.length > 8) label = label.slice(0, 8) + "…";
        ctx.fillText(label, x + box / 2, y + box / 2 + 9);
      } else {
        ctx.fillText("—", x + box / 2, y + box / 2 + 9);
      }
    }
  }

  ctx.restore();
}


let skillsTab = "wand";
    // (button controls main menu, not inventory)
 // I key toggles inventory UI

/* ======================
   DEBUG MAP EDITOR
   F1: toggle editor
   TAB: switch layer (ground/object)
   [ / ]: cycle tile id
   Left click: paint, Right click: erase
   Ctrl+E: export current map+objects to clipboard/console
====================== */
let editorOpen = false;
let editorLayer = "ground"; // "ground" | "object"
let editorShowGrid = true;
let editorShowColl = true;
let editorMouseX = 0, editorMouseY = 0; let editorMouseHas = false;

// Track the last known mouse position so keyboard skills (like 2) can aim like click-attacks.
let lastAim = { mx: 0, my: 0, wx: 0, wy: 0, has: false };

// Allowed tiles to keep you from accidentally breaking portals/statues.
// You can expand these later.
// Ground tiles that are selectable in the editor (auto-built from /assets/tiles.png)
let EDIT_GROUND_TILES = [0, 1];

function rebuildEditorGroundTiles() {
  // Build [0..N-1] from the tilesheet size, excluding the portal tile so we don't accidentally paint portals.
  const img = tileImage;
  const cell = TILE_SIZE + TILE_PAD;

  if (!img || !img.complete || img.naturalWidth <= 0 || img.naturalHeight <= 0) return;

  const cols = TILESET_COLS;
  const rows = Math.max(1, Math.floor(img.naturalHeight / cell));
  const total = rows * cols;

  const list = [];
  for (let i = 0; i < total; i++) {
    list.push(i);
  }
  if (list.length) EDIT_GROUND_TILES = list;
}
          // grass, wall (keep portals/statues unchanged for now)
let EDIT_OBJECT_TILES = [0, 1, 2, 6];    // will expand automatically based on tiles_objects.png
function rebuildEditorObjectTiles() {
  // Allow painting any tile that exists in tiles_objects.png (0 = empty)
  if (!objTileImage.complete || objTileImage.naturalHeight <= 0) return;
  const cell = TILE_SIZE + TILE_PAD;
  const rows = Math.floor((objTileImage.naturalHeight + TILE_PAD) / cell);
  const maxId = Math.max(0, rows * TILESET_COLS);
  const list = [0];
  for (let i = 1; i <= maxId; i++) list.push(i);
  EDIT_OBJECT_TILES = list;
  editorTileIndex = clamp(editorTileIndex, 0, EDIT_OBJECT_TILES.length - 1);
}

let editorTileIndex = 0; // index into allowed list for current layer

function editorAllowedList() {
  return (editorLayer === "ground") ? EDIT_GROUND_TILES : EDIT_OBJECT_TILES;
}
function editorSelectedTile() {
  const list = editorAllowedList();
  return list[clamp(editorTileIndex, 0, list.length - 1)];
}
function editorSetTileIndexByValue(v) {
  const list = editorAllowedList();
  const idx = list.indexOf(v);
  if (idx !== -1) editorTileIndex = idx;
}

// send tile edit to server (server will validate)
function sendEditTile(layer, tx, ty, tile) {
  wsSend({ type: "editTile", layer, x: tx, y: ty, tile });
}

function legacyCopyTextToClipboard(txt) {
  try {
    const ta = document.createElement("textarea");
    ta.value = txt;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    const ok = document.execCommand && document.execCommand("copy");
    document.body.removeChild(ta);
    return !!ok;
  } catch (e) {
    return false;
  }
}

function showExportOverlay(txt) {
  let overlay = document.getElementById("mapExportOverlay");
  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "mapExportOverlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.right = "0";
    overlay.style.bottom = "0";
    overlay.style.background = "rgba(0,0,0,0.55)";
    overlay.style.zIndex = "999999";
    overlay.style.display = "none";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.padding = "18px";

    const panel = document.createElement("div");
    panel.style.width = "min(980px, 92vw)";
    panel.style.maxHeight = "86vh";
    panel.style.background = "rgba(20,20,24,0.98)";
    panel.style.border = "1px solid rgba(255,255,255,0.12)";
    panel.style.borderRadius = "12px";
    panel.style.boxShadow = "0 12px 40px rgba(0,0,0,0.45)";
    panel.style.padding = "14px";
    panel.style.display = "flex";
    panel.style.flexDirection = "column";
    panel.style.gap = "10px";
    panel.style.color = "#fff";
    panel.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";

    const title = document.createElement("div");
    title.textContent = "Map Export";
    title.style.fontSize = "18px";
    title.style.fontWeight = "700";

    const tip = document.createElement("div");
    tip.textContent = "Clipboard is blocked in this context. The export is shown below — click inside, then press Ctrl+C to copy.";
    tip.style.fontSize = "13px";
    tip.style.opacity = "0.85";

    const ta = document.createElement("textarea");
    ta.id = "mapExportText";
    ta.spellcheck = false;
    ta.wrap = "off";
    ta.style.width = "100%";
    ta.style.height = "60vh";
    ta.style.resize = "vertical";
    ta.style.background = "rgba(0,0,0,0.35)";
    ta.style.color = "#fff";
    ta.style.border = "1px solid rgba(255,255,255,0.18)";
    ta.style.borderRadius = "10px";
    ta.style.padding = "10px";
    ta.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ta.style.fontSize = "12px";
    ta.style.lineHeight = "1.35";

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "10px";
    row.style.justifyContent = "flex-end";

    const btnCopy = document.createElement("button");
    btnCopy.textContent = "Try Copy Again";
    btnCopy.style.padding = "8px 12px";
    btnCopy.style.borderRadius = "10px";
    btnCopy.style.border = "1px solid rgba(255,255,255,0.22)";
    btnCopy.style.background = "rgba(255,255,255,0.08)";
    btnCopy.style.color = "#fff";
    btnCopy.style.cursor = "pointer";

    const btnClose = document.createElement("button");
    btnClose.textContent = "Close";
    btnClose.style.padding = "8px 12px";
    btnClose.style.borderRadius = "10px";
    btnClose.style.border = "1px solid rgba(255,255,255,0.22)";
    btnClose.style.background = "rgba(255,255,255,0.08)";
    btnClose.style.color = "#fff";
    btnClose.style.cursor = "pointer";

    btnClose.onclick = () => { overlay.style.display = "none"; };
    overlay.onclick = (e) => { if (e.target === overlay) overlay.style.display = "none"; };

    btnCopy.onclick = async () => {
      const t = document.getElementById("mapExportText")?.value ?? "";
      let ok = false;
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(t);
          ok = true;
        }
      } catch {}
      if (!ok) ok = legacyCopyTextToClipboard(t);
      levelToastText = ok ? "Export copied to clipboard" : "Copy still blocked — use Ctrl+C";
      levelToastUntilMs = performance.now() + 2500;
      if (ok) overlay.style.display = "none";
    };

    row.appendChild(btnCopy);
    row.appendChild(btnClose);

    panel.appendChild(title);
    panel.appendChild(tip);
    panel.appendChild(ta);
    panel.appendChild(row);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
  }

  const ta = document.getElementById("mapExportText");
  if (ta) ta.value = txt;

  overlay.style.display = "flex";
  setTimeout(() => {
    const t = document.getElementById("mapExportText");
    if (t) {
      t.focus();
      t.select();
    }
  }, 0);
}

async function exportCurrentMapToClipboard() {
  if (!map) return;

  // Use whatever your client already tracks as the "current map id"
  // If yours is named differently, swap this line only.
  const id = (typeof currentMapId !== "undefined") ? currentMapId
           : (typeof currentMap !== "undefined" && currentMap?.id != null) ? currentMap.id
           : 1;

  // If your maps are numeric (1/2/3/4), this makes makeMapA/B/C/D automatically.
  // If your ids are strings (like "mapA"), see note below.
  const letter = (typeof id === "number" && id >= 1 && id <= 26)
    ? String.fromCharCode(64 + id)
    : String(id);

  const fnName = `makeMap${letter}`;

  const w = map?.[0]?.length || 0;
  const h = map?.length || 0;

  const ground = map;
  const objects = objMap || Array.from({ length: h }, () => Array(w).fill(0));

  // If your client has portals synced, include them; otherwise export empty list
  const portalList = (typeof portals !== "undefined" && Array.isArray(portals)) ? portals : [];

  const payload =
`// Paste into maps_data.js
export function ${fnName}() {
  const w = ${w};
  const h = ${h};

  const map = ${JSON.stringify(ground)};
  const obj = ${JSON.stringify(objects)};

  const portals = ${JSON.stringify(portalList, null, 2)};

  return { id: ${JSON.stringify(id)}, w, h, map, obj, portals };
}
`;

  console.log(payload);

  let copied = false;
try {
  // Modern API (works on https / localhost with permission)
  if (navigator.clipboard && (window.isSecureContext || location.hostname === "localhost")) {
    await navigator.clipboard.writeText(payload);
    copied = true;
  }
} catch (err) {
  copied = false;
}

// Fallback for http / blocked clipboard contexts
if (!copied) copied = legacyCopyTextToClipboard(payload);

if (copied) {
  levelToastText = "Exported makeMap() to clipboard (also logged to console)";
  levelToastUntilMs = performance.now() + 2500;
} else {
  console.warn("Clipboard blocked — showing export overlay");
  levelToastText = "Clipboard blocked — showing export box";
  levelToastUntilMs = performance.now() + 2500;
  showExportOverlay(payload);
}
}



let invUI = null; // cached inventory UI layout for click handling

// Inventory window (draggable)
let invWinX = null;
let invWinY = null;
let invWinW = 0;
let invWinH = 0;
let invDragging = false;
let invDragOffX = 0;
let invDragOffY = 0;
let invCloseRect = null;
let invHeaderRect = null;

// Skills window (draggable)
let skillsUI = null; // cached skills UI layout for click handling
let skillsWinX = null;
let skillsWinY = null;
let skillsWinW = 0;
let skillsWinH = 0;
let skillsDragging = false;
let skillsDragOffX = 0;
let skillsDragOffY = 0;
let skillsCloseRect = null;
let skillsHeaderRect = null;
let skillsTabRects = null; // {sword:{...}, spear:{...}, wand:{...}}
let skillsItemRects = null; // [{id, rect}, ...]


// Mouse position in screen-space (for inventory hover tooltips)
let uiMouse = { mx: 0, my: 0, has: false };
let invHover = null; // { id, qty, source, rect }
let invItemMenu = null; // { x, y, slotIndex, itemId }
let invItemMenuUI = null; // { panel, btnUse, btnBind }

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function rectHit(r, mx, my) {
  return !!r && mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h;
}
function lerp(a, b, t) { return a + (b - a) * t; }
function easeInOut(t) { return t * t * (3 - 2 * t); }
function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
function snap2(x, y) { return { x: Math.round(x), y: Math.round(y) }; }

// Show mob HP bars if you're nearby OR the mob is currently aggro/provoked.
function shouldShowMobHp(mob, me, wx, wy) {
  // Server sets aggroUntil when a mob is provoked (eg, after being hit)
  if (mob && typeof mob.aggroUntil === "number" && mob.aggroUntil > serverNowMs()) return true;
  if (!me) return true;
  return dist(me.x, me.y, wx, wy) <= MOB_HPBAR_DIST;
}

/* ======================
   ASSETS
====================== */
const tileImage    = new Image();
tileImage.onload = rebuildEditorGroundTiles;
tileImage.src = "/assets/tiles.png";
const objTileImage = new Image();
objTileImage.onload = rebuildEditorObjectTiles;
objTileImage.src = "/assets/tiles_objects.png";
// Skill 1 black hole spritesheet (8 frames vertical: 64x64 each)
const SKILL1_BLACKHOLE = {
  src: "/assets/skills/skill_blackhole.png",
  frameW: 64,
  frameH: 64,
  frames: 8,
  frameMs: 90, // ~11 FPS
};
const blackholeImg = new Image();
blackholeImg.src = SKILL1_BLACKHOLE.src;
const skill1IconImg = new Image();
skill1IconImg.src = "/assets/skills/icons/icon_skill_blackhole.png";
const skill2IconImg = new Image();
skill2IconImg.src = "/assets/skills/icons/icon_skill_double_stab.png";

// Hotbar icon lookup for skills
const hotbarSkillIcons = {
  skill1: skill1IconImg,
  skill2: skill2IconImg,
};

function getItemIconImage(itemId) {
  // Prefer inventory/equipment icons; fall back to drop sprites if needed
  return (typeof equipIcons !== "undefined" && equipIcons[itemId]) ? equipIcons[itemId]
       : (typeof itemSprites !== "undefined" && itemSprites[itemId]) ? itemSprites[itemId]
       : null;
}

// In case the image is already cached/complete
setTimeout(rebuildEditorObjectTiles, 0);
setTimeout(rebuildEditorGroundTiles, 0);
const playerSprite = new Image(); playerSprite.src = "/assets/player_image.png";
const playerIdleSprite = new Image(); playerIdleSprite.src = "/assets/player_idle.png";
const npcSprite    = new Image(); npcSprite.src = "/assets/npc.png";

// Static NPC images (new system)
const NPC_DRAW_W = 64;
const NPC_DRAW_H = 64;
const NPC_SORT_Y_OFFSET = 22;

const npcImages = {
  "npcs/npc_crystal.png": new Image(),
  "npcs/npc_girl.png": new Image(),
  "npcs/npc_jangoon.png": new Image(),
};
npcImages["npcs/npc_crystal.png"].src = "/assets/npcs/npc_crystal.png";
npcImages["npcs/npc_girl.png"].src    = "/assets/npcs/npc_girl.png";
npcImages["npcs/npc_jangoon.png"].src = "/assets/npcs/npc_jangoon.png";


// Attack weapon sprites (spears can swap art based on equipped spear item)
const spearSprites = {
  training_spear: new Image(),
  candy_cane_spear: new Image(),
  fang_spear: new Image(),
};
spearSprites.training_spear.src = "/assets/basic_spear.png";
spearSprites.candy_cane_spear.src = "/assets/candy_cane_spear.png";
spearSprites.fang_spear.src = "/assets/fang_spear.png";


// Projectile sprites (server sends pr.sprite key; fallback draws a simple bolt if missing)
const projectileSprites = {
  wand_projectile: new Image(),
  skill1_projectile: new Image(),
};
// Put your custom wand projectile here:
projectileSprites.wand_projectile.src = "/assets/wand_projectile.png";
// Skill 1 projectile sprite (used only for Skill 1 primed shots)
projectileSprites.skill1_projectile.src = "/assets/skill1_projectile.png";

function getSpearSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return spearSprites[wid] || null;
}


// Held-weapon overlay sprites (NOT the inventory icons).
// Icons live under /assets/equipment/*, but the in-hand overlays live under /assets/*.
const swordSprites = {
  training_sword: new Image(),
};
swordSprites.training_sword.src = "/assets/training_sword.png";

const wandSprites = {
  training_wand: new Image(),
};
wandSprites.training_wand.src = "/assets/training_wand.png";

function getSwordSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return swordSprites[wid] || null;
}
function getWandSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return wandSprites[wid] || null;
}


function getSwordHand(dir) {
  // Shared sword hand anchor so held + slash align perfectly.
  // Tune these 4 numbers and both visuals will follow.
  return ({
    [DIR.RIGHT]: { x: -6,  y: 16 },
    [DIR.LEFT]:  { x:  6,  y: 16 },
    [DIR.DOWN]:  { x: -12, y: 16 },
    [DIR.UP]:    { x:  10, y: 16 },
  }[dir] || { x: 0, y: 0 });
}

function getSpearHand(dir) {
  return ({
    [DIR.RIGHT]: { x: -10, y: 15 },
    [DIR.LEFT]:  { x:  10, y: 15 },
    [DIR.DOWN]:  { x: -14, y: -3 },
    [DIR.UP]:    { x:  10, y: 25 },
  }[dir] || { x: 32, y: 32 });
}


function drawSwordHeld(x, y, dir, swordImg) {
  x = Math.round(x); y = Math.round(y);

  // Use the shared anchor so held + slash never drift apart.
  const hand = getSwordHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  const img = swordImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Keep the sword upright (no 90° rotation). Mirror for LEFT so it sits naturally.
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = 32, H = 64;

  // Grip point inside the sprite (from top-left of the 32x64 image).
  // Starter values: bottom-center-ish.
  const gripX = 16;
  const gripY = 50;

  ctx.imageSmoothingEnabled = false;
  if (ready) ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  else {
    // fallback: simple blade
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-1, -44, 2, 40);
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-6, -10, 12, 6);
  }
  ctx.restore();
}

function drawWandHeld(x, y, dir, wandImg) {
  x = Math.round(x); y = Math.round(y);

  // Starter hand anchors (tune as needed)
  const hand = ({
    [DIR.RIGHT]: { x: -6,  y: 20 },
    [DIR.LEFT]:  { x:  6,  y: 20 },
    [DIR.DOWN]:  { x: -12, y: 20 },
    [DIR.UP]:    { x:  10, y: 20 },
  }[dir] || { x: 0, y: 0 });

  const px = x + hand.x;
  const py = y + hand.y;

  const img = wandImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Keep the wand/staff upright (no 90° rotation). Mirror for LEFT.
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = 32, H = 64;

  // Grip point (starter): bottom-center-ish
  const gripX = 16;
  const gripY = 52;

  ctx.imageSmoothingEnabled = false;
  if (ready) ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  else {
    // fallback: simple staff
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -50, 4, 48);
    ctx.fillStyle = "#bde0fe";
    ctx.fillRect(-4, -54, 8, 6);
  }
  ctx.restore();
}

function drawDebugCircle(x, y, r, stroke) {
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();
}

function weaponKeyFromEquippedId(wid) {
  if (!wid) return null;
  if (wid.includes("spear")) return "spear";
  if (wid.includes("wand")) return "wand";
  if (wid.includes("sword")) return "sword";
  return null;
}

function dirVecFromAtkDir(atkDir, facing) {
  if (atkDir === "left") return { x: -1, y: 0 };
  if (atkDir === "right") return { x: 1, y: 0 };
  if (atkDir === "up") return { x: 0, y: -1 };
  if (atkDir === "down") return { x: 0, y: 1 };
  const fx = facing?.x ?? 0;
  const fy = facing?.y ?? 0;
  const ax = Math.abs(fx), ay = Math.abs(fy);
  if (ax > ay) return { x: fx >= 0 ? 1 : -1, y: 0 };
  if (ay > 0) return { x: 0, y: fy >= 0 ? 1 : -1 };
  return { x: 0, y: 1 };
}
const mobSprites = {
  green: new Image(),
  pink: new Image(),
  orange: new Image(),
  purple: new Image(),
  rainbow: new Image(),
  snail_blue: new Image(),
  snail_red: new Image(),
};
mobSprites.green.src   = "/assets/mobs/slime_green.png";
mobSprites.pink.src    = "/assets/mobs/slime_pink.png";
mobSprites.orange.src  = "/assets/mobs/slime_orange.png";
mobSprites.purple.src  = "/assets/mobs/slime_purple.png";
mobSprites.rainbow.src = "/assets/mobs/slime_rainbow.png";
mobSprites.snail_blue.src = "/assets/mobs/snail_blue.png";
mobSprites.snail_red.src  = "/assets/mobs/snail_red.png";
/* ======================
   EQUIPMENT ICONS (32x32)
====================== */
const equipIcons = {
  training_sword: new Image(),
  training_spear: new Image(),
  training_wand:  new Image(),
  cloth_armor:    new Image(),
  cloth_hat:      new Image(),
  lucky_charm:    new Image(),
  candy_cane_spear: new Image(),
  fang_spear:       new Image(),
  charger_helmet: new Image(),
  red_duke:       new Image(),
  charger_suit: new Image(),
  orange_flan: new Image(),
  potion_green: new Image(),
  potion_purple: new Image(),
};

equipIcons.training_sword.src = "/assets/equipment/training_sword.png";
equipIcons.training_spear.src = "/assets/equipment/training_spear.png";
equipIcons.training_wand.src  = "/assets/equipment/training_wand.png";
equipIcons.cloth_armor.src    = "/assets/equipment/cloth_armor.png";
equipIcons.cloth_hat.src      = "/assets/equipment/cloth_hat.png";
equipIcons.charger_helmet.src = "/assets/equipment/charger_helmet.png";
equipIcons.red_duke.src       = "/assets/equipment/red_duke.png";
equipIcons.charger_suit.src = "/assets/equipment/charger_suit.png";
equipIcons.orange_flan.src = "/assets/items/orange_flan.png";
equipIcons.lucky_charm.src    = "/assets/equipment/lucky_charm.png";
equipIcons.candy_cane_spear.src = "/assets/candy_cane_spear.png";
equipIcons.fang_spear.src       = "/assets/fang_spear.png";
equipIcons.potion_green.src  = "/assets/items/potion_green.png";
equipIcons.potion_purple.src = "/assets/items/potion_purple.png";


function drawItemIcon(itemId, x, y, slotSize) {
  const img = equipIcons[itemId];
  if (!img || !img.complete || img.naturalWidth === 0) return false;

  const ICON = 32;
  const ix = Math.round(x + (slotSize - ICON) / 2);
  const iy = Math.round(y + (slotSize - ICON) / 2);
  ctx.drawImage(img, ix, iy, ICON, ICON);
  return true;
}

/* ======================
   PAPER-DOLL OVERLAYS (48x48 frames)
====================== */
const armorOverlays = {
  cloth_armor: new Image(),
  charger_suit: new Image(),
};
armorOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_cloth_armor.png";

armorOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_charger_suit.png";
// Hat overlays for walking/moving (3 cols x 4 rows, 64x64 frames)
const hatOverlays = { cloth_hat: new Image(), charger_helmet: new Image(), red_duke: new Image() };
hatOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_cloth_hat.png";


hatOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_charger_helmet.png";
hatOverlays.red_duke.src = "/assets/equipment/overlays/overlay_red_duke.png";
// Idle overlays (2 cols x 4 rows, 64x64 frames)
const armorIdleOverlays = { cloth_armor: new Image(), charger_suit: new Image() };
armorIdleOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_idle_cloth_armor.png";
armorIdleOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_idle_charger_suit.png";
const hatIdleOverlays = { cloth_hat: new Image(), charger_helmet: new Image(), red_duke: new Image() };
hatIdleOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_idle_cloth_hat.png";




hatIdleOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_idle_charger_helmet.png";
hatIdleOverlays.red_duke.src = "/assets/equipment/overlays/overlay_idle_red_duke.png";
/* ======================
   CANVAS
====================== */
const canvas = document.getElementById("c");

// Hamburger menu button (opens inventory) — keeps 'I' hotkey too.
var invBtn = document.getElementById("invBtn");

// --- Main (hamburger) menu state ---
let mainMenuOpen = false;
let mainMenu = document.getElementById("mainMenu");

function updateMenuBtnState() {
  if (!invBtn) invBtn = document.getElementById("invBtn");
  if (!invBtn) return;
  invBtn.setAttribute("aria-expanded", mainMenuOpen ? "true" : "false");
}

function setMainMenuOpen(open) {
  mainMenuOpen = !!open;
  if (!mainMenu) mainMenu = document.getElementById("mainMenu");
  if (mainMenu) mainMenu.classList.toggle("open", mainMenuOpen);
  updateMenuBtnState();
}

function toggleMainMenu() {
  setMainMenuOpen(!mainMenuOpen);
}

// Back-compat: some places may still call updateInvBtnState from earlier patching.
function updateInvBtnState() { updateMenuBtnState(); }

// Button toggles the menu (not inventory)
if (invBtn) {
  invBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    toggleMainMenu();
  });
}

// Prevent menu clicks from interacting with the canvas (attacks / movement)
if (mainMenu) {
  mainMenu.addEventListener("pointerdown", (e) => {
    e.stopPropagation();
    // Prevent pointerdown from ever reaching the canvas
    // (helps on some browsers where pointer events behave oddly)
    e.preventDefault();
  });
}

// Close the menu when clicking outside
document.addEventListener("pointerdown", (e) => {
  if (!mainMenuOpen) return;
  const t = e.target;
  if (t === invBtn) return;
  if (mainMenu && mainMenu.contains(t)) return;
  setMainMenuOpen(false);
});

// Menu item actions (Items wired now; others can be enabled later)
if (mainMenu) {
  mainMenu.addEventListener("click", (e) => {
    // Keep menu interactions from triggering canvas actions
    e.stopPropagation();

    const btn = e.target && e.target.closest ? e.target.closest(".main-menu-item") : null;
    if (!btn) return;
    if (btn.disabled || btn.classList.contains("disabled")) return;

    const action = btn.getAttribute("data-action");
    if (action === "items") {
      toggleInventory();
      setMainMenuOpen(false);
      return;
    }
    if (action === "skills") {
      toggleSkills();
      setMainMenuOpen(false);
      return;
    }
  });
}
// Escape closes the menu (and keeps existing ESC behavior elsewhere)
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && mainMenuOpen) {
    setMainMenuOpen(false);
  }
});


function updateInvBtnState() {
  // If this runs before invBtn is assigned, try to grab it.
  if (!invBtn) invBtn = document.getElementById("invBtn");
  if (!invBtn) return;
  invBtn.setAttribute("aria-expanded", inventoryOpen ? "true" : "false");
}

function guessWeaponTab() {
  const me = worldPlayers && worldPlayers[myId];
  const w = me?.equipment?.weapon ?? me?.weapon ?? null;
  const wid = (typeof w === "string") ? w : (w && typeof w === "object" ? (w.id || w.itemId || w.type) : "");
  const s = String(wid || "").toLowerCase();
  if (s.includes("spear")) return "spear";
  if (s.includes("wand")) return "wand";
  if (s.includes("sword")) return "sword";
  return "wand";
}

function toggleSkills() {
  skillsOpen = !skillsOpen;
  pendingSkillBind = null;

  if (skillsOpen) {
    // Only show one window at a time for now
    inventoryOpen = false;
    invUI = null;
    invHover = null;

    // pick a reasonable default tab (based on equipped weapon)
    skillsTab = guessWeaponTab();

    // lazy init window position
    if (skillsWinX == null || skillsWinY == null) {
      skillsWinX = Math.floor(canvas.width / 2 - 190);
      skillsWinY = Math.floor(canvas.height / 2 - 170);
    }
  }

  skillsDragging = false;
}

function toggleInventory() {
  inventoryOpen = !inventoryOpen;

  if (inventoryOpen) {
    invItemMenu = null;
    invItemMenuUI = null;
    pendingItemBind = null;

    skillsOpen = false;
    skillsUI = null;
    skillsDragging = false;
  }
  // lazy init window position
  if (inventoryOpen && (invWinX == null || invWinY == null)) {
    invWinX = Math.floor(canvas.width / 2 - 180);
    invWinY = Math.floor(canvas.height / 2 - 180);
  }

  if (!inventoryOpen) {
    invDragging = false;
    invItemMenu = null;
    invItemMenuUI = null;
    pendingItemBind = null;
  }

  updateInvBtnState();
}

const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// Hit-flash uses an offscreen canvas; cache per sprite size.
const fxCache = new Map(); // key: "{w}x{h}" => { c, ctx }
function getFxCtx(w, h) {
  const key = `${w}x${h}`;
  let entry = fxCache.get(key);
  if (!entry) {
    const c = document.createElement("canvas");
    c.width = w;
    c.height = h;
    const ctx2 = c.getContext("2d");
    ctx2.imageSmoothingEnabled = false;
    entry = { c, ctx: ctx2 };
    fxCache.set(key, entry);
  }
  return entry;
}


/* ======================
   FADE TRANSITION
====================== */
let fadeState = "none";
let fadeA = 0;
let fadeTimer = 0;
let portalSent = false;
let portalWaitTimer = 0;

// Small local throttle to avoid spamming portal requests (server also enforces its own cooldown)
let nextPortalAtMs = 0;
const PORTAL_COOLDOWN_MS = 450;

const FADE_OUT_DUR = 0.18;
const FADE_IN_DUR  = 0.18;

function startPortalFade() {
  if (fadeState !== "none") return;

  const nowMs = performance.now();
  if (nowMs < nextPortalAtMs) return;
  nextPortalAtMs = nowMs + PORTAL_COOLDOWN_MS;

  fadeState = "fadingOut";
  fadeTimer = 0;
  fadeA = 0;
  portalSent = false;
  portalWaitTimer = 0;

  // Send portal request immediately
  portalSent = true;
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "portal" }));

  // Freeze movement instantly
  keys.up = keys.down = keys.left = keys.right = false;
  sendInput();
}

function updateFade(dt) {
  if (fadeState === "none") return;
  fadeTimer += dt;

  if (fadeState === "fadingOut") {
    fadeA = Math.min(fadeTimer / FADE_OUT_DUR, 1);
    if (fadeTimer >= FADE_OUT_DUR) {
      fadeState = "waitingMap";
      fadeA = 1;
      portalWaitTimer = 0;
    }
  } else if (fadeState === "waitingMap") {
    fadeA = 1;
    portalWaitTimer += dt;

    // Safety fallback — never stay black forever
    if (portalWaitTimer > 1.2) {
      fadeState = "fadingIn";
      fadeTimer = 0;
      levelToastText = "Portal failed — stand fully on portal and press E";
      levelToastUntilMs = performance.now() + 2400;
    }
  } else if (fadeState === "fadingIn") {
    fadeA = 1 - Math.min(fadeTimer / FADE_IN_DUR, 1);
    if (fadeTimer >= FADE_IN_DUR) {
      fadeState = "none";
      fadeA = 0;
    }
  }
}

function drawFadeOverlay() {
  if (fadeA <= 0) return;
  ctx.save();
  ctx.globalAlpha = fadeA;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
/* ======================
   NETWORK
====================== */
const wsProto = (location.protocol === "https:") ? "wss" : "ws";
const ws = new WebSocket(`${wsProto}://${location.host}`);

function wsSend(obj) {
  if (!ws || ws.readyState !== 1) return false;
  try {
    ws.send(JSON.stringify(obj));
    return true;
  } catch {
    return false;
  }
}

// --- Server clock sync (Render can be ~0-2s ahead/behind your PC clock).
// Server timestamps (startMs/endMs/cooldowns) are serverNowMs()-based epoch ms.
// We estimate the offset so visuals/cooldowns line up instantly everywhere.
let serverClockOffsetMs = 0; // localNow - serverNow
let haveServerClock = false;
function serverNowMs() { return Date.now() - serverClockOffsetMs; }

let myName = null;
let nameSent = false;

function promptForName() {
  // Only prompt once per page load unless rejected.
  while (true) {
    const raw = window.prompt("Enter your name (letters only, 4-8 chars):", myName || "") || "";
    const name = raw.trim();
    if (/^[A-Za-z]{4,8}$/.test(name)) {
      myName = name;
      if (ws.readyState === 1) {
        ws.send(JSON.stringify({ type: "setName", name }));
        nameSent = true;
      }
      break;
    }
    alert("Name must be letters only, 4-8 characters.");
  }
}

ws.addEventListener("open", () => {
  promptForName();
});


let myId = null;
let map = null;
let objMap = null;
let currentMapId = null;
let portals = []; // [{x,y,to,...}] current map portal positions

let worldPlayers = {};
let worldNpcs = {};
let worldMobs = {};

// Spawn fade-in tracking (client-side)
const MOB_SPAWN_FADE_MS = 200; // how long mobs fade in after spawning/respawning
const mobSpawnAtMs = new Map(); // mobId -> performance.now() when it became alive
let worldDrops = {};
let worldProjectiles = {};
let whirlpools = []; // active skill1 vortices from server [{x,y,rad,endMs,...}]

const netState = new Map();

/* --- HIT FX STATE --- */
const hitFx = new Map();
let screenShakeUntilMs = 0;
let screenShakeMag = 0;

function startScreenShake(mag = 4, ms = 140) {
  screenShakeMag = Math.max(screenShakeMag, mag);
  screenShakeUntilMs = Math.max(screenShakeUntilMs, performance.now() + ms);
}


/* ======================
   SKILLS UI (Tabbed)
====================== */
function drawSkillsMenu() {
  const tabs = ["sword", "spear", "wand"];
  const tabLabels = { sword: "Sword", spear: "Spear", wand: "Wand" };

  // Basic skill catalog (placeholder-friendly)
  const skillCatalog = {
    sword: [],
    spear: [
      {
        id: "skill2",
        name: "Double Stab",
        key: "2",
        icon: skill2IconImg,
        desc: "Stab twice quickly. Requires a spear.",
      },
    ],
    wand: [
      {
        id: "skill1",
        name: "Whirlpool Bolt",
        key: "1",
        icon: skill1IconImg,
        desc: "Shoot a bolt that creates a whirlpool on impact. Requires a wand.",
      },
    ],
  };

  const HEADER_H = 26;
  const TAB_H = 26;
  const PAD = 14;

  const panelW = 380;
  const panelH = 320;

  // init window if needed
  if (skillsWinX == null || skillsWinY == null) {
    skillsWinX = Math.floor(canvas.width / 2 - panelW / 2);
    skillsWinY = Math.floor(canvas.height / 2 - panelH / 2);
  }

  // clamp to screen
  skillsWinX = clamp(skillsWinX, 10, canvas.width - panelW - 10);
  skillsWinY = clamp(skillsWinY, 10, canvas.height - panelH - 10);

  const x = skillsWinX;
  const y = skillsWinY;
  const w = panelW;
  const h = panelH;

  skillsWinW = w;
  skillsWinH = h;

  // panel
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.80)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

  // header
  ctx.fillStyle = "rgba(255,255,255,0.08)";
  ctx.fillRect(x, y, w, HEADER_H);
  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.font = "13px system-ui, sans-serif";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";
  ctx.fillText("Skills", x + 10, y + HEADER_H / 2);

  // close button
  const closeSize = 18;
  const cx = x + w - closeSize - 6;
  const cy = y + (HEADER_H - closeSize) / 2;
  ctx.fillStyle = "rgba(255,255,255,0.10)";
  ctx.fillRect(cx, cy, closeSize, closeSize);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(cx + 0.5, cy + 0.5, closeSize - 1, closeSize - 1);
  ctx.fillStyle = "rgba(255,255,255,0.80)";
  ctx.textAlign = "center";
  ctx.fillText("×", cx + closeSize / 2, cy + closeSize / 2 + 0.5);

  skillsCloseRect = { x: cx, y: cy, w: closeSize, h: closeSize };
  skillsHeaderRect = { x, y, w, h: HEADER_H };

  // tabs
  const tabY = y + HEADER_H;
  const tabW = Math.floor((w - PAD * 2) / tabs.length);
  const tabX0 = x + PAD;

  skillsTabRects = {};
  for (let i = 0; i < tabs.length; i++) {
    const t = tabs[i];
    const tx = tabX0 + i * tabW;
    const active = (skillsTab === t);

    ctx.fillStyle = active ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.06)";
    ctx.fillRect(tx, tabY, tabW - 6, TAB_H);
    ctx.strokeStyle = active ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.14)";
    ctx.strokeRect(tx + 0.5, tabY + 0.5, tabW - 6 - 1, TAB_H - 1);

    ctx.fillStyle = active ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.70)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(tabLabels[t], tx + (tabW - 6) / 2, tabY + TAB_H / 2);

    skillsTabRects[t] = { x: tx, y: tabY, w: tabW - 6, h: TAB_H };
  }

  // content area
  const contentX = x + PAD;
  const contentY = tabY + TAB_H + 10;
  const contentW = w - PAD * 2;
  const contentH = h - (contentY - y) - PAD;

  ctx.fillStyle = "rgba(255,255,255,0.04)";
  ctx.fillRect(contentX, contentY, contentW, contentH);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.strokeRect(contentX + 0.5, contentY + 0.5, contentW - 1, contentH - 1);

  const list = skillCatalog[skillsTab] || [];
  skillsItemRects = [];

  const cardH = 62;
  const iconS = 34;
  const gap = 10;

  if (list.length === 0) {
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("No skills yet for this weapon.", contentX + contentW / 2, contentY + 26);
    ctx.fillStyle = "rgba(255,255,255,0.40)";
    ctx.fillText("Add more skills later and they'll show up here.", contentX + contentW / 2, contentY + 46);
  } else {
    for (let i = 0; i < list.length; i++) {
      const s = list[i];
      const cy2 = contentY + 10 + i * (cardH + 10);
      const cardX = contentX + 10;
      const cardW = contentW - 20;

      // card bg
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(cardX, cy2, cardW, cardH);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(cardX + 0.5, cy2 + 0.5, cardW - 1, cardH - 1);

      // icon box
      const ix = cardX + 10;
      const iy = cy2 + Math.floor((cardH - iconS) / 2);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(ix, iy, iconS, iconS);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(ix + 0.5, iy + 0.5, iconS - 1, iconS - 1);

      // draw icon if ready
      const img = s.icon;
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, ix + 1, iy + 1, iconS - 2, iconS - 2);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.18)";
        ctx.font = "10px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("ICON", ix + iconS / 2, iy + iconS / 2);
      }

      // name + desc
      const tx = ix + iconS + gap;
      ctx.textAlign = "left";
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "13px system-ui, sans-serif";
      ctx.fillText(s.name, tx, cy2 + 18);

      ctx.fillStyle = "rgba(255,255,255,0.62)";
      ctx.font = "11px system-ui, sans-serif";
      ctx.fillText(s.desc, tx, cy2 + 38);

      // key badge
      const badge = hotbarKeyForSkill(s.id);
      const bw = 28;
      const bh = 18;
      const bx = cardX + cardW - bw - 10;
      const by = cy2 + 12;

      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(bx, by, bw, bh);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(bx + 0.5, by + 0.5, bw - 1, bh - 1);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(badge, bx + bw / 2, by + bh / 2);

      // assign button (click to bind to a hotbar key)
      const abw = 62;
      const abh = 18;
      const abx = cardX + cardW - abw - 10;
      const aby = by + bh + 8;

      const isBinding = !!(pendingSkillBind && pendingSkillBind.skillId === s.id);

      ctx.fillStyle = isBinding ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.08)";
      ctx.fillRect(abx, aby, abw, abh);
      ctx.strokeStyle = isBinding ? "rgba(255,255,255,0.32)" : "rgba(255,255,255,0.18)";
      ctx.strokeRect(abx + 0.5, aby + 0.5, abw - 1, abh - 1);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(isBinding ? "Press 1-6" : "Assign", abx + abw / 2, aby + abh / 2);

      skillsItemRects.push({
        id: s.id,
        rect: { x: cardX, y: cy2, w: cardW, h: cardH },
        badgeRect: { x: bx, y: by, w: bw, h: bh },
        assignRect: { x: abx, y: aby, w: abw, h: abh }
      });
    }
  }

  ctx.restore();

  // expose hit-test data
  skillsUI = {
    x, y, w, h,
    close: skillsCloseRect,
    header: skillsHeaderRect,
    tabs: skillsTabRects,
    items: skillsItemRects,
  };
}


/* --- DAMAGE POPUPS --- */
const damagePops = []; // {x,y,text,color,untilMs}

/* --- HIT SPARKS (impact bursts) --- */
const hitSparks = []; // {x,y,dir,untilMs}

/**
 * Direction-specific anchor so impacts feel "heavier".
 * We bias sparks toward the side the hit came from (relative to the TARGET sprite).
 */
function getHitSparkOffset(dir, kind) {
  // Tweak these 4 numbers if you want different "impact points".
  // Player sprites are 64x64; mobs are 48x48, but these offsets read well for both.
  const common = {
    [DIR.RIGHT]: { x:  22, y:  -6 },
    [DIR.LEFT]:  { x: -22, y:  -6 },
    [DIR.DOWN]:  { x:   0, y:  14 },
    [DIR.UP]:    { x:   0, y: -22 },
  }[dir] || { x: 0, y: 0 };

  // Slightly closer-in for mobs so it doesn't look like it's floating off the slime.
  if (kind === "mob") {
    return { x: Math.round(common.x * 0.85), y: Math.round(common.y * 0.85) };
  }
  return common;
}

function spawnHitSparksAt(x, y, dir, kind) {
  const now = performance.now();
  const off = getHitSparkOffset(dir, kind);

  // 1 "main" spark burst + a couple secondary pops
  const baseX = x + off.x;
  const baseY = y + off.y;

  hitSparks.push({ x: baseX, y: baseY, dir, untilMs: now + 160 });
  hitSparks.push({ x: baseX + rand(-4, 4), y: baseY + rand(-3, 3), dir, untilMs: now + 120 });
  hitSparks.push({ x: baseX + rand(-6, 6), y: baseY + rand(-4, 4), dir, untilMs: now + 100 });
}

function drawHitSparks() {
  const now = performance.now();

  for (let i = hitSparks.length - 1; i >= 0; i--) {
    const s = hitSparks[i];
    if (now > s.untilMs) { hitSparks.splice(i, 1); continue; }

    const life = 170;
    const t = clamp(1 - ((s.untilMs - now) / life), 0, 1);
    const alpha = clamp(1 - t, 0, 1);

    // small outward "burst"
    const burst = Math.round(6 + t * 10);

    // direction-biased drift (so it "kicks" in the hit direction)
    let dx = 0, dy = 0;
    if (s.dir === DIR.RIGHT) dx = 1;
    else if (s.dir === DIR.LEFT) dx = -1;
    else if (s.dir === DIR.DOWN) dy = 1;
    else if (s.dir === DIR.UP) dy = -1;

    const cx = Math.round(s.x + dx * t * 6);
    const cy = Math.round(s.y + dy * t * 6);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";

    // starburst: 4 lines
    ctx.beginPath();
    ctx.moveTo(cx - burst, cy); ctx.lineTo(cx + burst, cy);
    ctx.moveTo(cx, cy - burst); ctx.lineTo(cx, cy + burst);
    ctx.moveTo(cx - burst + 2, cy - burst + 2); ctx.lineTo(cx + burst - 2, cy + burst - 2);
    ctx.moveTo(cx - burst + 2, cy + burst - 2); ctx.lineTo(cx + burst - 2, cy - burst + 2);
    ctx.stroke();

    ctx.restore();
  }
}

// tiny helper
function rand(a, b) { return a + Math.random() * (b - a); }


/* --- LOOT POPUPS --- */
const lootPops = []; // {x,y,text,untilMs}

function upsertNet(id, x, y, now) {
  const WARP_DIST = TILE_SIZE * 3;

  if (!netState.has(id)) {
    netState.set(id, {
      prev: { x, y, t: now },
      curr: { x, y, t: now },
      vx: 0, vy: 0,
      smoothX: x, smoothY: y
    });
    return;
  }

  const s = netState.get(id);

  const dxWarp = x - s.curr.x;
  const dyWarp = y - s.curr.y;
  if (Math.hypot(dxWarp, dyWarp) > WARP_DIST) {
    s.prev = { x, y, t: now };
    s.curr = { x, y, t: now };
    s.vx = 0; s.vy = 0;
    s.smoothX = x; s.smoothY = y;
    return;
  }

  const old = s.curr;
  s.prev = s.curr;
  s.curr = { x, y, t: now };

  const dt = s.curr.t - old.t;
  if (dt > 0.0001) {
    s.vx = (s.curr.x - old.x) / dt;
    s.vy = (s.curr.y - old.y) / dt;
  }
}

let activeDialogue = null;

// level toast
let levelToastUntilMs = 0;
let levelToastText = "";

ws.onmessage = (e) => {
  const msg = JSON.parse(e.data);

  if (msg.type === "nameRejected") {
    // Re-prompt (server-side validation is source of truth)
    nameSent = false;
    setTimeout(promptForName, 0);
    return;
  }
  if (msg.type === "nameAccepted") {
    myName = msg.name || myName;
    return;
  }



  if (msg.type === "skill2Fx") {
    // Map-scoped visual cue for double-stab spear scaling/jut
    if (msg.casterId != null && typeof msg.startMs === "number") {
      skill2FxByCaster.set(String(msg.casterId), { startMs: msg.startMs });
    }
    return;
  }

  if (msg.type === "welcome") {
    myId = msg.id;
    map = msg.map;
    objMap = msg.objMap || objMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    currentMapId = msg.mapId ?? currentMapId;

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;
    return;
  }

  if (msg.type === "snapshot") {
    if (typeof msg.nowMs === "number") {
      const sample = Date.now() - msg.nowMs; // local - server
      if (!haveServerClock) { serverClockOffsetMs = sample; haveServerClock = true; }
      else { serverClockOffsetMs = serverClockOffsetMs * 0.9 + sample * 0.1; } // smooth
    }

    const now = performance.now() / 1000;

    const newMapId = msg.mapId ?? currentMapId;
    const mapChanged = (currentMapId != null && newMapId !== currentMapId);
    currentMapId = newMapId;

    if (msg.map) map = msg.map;
    if (msg.objMap) objMap = msg.objMap;

if (Array.isArray(msg.whirlpools)) whirlpools = msg.whirlpools;

    // Skill 1 timers for local HUD/hotbar
    const _nowAbs = serverNowMs();
    if (typeof msg.selfSkill1ActiveUntilMs === "number") {
      skill1ActiveUntilMs = msg.selfSkill1ActiveUntilMs;
      if (skill1ActiveUntilMs > _nowAbs && skill1ActiveUntilMs !== _lastSkill1ActiveUntilMs) {
        skill1ActiveTotalMs = Math.max(0, skill1ActiveUntilMs - _nowAbs);
        _lastSkill1ActiveUntilMs = skill1ActiveUntilMs;
      }
    }
    if (typeof msg.selfSkill1CdUntilMs === "number") {
      skill1CdUntilMs = msg.selfSkill1CdUntilMs;
      if (skill1CdUntilMs > _nowAbs && skill1CdUntilMs !== _lastSkill1CdUntilMs) {
        skill1CdTotalMs = Math.max(0, skill1CdUntilMs - _nowAbs);
        _lastSkill1CdUntilMs = skill1CdUntilMs;
      }

    // Skill 2 timers for local HUD/hotbar
    if (typeof msg.selfSkill2CdUntilMs === "number") {
      skill2CdUntilMs = msg.selfSkill2CdUntilMs;
      if (skill2CdUntilMs > _nowAbs && skill2CdUntilMs !== _lastSkill2CdUntilMs) {
        skill2CdTotalMs = Math.max(0, skill2CdUntilMs - _nowAbs);
        _lastSkill2CdUntilMs = skill2CdUntilMs;
      }
    }

    }

    objMap = msg.objMap || objMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;

    worldPlayers = msg.players || {};
    worldNpcs = msg.npcs || {};
    const prevMobs = worldMobs;
    worldMobs = msg.mobs || {};
    worldDrops = msg.drops || {};
	worldProjectiles = msg.projectiles || {};
    // Track mob spawn/respawn so we can fade them in smoothly
    const nowMs = performance.now();
    for (const [id, mob] of Object.entries(worldMobs)) {
      const prev = prevMobs ? prevMobs[id] : undefined;
      const wasDead = !!prev?.dead;
      const isAliveNow = !mob?.dead;
      const isNew = !prev;
      if (isAliveNow && (isNew || wasDead)) {
        mobSpawnAtMs.set(id, nowMs);
      }
    }
    // Clean up spawn timestamps for mobs that no longer exist
    for (const id of Array.from(mobSpawnAtMs.keys())) {
      if (!worldMobs[id]) mobSpawnAtMs.delete(id);
    }


    for (const [id, p] of Object.entries(worldPlayers)) upsertNet(id, p.x, p.y, now);
    for (const [id, n] of Object.entries(worldNpcs)) upsertNet(id, n.x, n.y, now);
    for (const [id, m0] of Object.entries(worldMobs)) upsertNet(id, m0.x, m0.y, now);

    const alive = new Set([
      ...Object.keys(worldPlayers),
      ...Object.keys(worldNpcs),
      ...Object.keys(worldMobs),
    ]);
    for (const id of Array.from(netState.keys())) if (!alive.has(id)) netState.delete(id);

	if (mapChanged) {
	  // Always resolve fade if map actually changed
	  fadeState = "fadingIn";
	  fadeTimer = 0;
	}

    return;
  }


  if (msg.type === "mapPatch") {
    // Small server-authoritative map edit (used by the in-game editor)
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    if (!Number.isInteger(tx) || !Number.isInteger(ty) || !Number.isInteger(tile)) return;
    if (!map || ty < 0 || tx < 0 || ty >= map.length || tx >= map[0].length) return;

    if (layer === "ground") {
      map[ty][tx] = tile;
    } else if (layer === "object") {
      if (!objMap) objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
      objMap[ty][tx] = tile;
    }
    return;
  }


  if (msg.type === "editAck") {
    // Server response for editor edits (helps diagnose why something "didn't work")
    const ok = !!msg.ok;
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    const reason = msg.reason ? String(msg.reason) : "";
    if (ok) {
      levelToastText = `Edit OK: ${layer} (${tx},${ty}) = ${tile}`;
    } else {
      levelToastText = `Edit REJECTED: ${layer} (${tx},${ty}) = ${tile}${reason ? ` (${reason})` : ""}`;
    }
    levelToastUntilMs = performance.now() + 2500;
    return;
  }


  if (msg.type === "dialogue") {
    activeDialogue = {
      npcId: msg.npcId,
      npcName: msg.npcName || msg.npcId,
      text: msg.text || "",
      untilMs: performance.now() + 4000
    };
    return;
  }

  if (msg.type === "hit") {
    const targetId = String(msg.targetId || "");
    const kind = msg.targetKind || "mob";
    const amount = Number(msg.amount || 0);

    const srcX = +msg.srcX || 0;
    const srcY = +msg.srcY || 0;

    let tx = 0, ty = 0;
    const rawP = worldPlayers[targetId];
    const rawM = worldMobs[targetId];

    if (rawP) { tx = rawP.x; ty = rawP.y; }
    else if (rawM) { tx = rawM.x; ty = rawM.y; }

    if (amount > 0 && (rawP || rawM)) {
      damagePops.push({
        x: tx,
        y: ty - 10,
        text: `${amount}`,
        color: (kind === "player") ? "#ff6b6b" : "#ffffff",
        untilMs: performance.now() + 650
      });
    }

    const dx = tx - srcX;
    const dy = ty - srcY;
    const l = Math.hypot(dx, dy) || 1;
    const ax = dx / l, ay = dy / l;

    // Direction-specific impact sparks (world-space)
    const sparkDir = dirFromVector(ax, ay) ?? DIR.DOWN;
    if (rawP || rawM) spawnHitSparksAt(tx, ty, sparkDir, kind);

    const isMe = (targetId === myId);

    hitFx.set(targetId, {
      untilMs: performance.now() + 220,
      color: (kind === "player") ? "rgba(255,0,0,0.45)" : "rgba(255,255,255,0.45)",
      bumpX: ax * 6,
      bumpY: ay * 6,
    });

    if (isMe) startScreenShake(5, 160);
    return;
  }

  if (msg.type === "levelup") {
    levelToastText = `LEVEL UP!  Lv ${msg.level}`;
    levelToastUntilMs = performance.now() + 1600;
    return;
  }

  if (msg.type === "loot") {
    const me = getMyPos();
    if (me && msg.kind === "gold") {
      lootPops.push({
        x: me.x,
        y: me.y - 18,
        text: `+${msg.amount}g`,
        untilMs: performance.now() + 700
      });
    }
    return;
  }
};

/* ======================
   INPUT
====================== */
const keys = { up:false, down:false, left:false, right:false };
let lastEPressed = 0;

function sendInput() {
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "input", ...keys }));
}

function setMoveKey(e, down) {
  if (fadeState !== "none") return;
  const k = e.key.toLowerCase();
  if (k === "w" || e.key === "ArrowUp") keys.up = down;
  if (k === "s" || e.key === "ArrowDown") keys.down = down;
  if (k === "a" || e.key === "ArrowLeft") keys.left = down;
  if (k === "d" || e.key === "ArrowRight") keys.right = down;
  sendInput();
}

function getMouseWorldFromEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  return { mx, my, wx: camX + mx, wy: camY + my };
}


// Keep an updated mouse->world aim point even when you aren't clicking.
// This lets keyboard-triggered skills aim in the same direction as click-attacks.
canvas.addEventListener("mousemove", (e) => {
  // Track cursor for both aiming and UI hover.
  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);
  uiMouse.mx = mx; uiMouse.my = my; uiMouse.has = true;
  lastAim.mx = mx;
  lastAim.my = my;
  lastAim.wx = wx;
  lastAim.wy = wy;
  lastAim.has = true;
});


function dirFromVector(dx, dy) {
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);
  if (ax < 1e-3 && ay < 1e-3) return null;
  if (ax > ay) return dx >= 0 ? DIR.RIGHT : DIR.LEFT;
  return dy >= 0 ? DIR.DOWN : DIR.UP;
}

function calcAimFromWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return null;
  // Derive aim direction from screen-space (mouse relative to the player's rendered position).
  // This avoids "opposite direction" when camera smoothing lags behind the server position.
  let dx = wx - me.x;
  let dy = wy - me.y;
  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }
  const dir = dirFromVector(dx, dy);
  const len = Math.hypot(dx, dy) || 1;
  return { me, dx, dy, dir, aimDirX: dx / len, aimDirY: dy / len };
}

function sendAttackAtWorld(wx, wy, mx = null, my = null, extra = null) {
  const aim = calcAimFromWorld(wx, wy, mx, my);
  if (!aim) return;
  const { me, dir: d, aimDirX, aimDirY } = aim;

  // drive local attack animation direction immediately
  if (d != null) {
    // Update facing immediately so the server sees your intended direction,
    // but DO NOT start a local swing animation here. We only animate when the server accepts the attack.
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  const payload = { type: "attack", aimX: wx, aimY: wy, aimDirX, aimDirY };
  if (extra && typeof extra === "object") Object.assign(payload, extra);
  wsSend(payload);
}

function sendAttack() {
  const me = worldPlayers[myId];
  const wid = me?.equipment?.weapon;
  if (!wid) {
    levelToastText = "Equip a weapon to attack";
    levelToastUntilMs = performance.now() + 1800;
    return;
  }
  // fallback: attack in current facing (server will use last facing)
  const nowMs = performance.now();
  if (nowMs < nextAttackAtMs) return;
  nextAttackAtMs = nowMs + ATTACK_DELAY_MS;
  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "attack" }));
}

function sendInvClick(slot) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "invClick", slot }));
}

function sendUnequip(slotName) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "unequip", slot: slotName }));
}

function sendSkill1Arm() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill1Arm" }));
}


function sendSkill2DoubleStabAtWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return;

  // Derive aim direction from screen-space (mouse relative to the player's rendered position),
  // matching sendAttackAtWorld().
  let dx = wx - me.x;
  let dy = wy - me.y;

  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }

  const d = dirFromVector(dx, dy);

  // Drive local facing immediately (no local swing; we still wait for server atkAnim)
  if (d != null) {
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  const len = Math.hypot(dx, dy) || 1;
  const aimDirX = dx / len;
  const aimDirY = dy / len;

  if (ws.readyState === 1) {
    ws.send(JSON.stringify({ type: "skill2DoubleStab", aimX: wx, aimY: wy, aimDirX, aimDirY }));
  }
}

function sendSkill2DoubleStab() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill2DoubleStab" }));
}






window.addEventListener("keydown", (e) => {
  const key = e.key;
  const k = key.toLowerCase();

  // If the Skills menu is waiting for a hotbar key, capture 1–6 (or Esc to cancel).
  if (pendingSkillBind) {
    if (key === "Escape") {
      e.preventDefault();
      pendingSkillBind = null;
      hotbarToast("Skill bind canceled");
      return;
    }
    if (!e.repeat && k >= "1" && k <= "6") {
      e.preventDefault();
      bindHotbarSkill(Number(k), pendingSkillBind.skillId);
      pendingSkillBind = null;
      return;
    }
    // While binding, don't let number keys trigger other actions.
    if (k >= "1" && k <= "6") {
      e.preventDefault();
      return;
    }
  }

  // If the Inventory item bind flow is waiting for a hotbar key, capture 1–6 (or Esc to cancel).
  if (pendingItemBind) {
    if (key === "Escape") {
      e.preventDefault();
      pendingItemBind = null;
      hotbarToast("Item bind canceled");
      return;
    }
    if (!e.repeat && k >= "1" && k <= "6") {
      e.preventDefault();
      bindHotbarItem(Number(k), pendingItemBind.itemId, pendingItemBind.preferSlot);
      pendingItemBind = null;
      return;
    }
    // swallow other keys while binding an item
    if (!e.repeat) {
      e.preventDefault();
      return;
    }
  }


  // Debug editor hotkeys
  if (key === "F1") {
    e.preventDefault();
    if (!e.repeat) {
      editorOpen = !editorOpen;
      // reset selection for layer
      editorTileIndex = 0;
      editorSetTileIndexByValue(0);
      levelToastText = editorOpen ? "Editor ON (TAB layer, [ ] tile, Ctrl+E export)" : "Editor OFF";
      levelToastUntilMs = performance.now() + 2200;
    }
    return;
  }

  // Debug collision overlay
  if (key === "F3") {
    e.preventDefault();
    if (!e.repeat) {
      debugHitboxes = !debugHitboxes;
      levelToastText = debugHitboxes ? "Hitboxes ON" : "Hitboxes OFF";
      levelToastUntilMs = performance.now() + 1600;
    }
    return;
  }

  if (editorOpen) {
    // Don't let movement keys interfere while editing unless you want them.
    if (key === "Tab") {
      e.preventDefault();
      editorLayer = (editorLayer === "ground") ? "object" : "ground";
      editorTileIndex = 0;
      editorSetTileIndexByValue(0);
      return;
    }

    if (key === "[") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex - 1 + list.length) % list.length;
      return;
    }
    if (key === "]") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex + 1) % list.length;
      return;
    }

    if (k === "g") {
      e.preventDefault();
      editorShowGrid = !editorShowGrid;
      return;
    }

    if (k === "c") {
      e.preventDefault();
      editorShowColl = !editorShowColl;
      return;
    }

    if ((e.ctrlKey || e.metaKey) && k === "e") {
      e.preventDefault();
      exportCurrentMapToClipboard();
      return;
    }
  }

  // Toggle Skills
  if (k === "k") {
    e.preventDefault();
    if (!e.repeat) {
      if (typeof setMainMenuOpen === "function") setMainMenuOpen(false);
      toggleSkills();
    }
    return;
  }

  // Toggle Inventory
  if (k === "i") {
    e.preventDefault();
    if (!e.repeat) {
      if (typeof setMainMenuOpen === "function") setMainMenuOpen(false);
      toggleInventory();
    }
    return;
  }

  // Hotbar 1..6 (use or bind)
  if (k >= "1" && k <= "6") {
    e.preventDefault();
    if (e.repeat) return;

    const n = Number(k);

    // Ctrl/Cmd+number binds hovered inventory item (grid) to that hotbar slot
    if (e.ctrlKey || e.metaKey) {
      if (inventoryOpen && typeof invHover !== "undefined" && invHover && invHover.source === "grid") {
        bindHotbarItem(n, invHover.id, invHover.slotIndex);
        return;
      }
      hotbarToast("Hover an inventory item then press Ctrl+1-6 to bind");
      return;
    }

    useHotbarSlot(n);
    return;
  }

  // Interact
  if (k === "e") {
    e.preventDefault();
    const now = performance.now();
    if (!e.repeat && now - lastEPressed > 200) {
      lastEPressed = now;
      if (isOnPortal()) startPortalFade();
      else tryInteract();
    }
    return;
  }

  setMoveKey(e, true);
});


window.addEventListener("keyup", (e) => setMoveKey(e, false));

// Editor painting
canvas.addEventListener("contextmenu", (e) => {
  if (!editorOpen) return;
  e.preventDefault();
});

canvas.addEventListener("mousemove", (e) => {
  if (!editorOpen) return;
  const rect = canvas.getBoundingClientRect();
  editorMouseX = e.clientX - rect.left;
  editorMouseY = e.clientY - rect.top;
  editorMouseHas = true;
});

canvas.addEventListener("mouseleave", () => { editorMouseHas = false; });

// Inventory tooltip hover reset
canvas.addEventListener("mouseleave", () => { uiMouse.has = false; });

canvas.addEventListener("mousedown", (e) => {


  if (!editorOpen) return;

  // If inventory is open and click is inside it, let inventory handle it.
  if (inventoryOpen && invUI) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // treat inventory window as a block region
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory mousedown run
    }
  }

  e.preventDefault();
  e.stopImmediatePropagation();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (!map) return;
  const tx = Math.floor((camX + mx) / TILE_SIZE);
  const ty = Math.floor((camY + my) / TILE_SIZE);
  if (tx < 0 || ty < 0 || ty >= map.length || tx >= map[0].length) return;

  const isRight = (e.button === 2);
  const tile = isRight ? 0 : editorSelectedTile();

  if (editorLayer === "ground") {
    // keep portals/statues intact (server also validates)
    const curr = map[ty][tx];
    if (curr === PORTAL_TILE) return;
    map[ty][tx] = tile;
    sendEditTile("ground", tx, ty, tile);
  } else {
    if (!objMap) {
      objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
    }
    objMap[ty][tx] = tile;
    sendEditTile("object", tx, ty, tile);
  }
});

// Inventory click handling (equip / use / consume)
canvas.addEventListener("mousedown", (e) => {
  if (!inventoryOpen || !invUI) return;

  // Inventory consumes clicks (including the close X) so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // If an item submenu is open, handle it first.
  if (invItemMenu && invItemMenuUI) {
    if (rectHit(invItemMenuUI.panel, mx, my)) {
      if (rectHit(invItemMenuUI.btnUse, mx, my)) {
        sendInvClick(invItemMenu.slotIndex);
        invItemMenu = null;
        invItemMenuUI = null;
        return;
      }
      if (rectHit(invItemMenuUI.btnBind, mx, my)) {
        pendingItemBind = { itemId: invItemMenu.itemId, preferSlot: invItemMenu.slotIndex };
        invItemMenu = null;
        invItemMenuUI = null;
        hotbarToast("Press 1–6 to bind item (Esc to cancel)");
        return;
      }
      return; // clicked inside the panel but not on a button
    } else {
      // click outside closes the submenu (and continues)
      invItemMenu = null;
      invItemMenuUI = null;
    }
  }


  // close button
  if (invCloseRect && mx >= invCloseRect.x && mx <= invCloseRect.x + invCloseRect.w && my >= invCloseRect.y && my <= invCloseRect.y + invCloseRect.h) {
    e.preventDefault();
    e.stopImmediatePropagation();
    inventoryOpen = false;
    invDragging = false;
    return;
  }

  // drag header (but not when clicking inside slots)
  if (invHeaderRect && mx >= invHeaderRect.x && mx <= invHeaderRect.x + invHeaderRect.w && my >= invHeaderRect.y && my <= invHeaderRect.y + invHeaderRect.h) {
    invDragging = true;
    invDragOffX = mx - invWinX;
    invDragOffY = my - invWinY;
    return;
  }

  // equipment slots
  for (const [slotName, r] of Object.entries(invUI.equipSlots)) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      // If it is already equipped, unequip. If empty, server will ignore.
      sendUnequip(slotName);
      return;
    }
  }

  // inventory grid
  const g = invUI.grid;
  if (mx < g.x || my < g.y || mx > g.x + g.w || my > g.y + g.h) return;

  const sx = Math.floor((mx - g.x) / g.slotSize);
  const sy = Math.floor((my - g.y) / g.slotSize);
  if (sx < 0 || sy < 0 || sx >= g.cols || sy >= g.rows) return;

  const slotIndex = sy * g.cols + sx;

  // If this is a consumable, open the submenu instead of immediately using it.
  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
  const slots = me?.inventory?.slots || [];
  const slot = slots[slotIndex];

  if (!slot) {
    invItemMenu = null;
    invItemMenuUI = null;
    return;
  }

  if (isConsumableItemId(slot.id)) {
    // Anchor menu near the clicked slot
    const slotX = g.x + sx * g.slotSize;
    const slotY = g.y + sy * g.slotSize;

    invItemMenu = {
      x: slotX + g.slotSize + 8,
      y: slotY,
      slotIndex,
      itemId: slot.id,
    };
    return;
  }

  // Non-consumables keep the old behavior (equip / etc.)
  sendInvClick(slotIndex);
});


canvas.addEventListener("mousedown", (e) => {
  if (!skillsOpen || !skillsUI) return;

  // Skills menu consumes clicks so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // close button
  const c = skillsUI.close;
  if (c && mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
    skillsOpen = false;
    skillsDragging = false;
    pendingSkillBind = null;
    return;
  }

  // tabs
  if (skillsUI.tabs) {
    for (const [t, r] of Object.entries(skillsUI.tabs)) {
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        skillsTab = t;
        return;
      }
    }
  }

  // drag header (but not when clicking close)
  const h = skillsUI.header;
  if (h && mx >= h.x && mx <= h.x + h.w && my >= h.y && my <= h.y + h.h) {
    skillsDragging = true;
    skillsDragOffX = mx - skillsWinX;
    skillsDragOffY = my - skillsWinY;
    return;
  }

  // click a skill card (for now just a toast)
  if (skillsUI.items) {
    for (const it of skillsUI.items) {
      const r = it.rect;
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        // Clicking any skill card enters a bind mode: press 1–6 to assign to hotbar.
        pendingSkillBind = { skillId: it.id };
        levelToastText = "Press 1-6 to bind that skill to your hotbar (Esc to cancel).";
        levelToastUntilMs = performance.now() + 1800;
        return;
      }
    }
  }
});

canvas.addEventListener("mousemove", (e) => {
  if (!skillsOpen || !skillsDragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  skillsWinX = Math.round(mx - skillsDragOffX);
  skillsWinY = Math.round(my - skillsDragOffY);
});


window.addEventListener("mousemove", (e) => {
  if (!inventoryOpen || !invDragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  invWinX = Math.round(mx - invDragOffX);
  invWinY = Math.round(my - invDragOffY);

  // keep on-screen
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
});


// Click-to-attack (left mouse button). Determines attack direction by click quadrant.
// For wand, the click position determines projectile trajectory (server computes direction).
canvas.addEventListener("mousedown", (e) => {
  if (e.button !== 0) return; // left click only
  if (editorOpen) return; // editor uses clicks for painting
  if (inventoryOpen && invUI) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory consume the click
    }
  }

  // avoid selecting text / dragging
  e.preventDefault();

  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);

  // If Skill 1 is primed, consume it on this wand shot.
  if (skill1Primed) {
    skill1Primed = false; // must press 1 again to try again (even if the shot misses)
    const me = worldPlayers[myId];
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      levelToastText = "Equip a wand to use Skill 1";
      levelToastUntilMs = performance.now() + 1500;
      return;
    }
    sendAttackAtWorld(wx, wy, mx, my, { skill1: true });
    return;
  }

  sendAttackAtWorld(wx, wy, mx, my);
});


window.addEventListener("mouseup", () => {
  invDragging = false;
  skillsDragging = false;
});

/* ======================
   SMOOTH POS
====================== */
function getSmoothedPos(id, rawX, rawY) {
  const s = netState.get(id);
  if (!s) return { x: rawX, y: rawY };

  const renderTime = performance.now() / 1000 - INTERP_DELAY;

  const t0 = s.prev.t;
  const t1 = s.curr.t;

  let alpha = 0;
  if (t1 > t0) alpha = clamp((renderTime - t0) / (t1 - t0), 0, 1);
  alpha = easeInOut(alpha);

  let x = lerp(s.prev.x, s.curr.x, alpha);
  let y = lerp(s.prev.y, s.curr.y, alpha);

  if (renderTime > t1) {
    const extra = clamp(renderTime - t1, 0, 0.10);
    x = s.curr.x + s.vx * extra;
    y = s.curr.y + s.vy * extra;
  }

  const SMOOTHING = 0.15;
  s.smoothX = lerp(s.smoothX, x, SMOOTHING);
  s.smoothY = lerp(s.smoothY, y, SMOOTHING);

  return { x: s.smoothX, y: s.smoothY };
}

function getMyPos() {
  if (!myId) return null;
  const raw = worldPlayers[myId];
  if (!raw) return null;
  return getSmoothedPos(myId, raw.x, raw.y);
}

function getMyStats() {
  const raw = myId ? worldPlayers[myId] : null;
  return {
    hp: raw?.hp ?? 0,
    maxHp: raw?.maxHp ?? 1,
    level: raw?.level ?? 1,
    xp: raw?.xp ?? 0,
    xpNext: raw?.xpNext ?? 1,
    gold: raw?.gold ?? 0,
    equippedWeaponId: raw?.equipment?.weapon ?? null,
  };
}


/* ======================
   CAMERA + SHAKE
====================== */
let camX = 0;
let camY = 0;

function getWorldSize() {
  if (!map) return { w: 0, h: 0 };
  return { w: map[0].length * TILE_SIZE, h: map.length * TILE_SIZE };
}

function updateCamera() {
  const me = getMyPos();
  if (!me || !map) return;

  const viewW = canvas.width;
  const viewH = canvas.height;
  const world = getWorldSize();

  let targetX = me.x - viewW / 2;
  let targetY = me.y - viewH / 2;

  targetX = clamp(targetX, 0, Math.max(0, world.w - viewW));
  targetY = clamp(targetY, 0, Math.max(0, world.h - viewH));

  const CAM_SMOOTH = 0.18;
  camX = lerp(camX, targetX, CAM_SMOOTH);
  camY = lerp(camY, targetY, CAM_SMOOTH);

  camX = Math.round(camX);
  camY = Math.round(camY);
}

function getShakeOffset() {
  if (performance.now() > screenShakeUntilMs) return { x: 0, y: 0 };
  const t = (screenShakeUntilMs - performance.now()) / 160;
  const mag = Math.max(0, screenShakeMag) * clamp(t, 0, 1);
  return {
    x: Math.round((Math.random() * 2 - 1) * mag),
    y: Math.round((Math.random() * 2 - 1) * mag)
  };
}

/* ======================
   DRAW MAP
====================== */
function drawMap() {
  if (!map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const tile = map[y][x];
      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);

      if (tileImage.complete && tileImage.naturalWidth > 0) {
        const cell = TILE_SIZE + TILE_PAD;
        const col = tile % TILESET_COLS;
        const row = Math.floor(tile / TILESET_COLS);
        const sx = col * cell;
        const sy = row * cell;
        ctx.drawImage(tileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
      }



 else {
        ctx.fillStyle = isSolid(tile) ? "#555" : "#2b2b2b";
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}


/* ======================
   OBJECT LAYER (tiles_objects.png)
====================== */
function objTileRow1Based(objTile) {
  // objTile is 1-based for tiles_objects.png (0 = empty)
  if (!objTile) return 0;
  const idx0 = objTile - 1; // 0-based index in the sheet
  const row0 = Math.floor(idx0 / TILESET_COLS);
  return row0 + 1; // 1-based row
}

// Odd rows (1,3,5,...) are canopy: passable, drawn in the canopy pass on top of players
function isObjCanopy(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 1);
}

// Even rows (2,4,6,...) are solid: blocks movement and is depth-sorted with entities

function groundTileRow1Based(tile) {
  if (tile == null || tile < 0) return 0;
  const row0 = Math.floor(tile / TILESET_COLS);
  return row0 + 1;
}
function isSolid(tile) {
  const r = groundTileRow1Based(tile);
  return r > 0 && (r % 2 === 0);
}

function tileAtWorld(wx, wy) {
  if (!map) return WALL_TILE;
  const tx = Math.floor(wx / TILE_SIZE);
  const ty = Math.floor(wy / TILE_SIZE);
  if (ty < 0 || ty >= map.length) return WALL_TILE;
  if (tx < 0 || tx >= map[0].length) return WALL_TILE;
  return map[ty][tx] | 0;
}

function objAtWorld(wx, wy) {
  if (!objMap) return 0;
  const tx = Math.floor(wx / TILE_SIZE);
  const ty = Math.floor(wy / TILE_SIZE);
  if (ty < 0 || ty >= objMap.length) return 0;
  if (tx < 0 || tx >= objMap[0].length) return 0;
  return objMap[ty][tx] | 0;
}

function isBlockedWorld(wx, wy) {
  return isSolid(tileAtWorld(wx, wy)) || isObjSolid(objAtWorld(wx, wy));
}

function isObjSolid(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 0);
} 

function drawSkill1Overlays() {
  const me = worldPlayers[myId];
  if (!me) return;

  // (Targeting radius outline removed — animation is now the only indicator.)

  // Active whirlpools (server)
  if (whirlpools && whirlpools.length) {
    for (const w of whirlpools) {
const cx = w.x;
const cy = w.y;
const r = w.rad || SKILL1_EFFECT_RADIUS_PX;

// Use epoch time for server-authored startMs/endMs (they are serverNowMs()-based)
const nowAbsMs = serverNowMs();
const elapsed = Math.max(0, nowAbsMs - (w.startMs || nowAbsMs));

// Animated black hole spritesheet (8 frames, vertical strip)
const pulse = 0.92 + 0.08 * Math.sin(elapsed * 0.006);
const size = r * 2;

ctx.save();
ctx.translate(cx, cy);

if (blackholeImg.complete && blackholeImg.naturalWidth > 0) {
  const frame = Math.floor(elapsed / SKILL1_BLACKHOLE.frameMs) % SKILL1_BLACKHOLE.frames;
  const sx = 0;
  const sy = frame * SKILL1_BLACKHOLE.frameH;

  ctx.globalAlpha = 0.92 * pulse;

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(
    blackholeImg,
    sx, sy, SKILL1_BLACKHOLE.frameW, SKILL1_BLACKHOLE.frameH,
    -size / 2, -size / 2, size, size
  );

  // subtle inner glow
  ctx.globalAlpha = 0.18 * pulse;
  ctx.fillStyle = "rgba(255, 255, 255, 1)";
  ctx.beginPath();
  ctx.arc(0, 0, Math.max(0, r - 18), 0, Math.PI * 2);
  ctx.fill();
} else {
  // Fallback (if the sprite isn't loaded yet): simple soft dot
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "rgba(0,0,0,1)";
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();
}

ctx.restore();

}
  }
}

// 1=tree canopy

function drawObjectTile(objTile, px, py) {
  if (!objTile) return;
  const cell = TILE_SIZE + TILE_PAD;
  const idx = objTile - 1; // object tiles use 1-based ids; 0=empty
  const col = idx % TILESET_COLS;
  const row = Math.floor(idx / TILESET_COLS);
  const sx = col * cell;
  const sy = row * cell;

  if (objTileImage.complete && objTileImage.naturalWidth > 0) {
    ctx.drawImage(objTileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
  } else {
    // fallback
    ctx.fillStyle = isObjCanopy(objTile) ? "#1f6" : "#888";
    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
  }
}

function drawObjects(pass) {
  if (!objMap || !map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const t = objMap[y][x];
      if (!t) continue;

      const canopy = isObjCanopy(t);
      if (pass === "below" && canopy) continue;
      if (pass === "canopy" && !canopy) continue;

      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);
      drawObjectTile(t, px, py);
    }
  }
}

/* ======================
   PORTAL + PROMPT
====================== */
function isOnPortal() {
  const me = getMyPos();
  if (!me) return false;
  // Use the same "feet" anchor as collision/sorting so you're standing on the portal tile.
  const tx = Math.floor(me.x / TILE_SIZE);
  const ty = Math.floor((me.y + DBG_PLAYER_FOOT_Y) / TILE_SIZE);
  if (!Number.isFinite(tx) || !Number.isFinite(ty)) return false;
  return Array.isArray(portals) && portals.some(p => p && p.x === tx && p.y === ty);
}
function drawPrompt(near, text = "Press E", spriteH = PLAYER_FRAME_H) {
  const anchor = snap2(near.x, near.y);

  ctx.font = "14px system-ui";
  ctx.textBaseline = "middle";
  const padding = 6;
  const w = Math.ceil(ctx.measureText(text).width + padding * 2);
  const h = 22;

  const x = Math.round(anchor.x - w/2);
  const y = Math.round(anchor.y - spriteH/2 - 18 - h);

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + padding, y + h/2);
}

/* ======================
   SPRITE ANIM
====================== */
const DIR = { DOWN:0, LEFT:1, RIGHT:2, UP:3 };
const animState = new Map();

function getAnim(id, x, y) {
  if (!animState.has(id)) {
    animState.set(id, { lastX:x, lastY:y, dir:DIR.DOWN, frame:0, walkT:0, sinceMove:999, dirLock:0, idleT:0, idleFrame:0 });
  }
  return animState.get(id);
}

function dirFromInput() {
  const h = (keys.right ? 1 : 0) + (keys.left ? -1 : 0);
  const v = (keys.down ? 1 : 0) + (keys.up ? -1 : 0);

  if (h !== 0 && v === 0) return h > 0 ? DIR.RIGHT : DIR.LEFT;
  if (v !== 0 && h === 0) return v > 0 ? DIR.DOWN : DIR.UP;
  return null;
}

function updateAnim(id, x, y, dt) {
  const st = getAnim(id, x, y);

  const dx = x - st.lastX;
  const dy = y - st.lastY;
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);

  const moved = (ax + ay) > 0.02;
  st.dirLock = Math.max(0, st.dirLock - dt);

  if (moved) {
    if (id === myId) {
      // Don't let movement inputs overwrite facing while we're in a locked swing direction.
      if (st.dirLock <= 0) {
        const d = dirFromInput();
        if (d != null) st.dir = d;
      }
    } else {
      const DOM = 1.6;
      const LOCK = 0.14;

      let cand = st.dir;
      if (ax > ay * DOM) cand = dx >= 0 ? DIR.RIGHT : DIR.LEFT;
      else if (ay > ax * DOM) cand = dy >= 0 ? DIR.DOWN : DIR.UP;

      if (cand !== st.dir && st.dirLock <= 0) {
        st.dir = cand;
        st.dirLock = LOCK;
      }
    }
  }

  if (moved) st.sinceMove = 0;
  else st.sinceMove += dt;

  const moving = (id === myId)
    ? (keys.left || keys.right || keys.up || keys.down)
    : (st.sinceMove < 0.22);

  if (moving) {
    st.walkT += dt;
    // 4-step cadence: 1,2,1,3
    st.frame = WALK_SEQ[Math.floor(st.walkT * 8) % WALK_SEQ.length];
    st.idleT = 0;
    st.idleFrame = 0;
  } else {
    st.frame = 0;
    st.walkT = 0;

    // idle cadence (2 frames, slow)
    st.idleT += dt;
    if (st.idleT >= IDLE_FRAME_TIME) {
      st.idleT = 0;
      st.idleFrame = 1 - (st.idleFrame || 0);
    }
  }

  st.lastX = x;
  st.lastY = y;
  return st;
}

function drawSprite(img, x, y, dirRow, frameCol, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;
  x = Math.round(x); y = Math.round(y);
  const sx = frameCol * frameW;
  const sy = dirRow * frameH;
  const dx = x - frameW / 2;
  const dy = y - frameH / 2;
  ctx.drawImage(img, sx, sy, frameW, frameH, dx, dy, frameW, frameH);
}

/* ======================
   HIT FLASH (sprite-only)
====================== */
function drawHitTintOnTop(img, x, y, dirRow, frameCol, rgbaColor, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;

  x = Math.round(x); y = Math.round(y);

  const sx = frameCol * frameW;
  const sy = dirRow * frameH;

  const { c: fxCanvas, ctx: fxCtx } = getFxCtx(frameW, frameH);

  // draw sprite frame into offscreen
  fxCtx.clearRect(0, 0, frameW, frameH);
  fxCtx.drawImage(img, sx, sy, frameW, frameH, 0, 0, frameW, frameH);

  // tint only the non-transparent pixels
  fxCtx.globalCompositeOperation = "source-atop";
  fxCtx.fillStyle = rgbaColor;
  fxCtx.fillRect(0, 0, frameW, frameH);
  fxCtx.globalCompositeOperation = "source-over";

  const dx = x - frameW / 2;
  const dy = y - frameH / 2;

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(fxCanvas, 0, 0, frameW, frameH, dx, dy, frameW, frameH);
  ctx.restore();
}

/* ======================
   ATTACK VISUALS
====================== */

function drawSwordSlash(x, y, dir, phase01, swordImg) {
  // Sword slash: uses the equipped sword overlay image and a wide arc "swish".
  // Visual-only; server controls actual hit logic.
  x = Math.round(x); y = Math.round(y);

  const t = clamp(phase01, 0, 1);

  // Hand anchor (shared with held sword)
  const hand = getSwordHand(dir);
  const px = x + hand.x;
  const py = y + hand.y;

  // Attack-only nudge: adjust the slash position without changing the idle/held placement.
  // (Keeps held sword natural, fixes DOWN slash drifting away from the body.)
  let nudgeX = 0, nudgeY = 0;
  if (dir === DIR.DOWN) { nudgeX = 4; nudgeY = -4; }


  // Swing profile: quick accel -> follow-through -> return
  function easeOutCubic(u) { return 1 - Math.pow(1 - u, 3); }
  function easeInOut(u) { return u * u * (3 - 2 * u); }

  // Build a swing angle for each direction.
  // Angles are in radians, measured from +X axis.
  // We sweep a wide arc (about 120°) to feel distinct from spear thrust.
  const sweep = (Math.PI * 2) / 3; // 120°
  const u = (t < 0.55) ? easeOutCubic(t / 0.55) : (0.85 + 0.15 * easeInOut((t - 0.55) / 0.45));
  // u goes 0..~1, with a slight linger near the end.

  // Base angles (start -> end) per facing direction
  let a0 = 0, a1 = 0;
  if (dir === DIR.RIGHT) { a0 = -Math.PI/3; a1 = a0 + sweep; }
  else if (dir === DIR.LEFT) { a0 = Math.PI + Math.PI/3; a1 = a0 - sweep; }
  else if (dir === DIR.DOWN) { a0 = Math.PI/2 - Math.PI/3; a1 = a0 + sweep; }
  else { // UP
    a0 = -Math.PI/2 + Math.PI/3; a1 = a0 - sweep;
  }

  const ang = a0 + (a1 - a0) * clamp(u, 0, 1);

  // Slight outward reach so the blade clears the body
  const reach = 18;
  const ox = Math.cos(ang) * reach;
  const oy = Math.sin(ang) * reach;

  // --- Draw the "swish" arc (behind the blade slightly) ---
  ctx.save();
  ctx.translate(px + nudgeX, py + nudgeY);
  ctx.globalAlpha = (t < 0.12) ? (t / 0.12) : (t > 0.9 ? (1 - (t - 0.9) / 0.1) : 1);
  ctx.globalAlpha *= 0.55;

  const r = 30;
  const start = a0;
  const end = ang;

  ctx.lineWidth = 6;
  ctx.lineCap = "round";
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath();
  // For LEFT/UP we may have end < start; arc handles it but we want a consistent path.
  ctx.arc(0, 0, r, start, end, (dir === DIR.LEFT || dir === DIR.UP));
  ctx.stroke();

  // faint outer arc
  ctx.globalAlpha *= 0.5;
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.beginPath();
  ctx.arc(0, 0, r + 6, start, end, (dir === DIR.LEFT || dir === DIR.UP));
  ctx.stroke();

  ctx.restore();

  // --- Draw the sword sprite as the blade sweeping through the arc ---
  const img = swordImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px + ox + nudgeX, py + oy + nudgeY);
  ctx.rotate(ang + Math.PI/2); // make the blade generally point outward from the hand

  // Mirror for LEFT so the grip stays in the hand
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = 32, H = 64;
  const gripX = 16;
  const gripY = 50;

  ctx.imageSmoothingEnabled = false;
  if (ready) {
    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  } else {
    // fallback blade
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-1, -44, 2, 40);
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-6, -10, 12, 6);
  }

  ctx.restore();
}

function drawSpearThrust(x, y, dir, phase01, spearImg, playerId) {
  // Image-based spear thrust. Uses /assets/basic_spear.png (16x32, centered).
  // Visual-only; does not affect hit/collision logic.
  x = Math.round(x); y = Math.round(y);

  // --- Motion profile ---
  // Idea 1) "Slow start" (ease-in) so the first part feels weighted.
  // Idea 2) Brief linger at max extension, then retract a touch.
  const t = clamp(phase01, 0, 1);

  const OUT  = 0.55; // time to extend
  const HOLD = 0.18; // linger at full extension
  const BACK = 1 - OUT - HOLD; // time to retract

  function easeInCubic(u) { return u * u * u; }
  function easeSmooth(u) { return u * u * (3 - 2 * u); } // same as easeInOut()

  let prog = 0; // 0..1 extension amount
  if (t < OUT) {
    const u = clamp(t / OUT, 0, 1);
    prog = easeInCubic(u);          // slow start, fast finish
  } else if (t < OUT + HOLD) {
    prog = 1;                       // linger at max
  } else {
    const u = clamp((t - OUT - HOLD) / BACK, 0, 1);
    prog = 1 - 0.18 * easeSmooth(u); // retract ~18% so it doesn't "snap off"
  }

  const MAX_THRUST = 28;            // pixels pushed outward
  const thrust = Math.round(prog * MAX_THRUST);

  // Use the shared spear-hand anchor so the thrust lines up with the held spear.
  const hand = getSpearHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  // If the sprite isn't loaded yet, fall back to a simple rectangle spear so nothing breaks.
  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  // Move outward along the facing direction (in world space).
  // We apply thrust before rotation by translating in direction coords.
  if (dir === DIR.RIGHT) ctx.translate(thrust, 0);
  if (dir === DIR.LEFT)  ctx.translate(-thrust, 0);
  if (dir === DIR.DOWN)  ctx.translate(0, thrust);
  if (dir === DIR.UP)    ctx.translate(0, -thrust);

  ctx.rotate(ang);

  // Skill 2 (Double Stab) visual: temporarily scale spear and add a slight "jut" angle.
  // This is purely visual; server is authoritative for damage.
  let extraScale = 1;
  let extraAng = 0;
  let extraSide = 0;

  const sid = (playerId != null) ? String(playerId) : null;
  const fx = sid ? skill2FxByCaster.get(sid) : null;
  if (fx && typeof fx.startMs === "number") {
    const tAbs = serverNowMs() - fx.startMs;
    if (tAbs >= 0 && tAbs <= SKILL2_VIS_MS) {
      // Two windows: stab 0 then stab 1
      const stabIndex = (tAbs < SKILL2_GAP_MS) ? 0 : 1;
      extraScale = 1.25;
      extraAng = (stabIndex === 0 ? -1 : 1) * (Math.PI / 28);
      // tiny sideways "jut" so the thrust isn't perfectly straight
      const w = Math.sin(Math.min(1, (tAbs % SKILL2_GAP_MS) / SKILL2_GAP_MS) * Math.PI);
      extraSide = (stabIndex === 0 ? -1 : 1) * (2.5 * w);
    }
    if (tAbs > SKILL2_VIS_MS + 200) skill2FxByCaster.delete(sid);
  }

  ctx.rotate(extraAng);
  if (extraScale !== 1) ctx.scale(extraScale, extraScale);
  if (extraSide !== 0) ctx.translate(extraSide, 0);

  // IMPORTANT: no spear scaling.
  // We draw at the sprite's native resolution (or a 32x64 fallback) so the spear art controls its own size.
  if (ready) {
    const w = img.naturalWidth || 32;
    const h = img.naturalHeight || 64;
    // Grip near the bottom-center of the sprite.
    const gripX = Math.round(w / 2);
    const gripY = Math.round(h * 0.82);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, w, h);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}



function drawSpearHeld(x, y, dir, spearImg) {
  // Persistent spear when equipped (not attacking).
  // Uses the same /assets/basic_spear.png sprite as the thrust, but with no thrust motion.
  x = Math.round(x); y = Math.round(y);

  // Same anchor as the thrust so it stays “in the hands”.
  const hand = getSpearHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  ctx.rotate(ang);

  // IMPORTANT: no spear scaling.
  // Draw at native sprite size (or 32x64 fallback) so it matches your actual spear art.
  if (ready) {
    const w = img.naturalWidth || 32;
    const h = img.naturalHeight || 64;
    const gripX = Math.round(w / 2);
    const gripY = Math.round(h * 0.82);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, w, h);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}


function drawWandCastSpark(x, y, dir, phase01) {
  // tiny “spark” near hand to show casting
  x = Math.round(x); y = Math.round(y);
  const a = 1 - Math.abs(phase01 - 0.5) * 2;
  if (a <= 0) return;

  let sx = x, sy = y;
  if (dir === DIR.RIGHT) { sx = x + 16; sy = y - 4; }
  if (dir === DIR.LEFT)  { sx = x - 16; sy = y - 4; }
  if (dir === DIR.DOWN)  { sx = x + 6;  sy = y + 12; }
  if (dir === DIR.UP)    { sx = x - 6;  sy = y - 18; }

  ctx.save();
  ctx.globalAlpha = clamp(a, 0, 1);
  ctx.fillStyle = "#bde0fe";
  ctx.fillRect(sx - 2, sy - 2, 4, 4);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(sx - 1, sy - 1, 2, 2);
  ctx.restore();
}

/* ======================
   PROJECTILE DRAW
====================== */
function drawProjectile(pr) {
  const x = Math.round(pr.x);
  const y = Math.round(pr.y);

  // Try sprite-based rendering first
  const key = pr.sprite || null;
  const img = key ? (projectileSprites[key] || null) : null;

  if (img && img.complete && img.naturalWidth > 0) {
    const rad = (pr.rad ?? 10);
    // Slightly larger than hit radius so it reads well visually
    const w = Math.max(12, Math.round(rad * 2.2));
    const h = w;

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, Math.round(x - w / 2), Math.round(y - h / 2), w, h);
    ctx.restore();
    return;
  }

  // Fallback: simple bolt (keeps working even if the image is missing)
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x - 5, y - 5, 10, 10);

  ctx.fillStyle = "#9bf6ff";
  ctx.fillRect(x - 3, y - 3, 6, 6);

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(x - 1, y - 1, 2, 2);
  ctx.restore();
}

/* ======================
   COIN DRAW
====================== */
function drawCoin(x, y, amount) {
  x = Math.round(x); y = Math.round(y);

  const cx = x - 5;
  const cy = y + 10;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(cx - 1, cy - 1, 12, 12);

  ctx.fillStyle = "#f1c40f";
  ctx.fillRect(cx + 2, cy + 1, 6, 8);
  ctx.fillStyle = "#ffd966";
  ctx.fillRect(cx + 3, cy + 2, 4, 6);

  if (amount >= 4) {
    ctx.font = "10px system-ui";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#fff";
    ctx.fillText(String(amount), cx + 12, cy + 1);
  }
  ctx.restore();
}

const itemSprites = {
  orange_flan: new Image(),
  potion_green: new Image(),
  potion_purple: new Image(),
};

itemSprites.orange_flan.src  = "/assets/items/orange_flan.png";
itemSprites.potion_green.src = "/assets/items/potion_green.png";
itemSprites.potion_purple.src = "/assets/items/potion_purple.png";



function drawItemDrop(itemId, x, y) {
  const img = itemSprites[itemId];
  if (!img) return;
  if (!img.complete) return;
  const w = 32, h = 32;
  ctx.drawImage(img, Math.round(x - w/2), Math.round(y - h/2), w, h);
}


/* ======================
   MOB HP BAR
====================== */
function drawHpBarWorld(x, y, hp, maxHp, spriteH = MOB_FRAME_H) {
  const w = 34, h = 6;
  const pct = clamp((maxHp ? hp / maxHp : 0), 0, 1);
  const bx = Math.round(x - w/2);
  const by = Math.round(y - spriteH/2 - 10);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(bx, by, w, h);
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(bx + 1, by + 1, Math.round((w - 2) * pct), h - 2);
}

/* ======================
   NPC INTERACTION
====================== */
let cachedNearestNpc = null;

function computeNearestNpc() {
  const me = getMyPos();
  if (!me) return null;

  let best = null;
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    const d = dist(me.x, me.y, pos.x, pos.y);
    if (d <= INTERACT_DIST && (!best || d < best.d)) best = { id, d, x: pos.x, y: pos.y, name: n.name || id };
  }
  return best;
}

function tryInteract() {
  if (!cachedNearestNpc) return;
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "interact", npcId: cachedNearestNpc.id }));
}

function drawDialogueBubble(d) {
  if (!d) return;
  if (performance.now() > d.untilMs) { activeDialogue = null; return; }

  const npcRaw = worldNpcs[d.npcId];
  if (!npcRaw) return;

  const npcPosF = getSmoothedPos(d.npcId, npcRaw.x, npcRaw.y);
  const npcPos = snap2(npcPosF.x, npcPosF.y);

  const lines = [`${d.npcName}:`, d.text];

  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";

  const padding = 8;
  let w = 0;
  for (const line of lines) w = Math.max(w, ctx.measureText(line).width);
  w = Math.ceil(w);

  const lineH = 18;
  const h = padding*2 + lineH*lines.length;

  let x = clamp(npcPos.x - w/2 - padding, camX + 8, camX + canvas.width - (w + padding*2) - 8);
  let y = clamp(npcPos.y - NPC_DRAW_H/2 - h - 18, camY + 8, camY + canvas.height - h - 8);

  x = Math.round(x);
  y = Math.round(y);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(x, y, w + padding*2, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w + padding*2 - 1, h - 1);

  ctx.fillStyle = "#fff";
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], x + padding, y + padding + i*lineH);
  }
}

/* ======================
   HUD
====================== */


function drawSkillHotbar() {
  // Bottom-left hotbar slots for Skill 1 and Skill 2
  const now = serverNowMs();
  const nowUi = performance.now();

  const slot = 48;
  const pad = 14;
  const gap = 10;

  const x0 = pad;
  const y0 = Math.round(canvas.height - pad - slot);

  function drawSlot(opts) {
    const {
      x0, y0,
      keyLabel,
      iconImg,
      isActive,
      activeUntilMs,
      activeTotalMs,
      cdUntilMs,
      cdTotalMs,
      nackUntilMs,
      shakeUntilMs,
      shakeSeed,
    } = opts;

    // Shake feedback
    let x = x0, y = y0;
    if (nowUi < shakeUntilMs) {
      const t = (shakeUntilMs - nowUi) / 1000;
      const amp = 4 * Math.min(1, t * 3); // px
      const sx = Math.sin((nowUi * 0.05) + shakeSeed) * amp;
      const sy = Math.cos((nowUi * 0.06) + shakeSeed * 2) * amp;
      x = x0 + sx;
      y = y0 + sy;
    }

    const isCd = now < cdUntilMs;
    const activeRem = Math.max(0, activeUntilMs - now);
    const cdRem = Math.max(0, cdUntilMs - now);

    // Base slot
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(x, y, slot, slot);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(x + 0.5, y + 0.5, slot - 1, slot - 1);

    // Icon
    const img = iconImg;
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.imageSmoothingEnabled = false;
      const iw = 32, ih = 32;
      ctx.drawImage(img, x + Math.round((slot - iw) / 2), y + Math.round((slot - ih) / 2), iw, ih);
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(x + 14, y + 14, 20, 20);
    }

    // Key label
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(x + 2, y + 2, 14, 14);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.strokeRect(x + 2.5, y + 2.5, 13, 13);
    ctx.fillStyle = "#fff";
    ctx.font = "12px system-ui";
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillText(String(keyLabel), x + 9, y + 9);

    // State overlays
    if (isActive || isCd) {
      const rem = isActive ? activeRem : cdRem;
      const total = isActive ? (activeTotalMs || rem) : (cdTotalMs || rem);
      const frac = clamp(total ? rem / total : 1, 0, 1);

      ctx.fillStyle = "rgba(0,0,0,0.60)";
      ctx.fillRect(x, y, slot, Math.round(slot * frac));

      const s = Math.ceil(rem / 1000);
      ctx.fillStyle = "#fff";
      ctx.font = "14px system-ui";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.fillText(String(s), x + slot / 2, y + slot / 2);
    } else {
      // Red blink feedback when pressed on cooldown/active
      if (nowUi < nackUntilMs) {
        const p = (nackUntilMs - nowUi) / 420; // 1..0
        const blink = (Math.floor(nowUi / 80) % 2) === 0;
        if (blink) {
          ctx.fillStyle = `rgba(255, 60, 60, ${0.25 + 0.35 * (1 - p)})`;
          ctx.fillRect(x, y, slot, slot);
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(255, 60, 60, ${0.85})`;
          ctx.strokeRect(x + 2, y + 2, slot - 4, slot - 4);
        }
      }
      ctx.lineWidth = 1;
    }

    ctx.restore();
  }

  // Skill 1 slot (active or cooldown)
  drawSlot({
    x0: x0,
    y0: y0,
    keyLabel: "1",
    iconImg: skill1IconImg,
    isActive: now < skill1ActiveUntilMs,
    activeUntilMs: skill1ActiveUntilMs,
    activeTotalMs: skill1ActiveTotalMs,
    cdUntilMs: skill1CdUntilMs,
    cdTotalMs: skill1CdTotalMs,
    nackUntilMs: skill1HotbarNackUntilMs,
    shakeUntilMs: skill1HotbarShakeUntilMs,
    shakeSeed: skill1HotbarShakeSeed,
  });

  // Skill 2 slot (cooldown only)
  drawSlot({
    x0: x0 + slot + gap,
    y0: y0,
    keyLabel: "2",
    iconImg: skill2IconImg,
    isActive: false,
    activeUntilMs: 0,
    activeTotalMs: 0,
    cdUntilMs: skill2CdUntilMs,
    cdTotalMs: skill2CdTotalMs,
    nackUntilMs: skill2HotbarNackUntilMs,
    shakeUntilMs: skill2HotbarShakeUntilMs,
    shakeSeed: skill2HotbarShakeSeed,
  });
}

function drawHud() {
  const { hp, maxHp, xp, xpNext } = getMyStats();
  const hpPct = clamp(maxHp ? hp / maxHp : 0, 0, 1);
  const xpPct = clamp(xpNext ? xp / xpNext : 0, 0, 1);

  const w = 170;
  const hpH = 14;
  const xpH = 7;
  const padding = 4;

  const x = canvas.width / 2 - w / 2;
  const hotbarBoxH = 44; // must match drawHotbar()
  const hotbarPadBottom = 12; // must match drawHotbar()
  const hudClearance = hotbarBoxH + hotbarPadBottom + 10;
  const y = Math.max(14, canvas.height - (hpH + xpH + padding * 3) - hudClearance);
ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 4, y - 4, w + 8, hpH + xpH + padding * 2);

  // HP BAR
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y, w, hpH);
  ctx.fillStyle = "#ff4757";
  ctx.fillRect(x, y, Math.round(w * hpPct), hpH);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, hpH - 1);

  ctx.fillStyle = "#fff";
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.fillText(`HP ${hp}/${maxHp}`, x + w / 2, y + hpH / 2);

  // XP BAR
  const y2 = y + hpH ;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y2, w, xpH);
  ctx.fillStyle = "#4dabf7";
  ctx.fillRect(x, y2, Math.round(w * xpPct), xpH);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y2 + 0.5, w - 1, xpH - 1);

  ctx.fillStyle = "#fff";
  ctx.font = "10px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.fillText(`XP ${xp}/${xpNext}`, x + w / 2, y2 + xpH / 2);

  ctx.restore();
}



/* ======================
   DEBUG EDITOR OVERLAY
====================== */
function drawEditorOverlay() {
  if (!editorOpen || !map) return;

  // World-space overlays (grid/collision/hover). We keep the editor panel in screen-space,
  // but these need to align to the tilemap, so apply the camera offset here.
  ctx.save();
  ctx.translate(-camX, -camY);

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE));
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE));

  if (editorShowGrid) {
    // Grid should be in world-space (aligned to tiles), so we draw it using world coords.
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    for (let x = startTx; x <= endTx + 1; x++) {
      const px = x * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(px, startTy * TILE_SIZE);
      ctx.lineTo(px, (endTy + 1) * TILE_SIZE);
      ctx.stroke();
    }
    for (let y = startTy; y <= endTy + 1; y++) {
      const py = y * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(startTx * TILE_SIZE, py);
      ctx.lineTo((endTx + 1) * TILE_SIZE, py);
      ctx.stroke();
    }
  }

  // Collision overlay (helps distinguish floor vs wall even if tiles look similar)
  if (editorShowColl) {
    for (let y = startTy; y <= endTy; y++) {
      for (let x = startTx; x <= endTx; x++) {
        const g = map[y][x];
        const o = (objMap && objMap[y] ? objMap[y][x] : 0);

        if (g === 1) {
          ctx.strokeStyle = "rgba(255,80,80,0.70)";
          ctx.strokeRect(x * TILE_SIZE + 1.5, y * TILE_SIZE + 1.5, TILE_SIZE - 3, TILE_SIZE - 3);
        } else if (o === 2 || o === 6) {
          ctx.strokeStyle = "rgba(255,190,80,0.65)";
          ctx.strokeRect(x * TILE_SIZE + 3.5, y * TILE_SIZE + 3.5, TILE_SIZE - 7, TILE_SIZE - 7);
        }
      }
    }
  }


  // Hover highlight
  if (editorMouseHas) {
    const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
    const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
    if (tx >= 0 && ty >= 0 && ty < map.length && tx < map[0].length) {
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.strokeRect(tx * TILE_SIZE + 0.5, ty * TILE_SIZE + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
    }
  }

  ctx.restore();

  // Screen-space panel
  const list = editorAllowedList();
  const sel = editorSelectedTile();
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.65)";
  ctx.fillRect(14, canvas.height - 110, 360, 96);
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(14.5, canvas.height - 109.5, 359, 95);

  ctx.fillStyle = "#fff";
  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";

  const y = canvas.height - 102;
  ctx.fillText("EDITOR (F1)", 26, y);
  ctx.fillText(`Layer: ${editorLayer.toUpperCase()} (TAB)`, 26, y + 20);
  ctx.fillText(`Tile: ${sel}  Allowed: [${list.join(", ")}]  ([ / ])`, 26, y + 40);

  // Tile preview (shows the currently selected brush)
  const prevX = 26 + 360;
  const prevY = y + 8;
  const prevS = 48; // preview size (1x tile)
  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(prevX - 6, prevY - 6, prevS + 12, prevS + 12);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(prevX - 6, prevY - 6, prevS + 12, prevS + 12);

  // If object layer and sel==0, draw a simple checker (empty)
  if (editorLayer === "object" && sel === 0) {
    const cs = 8;
    for (let yy = 0; yy < prevS; yy += cs) {
      for (let xx = 0; xx < prevS; xx += cs) {
        ctx.fillStyle = ((xx / cs + yy / cs) % 2 === 0) ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.08)";
        ctx.fillRect(prevX + xx, prevY + yy, cs, cs);
      }
    }
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.fillText("EMPTY", prevX + 6, prevY + prevS - 8);
  } else {
    const img = (editorLayer === "object") ? objTileImage : tileImage;
    const tileIndex = (editorLayer === "object") ? (Math.max(1, sel) - 1) : sel;
    const col = tileIndex % TILESET_COLS;
    const row = Math.floor(tileIndex / TILESET_COLS);
    const sx = col * (TILE_SIZE + TILE_PAD);
    const sy = row * (TILE_SIZE + TILE_PAD);
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, sx, sy, TILE_SIZE, TILE_SIZE, prevX, prevY, prevS, prevS);
    } else {
      // fallback if image not loaded yet
      ctx.fillStyle = "rgba(255,255,255,0.15)";
      ctx.fillRect(prevX, prevY, prevS, prevS);
    }
  }
  ctx.restore();
  let under = "";
  if (editorMouseHas) {
    const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
    const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
    if (tx >= 0 && ty >= 0 && ty < map.length && tx < map[0].length) {
      const g = map[ty][tx];
      const o = (objMap && objMap[ty] ? objMap[ty][tx] : 0);
      under = ` | Under cursor: G=${g} O=${o} @(${tx},${ty})`;
    }
  }
  ctx.fillText(`Left=paint  Right=erase  G=grid  C=coll  Ctrl+E=export${under}`, 26, y + 60);
  ctx.restore();
}

/* ======================
   INVENTORY UI (MapleStory-style)
====================== */
function drawInventory(inv, equipment) {
  const cols = 6;
  const rows = 4;
  const slotSize = 48;

  const HEADER_H = 26;
  const PAD = 14;

  const panelW = cols * slotSize + PAD * 2;

  // Equipment row layout
  // (we compute panelH from where the grid ends so nothing gets cut off)

  // Equipment row layout
  // position (draggable)
  // If this is the first draw after opening, center it.
  if (invWinX == null || invWinY == null) {
    invWinX = Math.floor(canvas.width / 2 - panelW / 2);
    invWinY = Math.floor(canvas.height / 2 - 220);
  }

  let startX = invWinX;
  let startY = invWinY;

  const eqY = startY + HEADER_H + 18;
  const eqX = startX + PAD;
  const eqGap = 12;

  const equipSlots = {
    weapon:    { x: eqX + 0 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    armor:     { x: eqX + 1 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    hat:       { x: eqX + 2 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    accessory: { x: eqX + 3 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
  };

  // Inventory grid layout
  const gridX = startX + PAD;
  const gridY = eqY + slotSize + 26;

  const panelH = (gridY + rows * slotSize + PAD) - startY;

  // cache window size for clamping drag
  invWinW = panelW;
  invWinH = panelH;

  // keep within canvas (in case screen size changed)
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
  startX = invWinX;
  startY = invWinY;

  // Close button + header rects
  const closeSize = 18;
  invCloseRect = {
    x: startX + panelW - closeSize - 8,
    y: startY + 4,
    w: closeSize,
    h: closeSize
  };
  invHeaderRect = {
    x: startX,
    y: startY,
    w: panelW,
    h: HEADER_H
  };

  // Cache layout for click handling
  invUI = {
    equipSlots,
    grid: {
      x: gridX,
      y: gridY,
      cols,
      rows,
      slotSize,
      w: cols * slotSize,
      h: rows * slotSize
    }
  };

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.fillRect(startX, startY, panelW, panelH);

  // header bar (drag handle)
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(startX, startY, panelW, HEADER_H);

  // header title
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Inventory", startX + PAD, startY + Math.floor(HEADER_H / 2));

  // close button
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(invCloseRect.x, invCloseRect.y, invCloseRect.w, invCloseRect.h);
  ctx.fillStyle = "#ddd";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("X", invCloseRect.x + invCloseRect.w / 2, invCloseRect.y + invCloseRect.h / 2 + 0.5);
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.font = "12px system-ui";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Equipment", startX + PAD, startY + HEADER_H + 2);

  // Draw equipment slots
  const eq = equipment || {};
  const labels = { weapon: "Wpn", armor: "Arm", hat: "Hat", accessory: "Acc" };

  for (const slotName of ["weapon", "armor", "hat", "accessory"]) {
    const r = equipSlots[slotName];
    ctx.strokeStyle = "#aaa";
    ctx.strokeRect(r.x, r.y, r.w, r.h);

    // label
    ctx.fillStyle = "#bbb";
    ctx.fillText(labels[slotName], r.x + 6, r.y + r.h + 2);

    const itemId = eq[slotName];
    if (itemId) {
      // icon first, fallback to text if unknown
      const drew = drawItemIcon(itemId, r.x, r.y, r.w);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(itemId, r.x + 4, r.y + 16);
      }
    }
  }

  ctx.fillStyle = "#ddd";
  ctx.fillText("Items", startX + PAD, gridY - 18);

  // Draw inventory grid
  const slots = inv?.slots || [];
  for (let i = 0; i < cols * rows; i++) {
    const x = gridX + (i % cols) * slotSize;
    const y = gridY + Math.floor(i / cols) * slotSize;

    ctx.strokeStyle = "#888";
    ctx.strokeRect(x, y, slotSize, slotSize);

    const slot = slots[i];
    if (slot) {
      // highlight if this exact item is equipped in any slot
      const isEquipped = (slot.id === eq.weapon || slot.id === eq.armor || slot.id === eq.hat || slot.id === eq.accessory);
      if (isEquipped) {
        ctx.save();
        ctx.globalAlpha = 0.20;
        ctx.fillStyle = "#fff";
        ctx.fillRect(x, y, slotSize, slotSize);
        ctx.restore();
      }

      // icon first, fallback to text if unknown
      const drew = drawItemIcon(slot.id, x, y, slotSize);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(slot.id, x + 4, y + 6);
      }

      // stack count
      if (slot.qty > 1) {
        const txt = String(slot.qty);
        ctx.save();
        ctx.font = "12px system-ui";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + slotSize - 6;
        const ty = y + slotSize - 6;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.strokeText(txt, tx, ty);
        ctx.fillStyle = "#fff";
        ctx.fillText(txt, tx, ty);
        ctx.restore();
      }
    }
  }


  // ---- Item submenu (Use / Bind to hotbar) ----
  // Only used for consumables; opened by clicking a consumable in the inventory grid.
  if (invItemMenu) {
    const cur = slots?.[invItemMenu.slotIndex];
    if (!cur || cur.id !== invItemMenu.itemId) {
      invItemMenu = null;
      invItemMenuUI = null;
    } else {
      const menuW = 170;
      const pad = 8;
      const rowH = 22;
      const gap = 6;
      const menuH = pad * 2 + rowH * 2 + gap;

      let mx = invItemMenu.x;
      let my = invItemMenu.y;

      // If we'd overflow right, pop to the left of the slot instead.
      if (mx + menuW > canvas.width - 8) {
        mx = (invItemMenu.x - menuW) - 16;
      }

      // Clamp to screen bounds
      mx = clamp(mx, 8, canvas.width - menuW - 8);
      my = clamp(my, 8, canvas.height - menuH - 8);

      const panel = { x: mx, y: my, w: menuW, h: menuH };
      const btnUse  = { x: mx + pad, y: my + pad, w: menuW - pad * 2, h: rowH };
      const btnBind = { x: mx + pad, y: my + pad + rowH + gap, w: menuW - pad * 2, h: rowH };

      invItemMenuUI = { panel, btnUse, btnBind };

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.88)";
      ctx.fillRect(panel.x, panel.y, panel.w, panel.h);
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.strokeRect(panel.x, panel.y, panel.w, panel.h);

      // Buttons
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(btnUse.x, btnUse.y, btnUse.w, btnUse.h);
      ctx.fillRect(btnBind.x, btnBind.y, btnBind.w, btnBind.h);

      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(btnUse.x, btnUse.y, btnUse.w, btnUse.h);
      ctx.strokeRect(btnBind.x, btnBind.y, btnBind.w, btnBind.h);

      ctx.font = "12px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ddd";
      ctx.fillText("Use item", btnUse.x + 10, btnUse.y + Math.floor(btnUse.h / 2));
      ctx.fillText("Bind to hotbar", btnBind.x + 10, btnBind.y + Math.floor(btnBind.h / 2));

      ctx.restore();
    }
  } else {
    invItemMenuUI = null;
  }

  // Bind hint (shows inside the inventory window)
  if (pendingItemBind) {
    ctx.save();
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("Press 1–6 to bind item to hotbar (Esc to cancel)", startX + PAD, startY + panelH - 10);
    ctx.restore();
  }

  ctx.restore();
}

/* ======================
   INVENTORY TOOLTIP (hover)
====================== */
// Keep this in sync with server.js ITEMS for names. Desc is client-only flavor.
const ITEM_INFO = {
  coin:            { name: "Coin",            desc: "Currency picked up from mobs." },
  orange_flan:     { name: "Orange Flan",     desc: "A wobbly snack. Looks suspiciously delicious." },
  potion_small:    { name: "Small Potion",    desc: "Restores 25 HP." },
  potion_green:    { name: "Green Slime Tonic",    desc: "Restores 50 HP." },
  potion_purple:    { name: "Purple Slime Tonic",    desc: "Restores 300 HP." },


  training_sword:  { name: "Training Sword",  desc: "A basic sword for practice." },
  training_spear:  { name: "Hunting Spear",  desc: "A basic spear for practice." },
  candy_cane_spear:{ name: "North Pole",desc: "Festive… and pointy." },
  fang_spear:      { name: "Twin Fang",      desc: "A spear tipped with a wicked fang." },
  training_wand:   { name: "Training Wand",   desc: "A simple wand for new mages." },

  cloth_armor:     { name: "Apprentice Robe",     desc: "Light protection." },
  charger_suit:    { name: "Charger Suit",    desc: "Sturdy armor with a metallic sheen." },
  cloth_hat:       { name: "Apprentice Hat",       desc: "Keeps the sun out of your eyes." },
  charger_helmet:  { name: "Charger Helmet",  desc: "A helmet with a solid visor." },
  red_duke: { name: "Red Duke", type: "hat", stats: "", desc: "A duke’s helm, dyed crimson." },
  lucky_charm:     { name: "Four-Leaf",     desc: "Maybe it really is lucky." },
};

// Minimal item meta for tooltip "splash" lines (type + weapon speed).
// Keep these in sync with server.js ITEMS where applicable.
const ITEM_META = {
  training_sword:   { slot: "weapon", kind: "Sword", weaponSpeed: 1.75 },
  training_wand:    { slot: "weapon", kind: "Wand",  weaponSpeed: 1.00 },
  training_spear:   { slot: "weapon", kind: "Spear", weaponSpeed: 1.50 },
  candy_cane_spear: { slot: "weapon", kind: "Spear", weaponSpeed: 1.75 },
  fang_spear:       { slot: "weapon", kind: "Spear", weaponSpeed: 1.50 },

  cloth_armor:      { slot: "armor", kind: "Armor" },
  charger_suit:     { slot: "armor", kind: "Armor" },
  cloth_hat:        { slot: "hat",   kind: "Hat"   },
  charger_helmet:   { slot: "hat",   kind: "Hat"   },
  lucky_charm:      { slot: "accessory", kind: "Accessory" },
};

function getItemTooltipData(itemId, qty = 1) {
  const info = ITEM_INFO[itemId] || null;
  const name = (info && info.name) ? info.name : String(itemId || "Unknown");
  const desc = (info && info.desc) ? info.desc : "";
  const metaLines = [];

  const meta = ITEM_META[itemId] || null;
  if (meta) {
    if (meta.slot === "weapon") {
      const kind = meta.kind ? ` (${meta.kind})` : "";
      metaLines.push(`Type: Weapon${kind}`);
      if (typeof meta.weaponSpeed === "number") {
        const s = (Math.round(meta.weaponSpeed * 100) / 100).toString();
        metaLines.push(`Speed: ${s}x`);
      }
    } else if (meta.slot === "armor") {
      metaLines.push("Type: Armor");
    } else if (meta.slot === "hat") {
      metaLines.push("Type: Hat");
    } else if (meta.slot === "accessory") {
      metaLines.push("Type: Accessory");
    }
  }

  if (qty > 1) metaLines.push(`x${qty}`);
  return { name, desc, metaLines };
}

function wrapTooltipText(text, maxWidthPx, font = "12px system-ui") {
  if (!text) return [];
  ctx.save();
  ctx.font = font;
  const words = String(text).split(/\s+/).filter(Boolean);
  const lines = [];
  let line = "";
  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxWidthPx) line = test;
    else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);
  ctx.restore();
  return lines;
}

function getInventoryHover(mx, my, inv, equipment) {
  if (!invUI) return null;

  // Equipment slots (only if occupied)
  const eq = equipment || {};
  for (const [slotName, r] of Object.entries(invUI.equipSlots || {})) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      const itemId = eq[slotName];
      if (!itemId) return null;
      return { id: itemId, qty: 1, source: "equip", rect: r };
    }
  }

  // Inventory grid slots
  const g = invUI.grid;
  if (!g) return null;
  if (mx < g.x || my < g.y || mx > g.x + g.w || my > g.y + g.h) return null;

  const sx = Math.floor((mx - g.x) / g.slotSize);
  const sy = Math.floor((my - g.y) / g.slotSize);
  if (sx < 0 || sy < 0 || sx >= g.cols || sy >= g.rows) return null;

  const slotIndex = sy * g.cols + sx;
  const slot = inv?.slots ? inv.slots[slotIndex] : null;
  if (!slot) return null;

  const rect = { x: g.x + sx * g.slotSize, y: g.y + sy * g.slotSize, w: g.slotSize, h: g.slotSize };
  return { id: slot.id, qty: slot.qty || 1, source: "grid", slotIndex, rect };
}

function drawInventoryTooltip(hover, preferX, preferY) {
  if (!hover || !hover.id) return;

  const { name, desc, metaLines } = getItemTooltipData(hover.id, hover.qty);

  const PAD = 10;
  const GAP = 8;
  const ICON = 56; // slightly larger than the 32px inventory icon
  const W = 240;

  // Wrap description
  const descLines = wrapTooltipText(desc, W - PAD * 2, "12px system-ui");

  // Compute height
  const nameH = 16;
  const metaH = metaLines.length ? (metaLines.length * 14 + 4) : 0;
  const descH = descLines.length ? (descLines.length * 14 + 2) : 0;
  const H = PAD + nameH + GAP + ICON + (metaH ? GAP + metaH : 0) + (descH ? GAP + descH : 0) + PAD;

  // Position & clamp inside canvas
  let x = Math.round(preferX);
  let y = Math.round(preferY);
  x = clamp(x, 8, canvas.width - W - 8);
  y = clamp(y, 8, canvas.height - H - 8);

  // Background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.88)";
  ctx.fillRect(x, y, W, H);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(x + 0.5, y + 0.5, W - 1, H - 1);

  // Name
  ctx.font = "bold 13px system-ui";
  ctx.fillStyle = "#fff";
  ctx.textBaseline = "top";
  ctx.textAlign = "left";
  ctx.fillText(name, x + PAD, y + PAD);

  // Image (left-justified)
  const img = equipIcons[hover.id];
  const ix = Math.round(x + PAD); // left align with text
  const iy = Math.round(y + PAD + nameH + GAP);
if (img && img.complete && img.naturalWidth > 0) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, ix, iy, ICON, ICON);
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(ix, iy, ICON, ICON);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(ix + 0.5, iy + 0.5, ICON - 1, ICON - 1);
  }

  // Meta
  let cy = iy + ICON + GAP;
  if (metaLines.length) {
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    for (const t of metaLines) {
      ctx.fillText(t, x + PAD, cy);
      cy += 14;
    }
    cy += 4;
  }

  // Desc
  if (descLines.length) {
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    for (const t of descLines) {
      ctx.fillText(t, x + PAD, cy);
      cy += 14;
    }
  }

  ctx.restore();
}

function drawLootPops() {
  const now = performance.now();
  for (let i = lootPops.length - 1; i >= 0; i--) {
    const p = lootPops[i];
    if (now > p.untilMs) { lootPops.splice(i, 1); continue; }
    const t = 1 - ((p.untilMs - now) / 700);
    const y = p.y - Math.round(t * 14);

    ctx.save();
    ctx.font = "14px system-ui";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ffd966";
    ctx.fillText(p.text, Math.round(p.x), Math.round(y));
    ctx.restore();
  }
}

/* ======================
   DAMAGE POPUPS DRAW
====================== */
function drawDamagePops() {
  const now = performance.now();
  for (let i = damagePops.length - 1; i >= 0; i--) {
    const d = damagePops[i];
    if (now > d.untilMs) { damagePops.splice(i, 1); continue; }

    const life = 650;
    const t = 1 - ((d.untilMs - now) / life);
    const rise = Math.round(t * 18);
    const alpha = clamp(1 - t, 0, 1);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = "bold 20px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.lineWidth = 5;
    ctx.strokeStyle = "rgba(0,0,0,0.7)";
    ctx.strokeText(d.text, Math.round(d.x), Math.round(d.y - rise));

    ctx.fillStyle = d.color || "#fff";
    ctx.fillText(d.text, Math.round(d.x), Math.round(d.y - rise));
    ctx.restore();
  }
}

/* ======================
   LEVEL TOAST
====================== */
function drawLevelToast() {
  if (performance.now() > levelToastUntilMs) return;

  ctx.save();
  ctx.font = "24px system-ui";
  ctx.textBaseline = "middle";

  const text = levelToastText || "LEVEL UP!";
  const w = Math.ceil(ctx.measureText(text).width);
  const x = Math.round(canvas.width / 2 - w / 2);
  const y = Math.round(canvas.height * 0.18);

  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 12, y - 18, w + 24, 36);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x - 11.5, y - 17.5, w + 23, 35);

  ctx.fillStyle = "#fff";
  ctx.fillText(text, x, y);
  ctx.restore();
}


/* ======================
   NAMEPLATE
====================== */
function drawNameplate(x, y, level, name, spriteH = PLAYER_FRAME_H) {
  if (!name) return;

  const lvl = String(level ?? 1);
  const nameText = String(name);

  ctx.save();
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  const padX = 6;
  const h = 18;

  // measure pieces
  const badgePad = 8;
  const badgeW = Math.max(18, Math.ceil(ctx.measureText(lvl).width + badgePad));
  const gap = 6;
  const nameW = Math.ceil(ctx.measureText(nameText).width);

  const w = padX + badgeW + gap + nameW + padX;

  const bx = Math.round(x - w / 2);
  // closer to player (was -20)
  const by = Math.round(y - spriteH / 2 - 20);

  // main plate (dark, subtle)
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(bx, by, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(bx + 0.5, by + 0.5, w - 1, h - 1);

  // level badge: white with black text (black-on-white)
  const badgeX = bx + padX;
  const badgeY = by + 2;
  const badgeH = h - 4;

  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.fillRect(badgeX, badgeY, badgeW, badgeH);
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.strokeRect(badgeX + 0.5, badgeY + 0.5, badgeW - 1, badgeH - 1);

  // level text centered inside badge
  ctx.fillStyle = "rgba(0,0,0,0.95)";
  ctx.textAlign = "center";
  ctx.fillText(lvl, badgeX + badgeW / 2, by + h / 2);

  // name text to the right (no bleeding into badge)
  ctx.textAlign = "left";
  ctx.fillStyle = "#fff";
  ctx.fillText(nameText, badgeX + badgeW + gap, by + h / 2);

  ctx.restore();
}



/* ======================
   MAIN LOOP
====================== */
let last = performance.now();


function drawPortals() {
  if (!portals) return;

  const t = performance.now() * 0.004;
  const pulse = (Math.sin(t) + 1) * 0.5;

  for (const p of portals) {
    const x = p.x * TILE_SIZE;
    const y = p.y * TILE_SIZE;

    ctx.save();
    ctx.globalAlpha = 0.4 + pulse * 0.3;
    ctx.strokeStyle = "#7fffd4";
    ctx.lineWidth = 3;

    const r = TILE_SIZE * (0.35 + pulse * 0.05);
    ctx.beginPath();
    ctx.arc(
      x + TILE_SIZE / 2,
      y + TILE_SIZE / 2,
      r,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.restore();
  }
}


function loop(nowMs) {
  const dt = (nowMs - last) / 1000;
  last = nowMs;

  try {

  updateCamera();
  updateFade(dt);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw nameplates last (above canopies)
  const nameplates = [];

  const shake = getShakeOffset();

  ctx.save();
  ctx.translate(-camX + shake.x, -camY + shake.y);

  drawMap();
  drawPortals();
  drawPortals();
  // drawObjects("below"); // non-canopy objects are now depth-sorted with entities

  // drops behind entities
  for (const d of Object.values(worldDrops)) {
    const itemId = d.itemId || "coin";
    if (itemId === "coin") drawCoin(d.x, d.y, d.amount || d.qty || 1);
    else drawItemDrop(itemId, d.x, d.y);
  }

  // projectiles behind entities (feels good for bolts)
  for (const pr of Object.values(worldProjectiles)) {
    drawProjectile(pr);
  }

  const me = getMyPos();

  // Defer world-space prompts until after objects/canopies + nameplates so they never render under the object layer.
  const portalPrompt = (me && isOnPortal()) ? { near: me, text: "Press E to travel", spriteH: PLAYER_FRAME_H } : null;

  cachedNearestNpc = computeNearestNpc();
  const npcPrompt = cachedNearestNpc ? { near: cachedNearestNpc, text: "Press E", spriteH: NPC_DRAW_H } : null;
  const entities = [];

  // object-layer solids (stumps/rocks) depth-sort with entities so you can walk behind them
  if (objMap) {
    const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
    const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
    const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
    const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

    for (let oy = startTy; oy <= endTy; oy++) {
      for (let ox = startTx; ox <= endTx; ox++) {
        const ot = objMap[oy][ox];
        if (!ot) continue;
        if (isObjCanopy(ot)) continue; // canopies are drawn in a separate pass on top
        const px = ox * TILE_SIZE;
        const py = oy * TILE_SIZE;
        entities.push({
          kind: "obj",
          id: `obj:${ox},${oy}:${ot}`,
          tile: ot,
          px,
          py,
          // sort by bottom of tile so players can walk "in front of" or "behind" the base
          sortY: py + TILE_SIZE,
        });
      }
    }
  }

  for (const [id, p] of Object.entries(worldPlayers)) {
    const pos = getSmoothedPos(id, p.x, p.y);
    // IMPORTANT: use a feet anchor for depth sorting (keep render position unchanged)
    // 64x64 sprites: feet are ~22px below the sprite center.
    entities.push({ kind:"player", id, x: pos.x, y: pos.y, sortY: pos.y + 22 });
  }
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    entities.push({ kind:"npc", id, x: pos.x, y: pos.y, sortY: pos.y + NPC_SORT_Y_OFFSET });
  }
  for (const [id, m0] of Object.entries(worldMobs)) {
    const pos = getSmoothedPos(id, m0.x, m0.y);
    entities.push({ kind:"mob", id, x: pos.x, y: pos.y, sortY: pos.y });
  }

  // Depth sort using an explicit anchor when provided.
  entities.sort((a,b) => (a.sortY ?? a.y) - (b.sortY ?? b.y));

  for (const e of entities) {
    if (e.kind === "obj") {
      drawObjectTile(e.tile, e.px, e.py);
      continue;
    }

    const st = updateAnim(e.id, e.x, e.y, dt);

    const fx = hitFx.get(e.id);
    let bumpX = 0, bumpY = 0;
    if (fx && performance.now() < fx.untilMs) {
      const t = (fx.untilMs - performance.now()) / 220;
      bumpX = (fx.bumpX || 0) * t;
      bumpY = (fx.bumpY || 0) * t;
    } else if (fx) {
      hitFx.delete(e.id);
    }

    const drawX = e.x + bumpX;
    const drawY = e.y + bumpY;


    // Static NPC rendering (single-image NPCs)
    if (e.kind === "npc") {
      const n = worldNpcs[e.id] || {};
      const key = n.sprite || null;
      const img = key ? (npcImages[key] || null) : null;

      if (img && img.complete && img.naturalWidth > 0) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, Math.round(drawX - NPC_DRAW_W/2), Math.round(drawY - NPC_DRAW_H/2), NPC_DRAW_W, NPC_DRAW_H);
      } else {
        // Fallback: draw legacy npc sheet if image not loaded yet
        drawSprite(npcSprite, drawX, drawY, st.dir, st.frame, NPC_FRAME_W, NPC_FRAME_H);
      }
      continue;
    }

    if (e.kind === "mob") {
      const mob = worldMobs[e.id];
      const type = mob?.mobType || "purple";
      const sprite = mobSprites[type] || mobSprites.purple;
      const { w: mobFW, h: mobFH } = getMobFrameSize(sprite);


      // Death "corpse" animation (no new sprites): persist 2s, slight shrink + fade at the end.
      const isCorpse = !!mob?.dead && (mob.corpseMs > 0);
      if (isCorpse) {
        const elapsed = clamp((CORPSE_TOTAL_MS - mob.corpseMs) / CORPSE_TOTAL_MS, 0, 1);
        const s = 1 - 0.12 * elapsed; // subtle shrink
        const alpha = (mob.corpseMs <= CORPSE_FADE_MS) ? clamp(mob.corpseMs / CORPSE_FADE_MS, 0, 1) : 1;

        // Draw with transform so shrink is centered on the mob.
        if (sprite.complete && sprite.naturalWidth) {
          const dirRow = st.dir, frameCol = st.frame;
          const sx = frameCol * mobFW;
          const sy = dirRow * mobFH;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.translate(Math.round(drawX), Math.round(drawY));
          ctx.scale(s, s);
          ctx.drawImage(sprite, sx, sy, mobFW, mobFH, -mobFW/2, -mobFH/2, mobFW, mobFH);
          ctx.restore();
        }

        // Keep HP bar at 0 HP while the corpse is still fully visible,
        // but hide it the moment the corpse starts fading out.
        // (Fade begins during the last CORPSE_FADE_MS.)
        if (mob && mob.corpseMs > CORPSE_FADE_MS) {
          const me = getMyPos();
          if (shouldShowMobHp(mob, me, drawX, drawY)) {
            drawHpBarWorld(drawX, drawY, 0, mob.maxHp ?? 1, mobFH);
          }
        }

        if (debugHitboxes && mob) {
          drawDebugCircle(drawX, drawY, (mob.radius ?? DBG_MOB_R), "rgba(255,60,60,0.95)");
        }
        continue;
      }
      // Fade-in when a mob spawns/respawns
      const spawnAt = mobSpawnAtMs.get(e.id) ?? 0;
      const spawnAlpha = spawnAt ? clamp((performance.now() - spawnAt) / MOB_SPAWN_FADE_MS, 0, 1) : 1;

      ctx.save();
      ctx.globalAlpha = spawnAlpha;

      drawSprite(sprite, drawX, drawY, st.dir, st.frame, mobFW, mobFH);

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(sprite, drawX, drawY, st.dir, st.frame, fx.color || "rgba(255,255,255,0.45)", mobFW, mobFH);
      }
      if (mob) {
        const me = getMyPos();
        if (shouldShowMobHp(mob, me, drawX, drawY)) {
          drawHpBarWorld(drawX, drawY, mob.hp ?? 0, mob.maxHp ?? 1, mobFH);
        }
      }
      if (debugHitboxes && mob) {
        drawDebugCircle(drawX, drawY, (mob.radius ?? DBG_MOB_R), "rgba(255,60,60,0.95)");
      }
      ctx.restore();
      continue;
    }

    const isNpc = (e.kind === "npc");
    const p = isNpc ? null : worldPlayers[e.id];

    // attack-active flag (used to suppress idle pose while swinging)
    const serverAtkAnim = p ? (p.atkAnim || 0) : 0;
    const attacking = (serverAtkAnim > 0);

    // match the movement test used by updateAnim()
    const movingNow = (e.id === myId)
      ? (keys.left || keys.right || keys.up || keys.down)
      : (st.sinceMove < 0.22);

    const idlePose = (!isNpc) && (!movingNow) && (!attacking);

    // choose base sprite (idle uses a 2-col sheet)
    let bodySprite = npcSprite;
    let bodyFrame = st.frame;
    let bodyFW = NPC_FRAME_W, bodyFH = NPC_FRAME_H;
    if (!isNpc) {
      bodySprite = idlePose ? playerIdleSprite : playerSprite;
      bodyFrame = idlePose ? (st.idleFrame || 0) : st.frame;
      bodyFW = PLAYER_FRAME_W; bodyFH = PLAYER_FRAME_H;
    }

    // Weapon visuals: draw UP swings *behind* the player so they don't sit on top of the sprite.
    // (Left/Right/Down stay in front as before.)
    let weapon = null;
    let hasEquippedWeapon = false;
    const p2 = (!isNpc) ? worldPlayers[e.id] : null;
    let weaponActive = false;
    let weaponPhase01 = 0;
    let weaponDrawnBehind = false;
    let heldWeaponDrawnBehind = false;
    let renderDir = st.dir;  // direction used for rendering (locks during attack)
    if (!isNpc) {
      weapon = (p2 && p2.weapon && p2.weapon !== "none" && p2.weapon !== "unarmed") ? p2.weapon : null;
      hasEquippedWeapon = !!(p2 && p2.equipment && p2.equipment.weapon);
      if (!hasEquippedWeapon) weapon = null;

      const serverAnim = p2 ? (p2.atkAnim || 0) : 0;
      weaponActive = (serverAnim > 0) && hasEquippedWeapon && !!weapon;
      if (weaponActive) {
        // serverAnim counts down from LOCAL_SWING_DUR
        weaponPhase01 = clamp(1 - (serverAnim / LOCAL_SWING_DUR), 0, 1);

        // Use an attack-locked direction while the weapon animation is active.
renderDir = st.dir;
if (!isNpc && weaponActive) {
  const wp = worldPlayers[e.id];
    const atkDirStr = wp && wp.atkDir;
    if (atkDirStr) {
      renderDir = (atkDirStr === "up") ? DIR.UP : (atkDirStr === "down") ? DIR.DOWN : (atkDirStr === "left") ? DIR.LEFT : DIR.RIGHT;
    } else if (wp && wp.facing && Number.isFinite(wp.facing.x) && Number.isFinite(wp.facing.y)) {
      const d = dirFromVector(wp.facing.x, wp.facing.y);
      if (d != null) renderDir = d;
    }
  }

const weaponBehind = (renderDir === DIR.UP) && (weapon === "sword" || weapon === "spear");
        if (weaponBehind) {
          if (weapon === "sword") drawSwordSlash(drawX, drawY, renderDir, weaponPhase01, getSwordSpriteForPlayer(p2));
          else if (weapon === "spear") drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p2), e.id);
          weaponDrawnBehind = true;
        }
      }
    }

    

    // Persistent spear when equipped (not attacking).
    // IMPORTANT: while weaponActive is true, we only draw the thrust (using the attack-locked renderDir).
    // This prevents the “held” spear from popping to a new facing direction mid-animation (no double-spears).
    // Persistent held weapon when equipped.
// For wand: keep it visible even while attacking/casting.
// For sword/spear: keep previous behavior (don't double-draw during the swing).
if (!isNpc && renderDir === DIR.UP) {
  if (weapon === "wand") {
    drawWandHeld(drawX, drawY, renderDir, getWandSpriteForPlayer(p2));
    heldWeaponDrawnBehind = true;
  } else if (!weaponActive) {
    if (weapon === "spear") {
      drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p2));
      heldWeaponDrawnBehind = true;
    } else if (weapon === "sword") {
      drawSwordHeld(drawX, drawY, renderDir, getSwordSpriteForPlayer(p2));
      heldWeaponDrawnBehind = true;
    }
  }
}
drawSprite(bodySprite, drawX, drawY, renderDir, bodyFrame, bodyFW, bodyFH);

    // paper-doll overlays (armor + hat)
    let armorSprite = null;
    let hatSprite = null;
    if (!isNpc) {
      const armorId = p?.equipment?.armor;
      if (armorId) {
        const aImg = idlePose ? armorIdleOverlays[armorId] : armorOverlays[armorId];
        const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
        if (aImg) {
          armorSprite = aImg;
          drawSprite(aImg, drawX, drawY, renderDir, aFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      const hatId = p?.equipment?.hat;
      if (hatId) {
        const hImg = idlePose ? hatIdleOverlays[hatId] : hatOverlays[hatId];
        const hFrame = idlePose ? (st.idleFrame || 0) : st.frame;
        if (hImg) {
          hatSprite = hImg;
          drawSprite(hImg, drawX, drawY, renderDir, hFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(bodySprite, drawX, drawY, st.dir, bodyFrame, fx.color || "rgba(255,0,0,0.45)", bodyFW, bodyFH);
        if (armorSprite) {
          const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
          drawHitTintOnTop(armorSprite, drawX, drawY, st.dir, aFrame, fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
        if (hatSprite) {
          drawHitTintOnTop(hatSprite, drawX, drawY, st.dir, (st.idleFrame || 0), fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }
    }
    // name + level above players (all clients) - queued to draw after canopy pass
    if (!isNpc) {
      const p = worldPlayers[e.id];
      if (p) nameplates.push({ x: drawX, y: drawY, level: p.level, name: p.name, spriteH: PLAYER_FRAME_H });
    }


    // debug collision overlays
    if (debugHitboxes && !isNpc) {
      // Player foot hitbox (matches server)
      drawDebugCircle(drawX, drawY + DBG_PLAYER_FOOT_Y, DBG_PLAYER_R, "rgba(80,160,255,0.95)");

      // Weapon hitbox (only while attacking)
      if (weaponActive) {
        const p0 = worldPlayers[e.id];
        const wid = p0?.equipment?.weapon;
        const wkey = p0?.weapon || weaponKeyFromEquippedId(wid);
        const d = dirVecFromAtkDir(p0?.atkDir, p0?.facing);
        if (wkey === "sword") {
				  const f = d; // already normalized dir vec
		  const perp = { x: -f.y, y: f.x };

		  const tests = [
			{ forward: 32, side: 0,  rad: 38 },
			{ forward: 28, side: 14, rad: 34 },
			{ forward: 28, side: -14, rad: 34 },
		  ];

		  for (const t of tests) {
			const cx = drawX + f.x * t.forward + perp.x * t.side;
			const cy = drawY + f.y * t.forward + perp.y * t.side;
			drawDebugCircle(cx, cy, t.rad, "rgba(255,220,40,0.95)");
		  }
		
        } else if (wkey === "spear") {
          drawDebugCircle(drawX + d.x * DBG_SPEAR_OFFSET, drawY + d.y * DBG_SPEAR_OFFSET, DBG_SPEAR_R, "rgba(255,220,40,0.95)");
        } else if (wkey === "wand") {
          // show your projectiles as the active weapon hitboxes
          for (const pr of Object.values(worldProjectiles || {})) {
            if (pr.mapId !== currentMapId) continue;
            if (pr.ownerId && pr.ownerId !== e.id) continue;
            const r = pr.rad ?? 10;
            drawDebugCircle(pr.x, pr.y, r, "rgba(255,220,40,0.95)");
          }
        }
      }
    }
    // weapon visuals for players (front pass)
    if (!isNpc && weaponActive && !weaponDrawnBehind) {
      if (weapon === "sword") drawSwordSlash(drawX, drawY, renderDir, weaponPhase01, getSwordSpriteForPlayer(p2));
      else if (weapon === "spear") drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p), e.id);
      else if (weapon === "wand") drawWandCastSpark(drawX, drawY, renderDir, weaponPhase01);
    }

    // Persistent spear when equipped (not attacking) — front pass (Left/Right/Down).
    if (!isNpc && (!weaponActive || weapon === "wand") && !heldWeaponDrawnBehind) {
      if (weapon === "spear") {
        drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p));
      } else if (weapon === "sword") {
        drawSwordHeld(drawX, drawY, renderDir, getSwordSpriteForPlayer(p));
      } else if (weapon === "wand") {
        drawWandHeld(drawX, drawY, renderDir, getWandSpriteForPlayer(p));
      }
    }
  }

  drawObjects("canopy");

  // nameplates last so they never sort under canopies
  for (const np of nameplates) {
    drawNameplate(np.x, np.y, np.level, np.name, np.spriteH);
  }

  // prompts after canopies + nameplates so they're always visible
  if (portalPrompt) drawPrompt(portalPrompt.near, portalPrompt.text, portalPrompt.spriteH);
  if (npcPrompt) drawPrompt(npcPrompt.near, npcPrompt.text, npcPrompt.spriteH);

  drawDialogueBubble(activeDialogue);

  // world-space impact sparks (follow camera)
  drawHitSparks();

  // world-space popups (follow camera)
  drawDamagePops();
  drawLootPops();

  // Skill overlays (world-space, includes Skill 1 targeting + active whirlpools)
  drawSkill1Overlays();
  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();

  drawFadeOverlay();
  drawHud();
  drawHotbar();

  if (inventoryOpen) {
    const me = worldPlayers[myId];
    drawInventory(me?.inventory, me?.equipment);

    // Tooltip (on hover)
    if (uiMouse.has && invUI) {
      invHover = getInventoryHover(uiMouse.mx, uiMouse.my, me?.inventory, me?.equipment);
      if (invHover) {
        // Prefer to the right/bottom of the cursor.
        drawInventoryTooltip(invHover, uiMouse.mx + 18, uiMouse.my + 18);
      }
    }
  } else {
    invUI = null;
    invHover = null;
  }
  if (skillsOpen) {
    drawSkillsMenu();
  } else {
    skillsUI = null;
  }

  drawLevelToast();

  }
  catch (err) {
    console.error('Render loop error:', err);
  }

  requestAnimationFrame(loop);

}

requestAnimationFrame(loop);
</script>
</body>
</html>