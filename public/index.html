<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<title>Mini MMO</title>
<style>
    body { background:#222; color:#ddd; font-family: system-ui, sans-serif; }
    canvas { border: 1px solid #555; image-rendering: pixelated; }
  
/* --- HUD button (hamburger inventory) --- */
.game-wrap { position: relative; display: inline-block; }
.hud-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 38px;
  height: 38px;
  border-radius: 12px;
  background: rgba(0,0,0,0.55);
  border: 1px solid rgba(255,255,255,0.18);
  color: #fff;
  font-size: 22px;
  line-height: 1;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}
.hud-btn:hover { background: rgba(0,0,0,0.70); }
.hud-btn:active { transform: translateY(1px); }
.hud-btn:focus { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

  
/* --- Main menu dropdown (hamburger) --- */
.main-menu {
  position: absolute;
  top: 54px;          /* below the ☰ button */
  right: 10px;
  min-width: 160px;
  padding: 8px;
  border-radius: 14px;
  background: rgba(0,0,0,0.72);
  border: 1px solid rgba(255,255,255,0.16);
  box-shadow: 0 10px 26px rgba(0,0,0,0.35);
  display: none;
  z-index: 30;
}
.main-menu.open { display: block; }
.main-menu-item {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 10px;
  margin: 0;
  border: 0;
  border-radius: 12px;
  background: rgba(255,255,255,0.06);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  user-select: none;
}
.main-menu-item + .main-menu-item { margin-top: 6px; }
.main-menu-item:hover { background: rgba(255,255,255,0.10); }
.main-menu-item:active { transform: translateY(1px); }
.main-menu-item:focus { outline: 2px solid rgba(255,255,255,0.28); outline-offset: 2px; }
.main-menu-item .hint {
  font-size: 12px;
  opacity: 0.75;
}
.main-menu-item.disabled,
.main-menu-item:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}

  /* --- Editor side panel (off-canvas UI, same window) --- */
.app-layout{display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap;}
.editor-panel{
  width: 320px;
  max-width: 92vw;
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.14);
  border-radius: 14px;
  padding: 10px;
  box-shadow: 0 10px 26px rgba(0,0,0,0.30);
}
.editor-panel.hidden{display:none;}
.editor-panel h2{margin:6px 0 8px; font-size:14px; font-weight:700;}
.editor-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px;}
.editor-row button, .editor-row select{
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  color:#fff;
  border-radius: 10px;
  padding: 7px 10px;
  cursor:pointer;
  font-size: 12px;
}
.editor-row button:hover{background: rgba(255,255,255,0.12);}
.editor-row input{
  width: 100%;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.14);
  color:#fff;
  border-radius: 10px;
  padding: 8px 10px;
  font-size: 12px;
}
.tile-grid{
  display:grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  max-height: 520px;
  overflow:auto;
  padding-right: 2px;
}
.tile-btn{
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.25);
  padding: 6px;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
}
.tile-btn.selected{
  outline: 2px solid rgba(255,255,255,0.55);
  outline-offset: 2px;
}
.tile-btn canvas{width:100%; height:100%; image-rendering: pixelated;}
.editor-meta{font-size:12px; opacity:0.85; margin-top:8px; line-height:1.3;}

/* --- Mob spawn attribute panel (appears under palette when Layer: MOBS) --- */
.editor-mobprops{
  margin-top: 10px;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid rgba(90,180,255,0.55);
  background: rgba(0,0,0,0.28);
}
.editor-mobprops.hidden{display:none;}
.mobprops-title{font-size:12px; font-weight:800; margin-bottom:6px; opacity:0.95;}
.mobprops-hint{font-size:12px; opacity:0.75; margin-bottom:10px; line-height:1.3;}
.mobprops-grid{display:grid; grid-template-columns: 1fr; gap:8px;}
.mobprops-row{display:grid; grid-template-columns: 120px 1fr; gap:10px; align-items:center;}
.mobprops-row label{font-size:12px; opacity:0.9;}
.mobprops-row input[type="number"]{width:100%;}
.mobprops-row input[type="checkbox"]{width:18px; height:18px; justify-self:start;}
.mobprops-readonly{font-size:12px; opacity:0.92; padding:6px 8px; border-radius:10px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);}
.mobprops-actions{display:flex; gap:8px; justify-content:flex-end; margin-top:10px;}
.mobprops-actions button{
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  color:#fff;
  border-radius: 10px;
  padding: 7px 10px;
  cursor:pointer;
  font-size: 12px;
}
.mobprops-actions button:hover{background: rgba(255,255,255,0.12);}



/* --- Mobile game-mode interaction safeguards (prevent text selection/callouts) --- */
html, body {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

/* Allow text entry where needed (editor search, mob props inputs, etc.) */
input, textarea, [contenteditable="true"] {
  -webkit-user-select: text;
  user-select: text;
  -webkit-touch-callout: default;
}

/* Game surfaces / HUD buttons should not select text or trigger callouts */
.game-wrap, #c, .hud-btn, .main-menu, .main-menu-item {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

/* Prevent browser gesture handling on the game canvas */
#c {
  touch-action: none;
}
@media (max-width: 900px){
  .app-layout{flex-direction:column;}
  .editor-panel{width: min(720px, 96vw);}
  .tile-grid{grid-template-columns: repeat(8, 1fr); max-height: 240px;}
}

  </style>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" name="viewport"/><meta content="#000000" name="theme-color"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="Mini MMO" name="apple-mobile-web-app-title"/><link href="/manifest.webmanifest" rel="manifest"/><link href="/icons/icon-180.png" rel="apple-touch-icon"/></head>
<body>
<h1>Mini MMO23</h1>
<p>WASD / Arrow keys • Press <b>E</b> near NPC / portal • Left-click to attack • Press <b>I</b> (or ☰) for inventory • Press <b>K</b> for skills</p>
<div class="app-layout" id="appLayout">
<div class="game-wrap" id="gameWrap">
<button aria-expanded="false" aria-label="Open inventory (I)" class="hud-btn" id="invBtn" type="button">☰</button>
<div aria-label="Game menu" class="main-menu" id="mainMenu" role="menu">
<button class="main-menu-item" data-action="items" role="menuitem" type="button">Items <span class="hint">I</span></button>
<button class="main-menu-item" data-action="skills" role="menuitem" type="button">Skills <span class="hint">K</span></button>
<button class="main-menu-item" data-action="book" role="menuitem" type="button">Monster Book <span class="hint">B</span></button>
<button aria-disabled="true" class="main-menu-item disabled" data-action="quests" disabled="" role="menuitem" type="button">Quests <span class="hint">Soon</span></button>
<button aria-disabled="true" class="main-menu-item disabled" data-action="settings" disabled="" role="menuitem" type="button">Settings <span class="hint">Soon</span></button>
</div>
<canvas height="600" id="c" width="800"></canvas>

    </div>
    <div class="editor-panel hidden" id="editorPanel" aria-label="Map editor panel">
      <h2>Map Editor</h2>
      <div class="editor-row">
        <button type="button" id="editorLayerBtn">Layer: GROUND</button>
        <button type="button" id="editorGridBtn">Grid: ON</button>
        <button type="button" id="editorCollBtn">Coll: ON</button>
        <button type="button" id="editorExportBtn" title="Ctrl+E">Export</button>
      </div>
      <div class="editor-row">
        <input id="editorSearch" type="text" placeholder="Filter by tile # (e.g., 12) — tags later" />
      </div>
      <div class="editor-meta" id="editorStatus">Cursor: —</div>
      <div class="tile-grid" id="editorTileGrid"></div>
            <div class="editor-meta" id="editorMeta">Select a tile.</div>
      <div class="editor-mobprops hidden" id="editorMobProps" aria-label="Mob spawn properties">
        <div class="mobprops-title">Mob Spawn</div>
        <div class="mobprops-hint" id="editorMobPropsHint">Click a mob spawn on the map to edit its attributes.</div>

        <div class="mobprops-grid" id="editorMobPropsGrid">
          <div class="mobprops-row">
            <label>Type</label>
            <div class="mobprops-readonly" id="mobPropType">—</div>
          </div>
          <div class="mobprops-row">
            <label>Tile</label>
            <div class="mobprops-readonly" id="mobPropPos">—</div>
          </div>

          <div class="mobprops-row">
            <label for="mobPropCount">Count</label>
            <input id="mobPropCount" type="number" min="1" step="1" value="1"/>
          </div>
          <div class="mobprops-row">
            <label for="mobPropRespawn">Respawn (s)</label>
            <input id="mobPropRespawn" type="number" min="0" step="1" value="30"/>
          </div>
          <div class="mobprops-row">
            <label for="mobPropLeash">Leash (tiles)</label>
            <input id="mobPropLeash" type="number" min="0" step="1" value="8"/>
          </div>
          <div class="mobprops-row">
            <label for="mobPropAggroRadius">Aggro radius</label>
            <input id="mobPropAggroRadius" type="number" min="0" step="1" value="6"/>
          </div>

          <div class="mobprops-row">
            <label for="mobPropPassive">Passive until hit</label>
            <input id="mobPropPassive" type="checkbox"/>
          </div>

          <div class="mobprops-row">
            <label for="mobPropSpeed">Speed ×</label>
            <input id="mobPropSpeed" type="number" min="0.1" step="0.1" value="1"/>
          </div>
          <div class="mobprops-row">
            <label for="mobPropAggroSpeed">Aggro speed ×</label>
            <input id="mobPropAggroSpeed" type="number" min="0.1" step="0.1" value="1"/>
          </div>
          <div class="mobprops-row">
            <label for="mobPropMaxHp">Max HP (override)</label>
            <input id="mobPropMaxHp" type="number" min="1" step="1" value="" placeholder="(use mob default)"/>
          </div>
        </div>

        <div class="mobprops-actions">
          <button type="button" id="mobPropApplyDefaults">Defaults</button>
          <button type="button" id="mobPropDelete">Delete</button>
        </div>
      </div>
    </div>
</div>
<script src="/mobile_controls.js"></script><script>
"use strict";

// ===== Mobile browser UX: prevent text-selection/callout on game surface =====
(function setupGameSurfaceTouchGuards(){
  const prevent = (e) => {
    // Allow normal behavior for editable fields (editor inputs/search)
    const t = e.target;
    if (t && (t.closest?.('input, textarea, [contenteditable="true"]'))) return;
    e.preventDefault();
  };

  function bindGuards() {
    const canvasEl = document.getElementById('c');
    const gameWrapEl = document.getElementById('gameWrap') || document.querySelector('.game-wrap');
    const menuEl = document.getElementById('mainMenu');
    const btnEl = document.getElementById('invBtn');
    [canvasEl, gameWrapEl, menuEl, btnEl].forEach((el) => {
      if (!el || el.__touchGuardsBound) return;
      el.__touchGuardsBound = true;
      el.addEventListener('touchstart', prevent, { passive:false });
      el.addEventListener('touchmove', prevent, { passive:false });
      el.addEventListener('touchend', prevent, { passive:false });
      el.addEventListener('contextmenu', (e) => e.preventDefault());
      el.addEventListener('dragstart', (e) => e.preventDefault());
      el.addEventListener('selectstart', (e) => e.preventDefault());
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindGuards, { once:true });
  } else {
    bindGuards();
  }
})();


// ===== Mobile: suppress synthetic "tap -> mousedown" basic attacks =====
// Many mobile browsers generate mouse events after a touch. We track the most recent touch
// and ignore only the *click-to-attack* handler when the mousedown is touch-originated.
let __lastTouchTs = 0;
window.addEventListener("touchstart", () => { __lastTouchTs = Date.now(); }, { capture: true, passive: true });

function isTouchOriginMouseEvent(e) {
  try {
    if (e && e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return true;
  } catch (_) {}
  return (Date.now() - __lastTouchTs) < 900;
}

/* ==========================================================
   DEV / READABILITY HELPERS
   - Toggle logging by running:   __DEV__.log = true
   - Keep this OFF in production; it can be noisy.
========================================================== */
const __DEV__ = { log: false };
function dlog(...args) { if (__DEV__.log) console.log(...args); }

/* ======================
   CONFIG
====================== */
let TILE_SIZE = 64;
let PORTAL_TILE = 3;
// Debug: collision visuals (client-only). Toggle with F3.
let debugHitboxes = false;
const DBG_PLAYER_R = 14;       // matches server PLAYER_FOOT_RADIUS
const DBG_PLAYER_FOOT_Y = 22;  // matches server PLAYER_FOOT_OFFSET_Y
const DBG_MOB_R = 16;          // matches server MOB_RADIUS
const DBG_SWORD_OFFSET = 40;   // matches server melee constants
const DBG_SWORD_R = 55;
const DBG_SPEAR_OFFSET = 50;
const DBG_SPEAR_R = 32;

// Corpse animation
const CORPSE_TOTAL_MS = 2000;
const CORPSE_FADE_MS = 650; // last part fades out


const PLAYER_FRAME_W = 64;
const PLAYER_FRAME_H = 64;

// Most existing spritesheets in this project are still 48x48.
// We keep their sizes separate so changing the player doesn't break NPCs/mobs/tiles.
const NPC_FRAME_W = 48;
const NPC_FRAME_H = 48;
const MOB_FRAME_W = 48;
const MOB_FRAME_H = 48;

// Auto-detect mob frame size from the spritesheet image.
// Assumes mobs are laid out as 3 columns (frames) x 4 rows (directions).
function getMobFrameSize(img) {
  // Fallback to legacy defaults until the image is loaded.
  if (!img || !img.complete || img.naturalWidth === 0) return { w: MOB_FRAME_W, h: MOB_FRAME_H };
  const w = Math.floor(img.naturalWidth / COLS); // COLS = 3
  const h = Math.floor(img.naturalHeight / 4);   // 4 direction rows
  return { w, h };
}


const COLS = 3; // columns per row in your 3-frame spritesheets
const WALK_SEQ = [0, 1, 0, 2]; // frame order: 1,2,1,3 (0-based cols)
const IDLE_FRAME_TIME = 0.7; // seconds per idle frame (~1.4 FPS)

const SNAPSHOT_HZ = 30;
const SNAPSHOT_DT = 1 / SNAPSHOT_HZ;
const INTERP_DELAY = SNAPSHOT_DT * 1.5;

const INTERACT_DIST = 80;
const MOB_HPBAR_DIST = 220; // px: only show enemy HP bars within this distance

// ======================
// SKILLS (client-side UI/state)
// ======================
const SKILL1_RANGE_PX = 200; // targeting preview radius
const SKILL1_EFFECT_RADIUS_PX = 200; // effect radius (server also sends w.rad)
let skill1Primed = false;

// Duration of the Healing Cloud (Skill 6) in milliseconds
const SKILL6_CLOUD_ACTIVE_MS = 10_000;

// Client-side cast time for Healing Cloud (visual delay before the spell fires)
const SKILL6_CAST_TIME_MS = 1500; // 1.5s cast time
// Brief wand casting pose (local visual only)
const CASTING_POSE_MS = 260;      // default quick pose (e.g., for Arcane Bolt)
let castingPoseUntilMs = 0;
let castingPoseDurationMs = 0;
let skill6CastEndClientMs = 0;
let skill6CastArmed = false;


// Hotbar feedback when player tries to use Skill 1 while it is not available
let skill1HotbarNackUntilMs = 0;   // UI time (performance.now)
let skill1HotbarShakeUntilMs = 0;  // UI time (performance.now)
let skill1HotbarShakeSeed = 0;

function triggerSkill1HotbarNack() {
  const now = performance.now();
  skill1HotbarNackUntilMs = now + 420;
  skill1HotbarShakeUntilMs = now + 420;
  skill1HotbarShakeSeed = Math.random() * 1000;
}


// Server-authoritative timers for local player (updated via ws messages)
let skill1ActiveUntilMs = 0; // while whirlpool is running
let skill1CdUntilMs = 0;     // when the skill can be cast again (cooldown timer (server))
let skill1ActiveTotalMs = 0; // client-learned total active duration (for UI)
let skill1CdTotalMs = 0;     // client-learned total cooldown duration (for UI)
let _lastSkill1ActiveUntilMs = 0;
let _lastSkill1CdUntilMs = 0;

// Healing Cloud (Skill 6) duration for our local player (server authoritative)
let skill6CloudUntilMs = 0;

// ===== Skill 2: Double Stab (spear-only) =====
let skill2CdUntilMs = 0;
let skill2CdTotalMs = 0;
let _lastSkill2CdUntilMs = 0;

// Hotbar feedback when player tries to use Skill 2 while it is not available
let skill2HotbarNackUntilMs = 0;   // UI time (performance.now)
let skill2HotbarShakeUntilMs = 0;  // UI time (performance.now)
let skill2HotbarShakeSeed = 0;

function triggerSkill2HotbarNack() {
  const now = performance.now();
  skill2HotbarNackUntilMs = now + 420;
  skill2HotbarShakeUntilMs = now + 420;
  skill2HotbarShakeSeed = Math.random() * 1000;
}

// For spear scaling/jut visuals during the double-stab window (map-scoped)
const skill2FxByCaster = new Map(); // casterId -> { startMs }
const SKILL2_GAP_MS = 120;
const SKILL2_VIS_MS = 360;

// ===== Skill 3: Dash Slash (sword-only) =====
let skill3CdUntilMs = 0;
let skill3CdTotalMs = 0;
let _lastSkill3CdUntilMs = 0;

// Hotbar feedback when player tries to use Skill 3 while it is not available
let skill3HotbarNackUntilMs = 0;
let skill3HotbarShakeUntilMs = 0;
let skill3HotbarShakeSeed = 0;
let skill3DashOverrideDir = null; // "up" | "down" | "left" | "right" when triggered via double-tap


function triggerSkill3HotbarNack() {
  const now = performance.now();
  skill3HotbarNackUntilMs = now + 420;
  skill3HotbarShakeUntilMs = now + 420;
  skill3HotbarShakeSeed = Math.random() * 1000;
}

// ===== Skill 4: Wide Slash (sword-only) =====
let skill4CdUntilMs = 0;
let skill4CdTotalMs = 0;
let _lastSkill4CdUntilMs = 0;

// Hotbar feedback when player tries to use Skill 4 while it is not available
let skill4HotbarNackUntilMs = 0;   // UI time (performance.now)
let skill4HotbarShakeUntilMs = 0;  // UI time (performance.now)
let skill4HotbarShakeSeed = 0;

function triggerSkill4HotbarNack() {
  const now = performance.now();
  skill4HotbarNackUntilMs = now + 420;
  skill4HotbarShakeUntilMs = now + 420;
  skill4HotbarShakeSeed = Math.random() * 1000;
}

// Optional: dash trail visuals (map-scoped)
const skill3FxByCaster = new Map(); // casterId -> { startMs, from:{x,y}, to:{x,y} }
const SKILL3_TRAIL_MS = 220;

function drawSkill3Trails() {
  if (!skill3FxByCaster || skill3FxByCaster.size === 0) return;

  const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();

  for (const [cid, fx] of skill3FxByCaster.entries()) {
    const t = nowAbs - (fx.startMs || 0);
    if (t < 0) continue;
    if (t > SKILL3_TRAIL_MS + 60) { skill3FxByCaster.delete(cid); continue; }

    const a = Math.max(0, 1 - (t / SKILL3_TRAIL_MS));

    const x1 = (fx.from?.x ?? 0) - camX;
    const y1 = (fx.from?.y ?? 0) - camY;
    const x2 = (fx.to?.x ?? 0) - camX;
    const y2 = (fx.to?.y ?? 0) - camY;

    ctx.save();
    ctx.globalAlpha = 0.35 * a;
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // small burst at the end
    ctx.globalAlpha = 0.55 * a;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.arc(x2, y2, 8, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

const TILE_PAD = 1;
const TILESET_COLS = 5; // tiles per row in tiles.png and tiles_objects.png

// ======================
// AUTO-TILE (16-variant) support
// - Stored in the ground layer as a special tile id (does not live in tiles.png).
// - Rendered from its own 4x4 atlas: /assets/autotile_dirtpath.png
// - Neighbor mask bits: N=1, E=2, S=4, W=8  (0..15)
// ======================
const AUTO_DIRTPATH_TILE = 500; // keep <= server EDITOR_MAX_GROUND_TILE (default 999)
const AUTO_DIRTPATH_COLS = 4;   // 4x4 = 16 variants

// ======================
// AUTO WATER (4-frame animated tile)
// Painted as a special ground tile id (does not live in tiles.png).
// Rendered from its own 1x4 atlas: /assets/autotile_water.png
// ======================
const AUTO_WATER_TILE = 505; // keep <= server EDITOR_MAX_GROUND_TILE (default 999)
const AUTO_WATER_FRAMES = 4;
const AUTO_WATER_FPS = 5;

function isAutoWater(tile) { return tile === AUTO_WATER_TILE; }

// Deterministic per-tile phase so water doesn't animate in perfect sync across large lakes.
// Returns a stable value in [0, 1) for a given tile coord (tx, ty).
function autoWaterPhase01(tx, ty) {
  tx = tx | 0; ty = ty | 0;
  let n = (tx * 374761393) ^ (ty * 668265263);
  n = Math.imul(n ^ (n >>> 13), 1274126177);
  n = (n ^ (n >>> 16)) >>> 0;
  return n / 4294967296;
}


function isAutoDirtPath(tile) { return tile === AUTO_DIRTPATH_TILE; }

function autoDirtPathMaskAt(tx, ty) {
  if (!map) return 0;
  let m = 0;
  // N
  if (ty > 0 && map[ty - 1]?.[tx] === AUTO_DIRTPATH_TILE) m |= 1;
  // E
  if (tx + 1 < map[0].length && map[ty]?.[tx + 1] === AUTO_DIRTPATH_TILE) m |= 2;
  // S
  if (ty + 1 < map.length && map[ty + 1]?.[tx] === AUTO_DIRTPATH_TILE) m |= 4;
  // W
  if (tx > 0 && map[ty]?.[tx - 1] === AUTO_DIRTPATH_TILE) m |= 8;
  return m & 15;
}
// Convention: odd rows in tiles.png are passable; even rows are blocked.
const WALL_TILE = TILESET_COLS; // row 2, col 1 (1-based) when cols=5

const BASE_BASIC_SWING_DUR = 0.60; // must match server BASE_BASIC_SWING_SEC
const FLAT_ATTACK_LOCKOUT_SEC = 0.10; // must match server FLAT_ATTACK_LOCKOUT_SEC
function getWeaponSpeedById(itemId) {
  const def = itemId ? ITEM_META[itemId] : null;
  return Math.max(0.05, Number(def?.weaponSpeed) || 1);
}
function getSwingDurByWeaponId(itemId) {
  const spd = getWeaponSpeedById(itemId);
  return Math.max(0.05, BASE_BASIC_SWING_DUR / spd);
}

let nextAttackAtMs = 0; // local send throttle (server also enforces)


let inventoryOpen = false;
let skillsOpen = false;

// ======================
// Movable HUD / Hotbar layout
// ======================
let hudPos = null;       // { x, y } top-left of HP/XP inner rect
let hotbarPos = null;    // { x, y } top-left of hotbar slot 0

let draggingHudBar = false;
let hudDragOffsetX = 0;
let hudDragOffsetY = 0;

let draggingHotbarBar = false;
let hotbarBarDragOffsetX = 0;
let hotbarBarDragOffsetY = 0;

const HUD_POS_STORAGE_KEY = "uiHudPos_v1";
const HOTBAR_POS_STORAGE_KEY = "uiHotbarPos_v1";

function loadUiLayout() {
  try {
    if (typeof window === "undefined" || typeof localStorage === "undefined") return;

    const hRaw = localStorage.getItem(HUD_POS_STORAGE_KEY);
    if (hRaw) {
      try {
        const obj = JSON.parse(hRaw);
        if (obj && typeof obj.x === "number" && typeof obj.y === "number") {
          hudPos = { x: obj.x, y: obj.y };
        }
      } catch (err) {
        // ignore parse errors
      }
    }

    const bRaw = localStorage.getItem(HOTBAR_POS_STORAGE_KEY);
    if (bRaw) {
      try {
        const obj = JSON.parse(bRaw);
        if (obj && typeof obj.x === "number" && typeof obj.y === "number") {
          hotbarPos = { x: obj.x, y: obj.y };
        }
      } catch (err) {
        // ignore parse errors
      }
    }
  } catch (err) {
    // localStorage might be unavailable; fail silently
  }
}

function saveUiLayout() {
  try {
    if (typeof window === "undefined" || typeof localStorage === "undefined") return;

    if (hudPos && typeof hudPos.x === "number" && typeof hudPos.y === "number") {
      localStorage.setItem(HUD_POS_STORAGE_KEY, JSON.stringify(hudPos));
    }
    if (hotbarPos && typeof hotbarPos.x === "number" && typeof hotbarPos.y === "number") {
      localStorage.setItem(HOTBAR_POS_STORAGE_KEY, JSON.stringify(hotbarPos));
    }
  } catch (err) {
    // ignore
  }
}

if (typeof window !== "undefined") {
  window.addEventListener("load", () => {
    loadUiLayout();
  });
}

// ======================
// HOTBAR (1–6)
// - Press 1..6 to use a bound skill/item (initially: 1=Skill1, 2=Skill2)
// - (Optional binding now) Ctrl+1..6 while hovering an inventory item binds that item
// ======================
const HOTBAR_SIZE = 6;

// Client-side hint for "consumable" items (used for inventory submenu + hotbar binding UI).
// Keep this list in sync with server.js ITEMS that have an onUse().
const CONSUMABLE_ITEM_IDS = new Set([
  "potion_small",
  "potion_green",
  "potion_purple",
]);

function isConsumableItemId(itemId) {
  if (!itemId) return false;
  return CONSUMABLE_ITEM_IDS.has(itemId) || itemId.startsWith("potion_");
}

let hotbarSlots = [
  null, null, null, null, null, null,
];
// ------------------------------
// Hotbar persistence (server-side)
// ------------------------------
const HOTBAR_SERVER_SYNC_DEBOUNCE_MS = 120;
let _hotbarSyncT = null;

function sanitizeHotbarSlots(slots) {
  const out = new Array(HOTBAR_SIZE).fill(null);
  if (!Array.isArray(slots)) return out;
  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const s = slots[i];
    if (!s || typeof s !== "object") { out[i] = null; continue; }
    if (s.type === "skill" && typeof s.id === "string") {
      out[i] = { type: "skill", id: s.id };
    } else if (s.type === "item") {
      const itemId = (typeof s.itemId === "string") ? s.itemId : ((typeof s.id === "string") ? s.id : "");
      if (!itemId) { out[i] = null; continue; }
      const preferSlot = Number.isFinite(s.preferSlot) ? s.preferSlot : undefined;
      out[i] = preferSlot === undefined ? { type: "item", itemId } : { type: "item", itemId, preferSlot };
    } else {
      out[i] = null;
    }
  }
  return out;
}

function queueHotbarSync() {
  // Don’t spam the server while the user is binding multiple things quickly.
  if (typeof ws === "undefined") return;
  if (_hotbarSyncT) clearTimeout(_hotbarSyncT);
  _hotbarSyncT = setTimeout(() => {
    _hotbarSyncT = null;
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: "setHotbar", slots: hotbarSlots }));
    }
  }, HOTBAR_SERVER_SYNC_DEBOUNCE_MS);
}

// Quick visual feedback when a hotbar slot is successfully used
const HOTBAR_FLASH_MS = 140;
const hotbarFlashUntilMs = new Array(HOTBAR_SIZE).fill(0);

function triggerHotbarFlashByIndex(idx) {
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarFlashUntilMs[idx] = performance.now() + HOTBAR_FLASH_MS;
}


function hotbarToast(msg, ms = 1400) {
  // Uses your existing toast if present; otherwise falls back to console
  if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
    levelToastText = msg;
    levelToastUntilMs = performance.now() + ms;
  } else {
    console.log("[hotbar]", msg);
  }
}

function resolveInventorySlotIndex(itemId, preferred) {
  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
  const slots = me?.inventory?.slots;
  if (!slots) return -1;

  if (preferred != null && preferred >= 0 && preferred < slots.length) {
    const s = slots[preferred];
    if (s && s.id === itemId) return preferred;
  }
  for (let i = 0; i < slots.length; i++) {
    const s = slots[i];
    if (s && s.id === itemId) return i;
  }
  return -1;
}

function activateSkillById(skillId) {
  // Skill1: your existing wand skill (arms the next shot)
  if (skillId === "skill1") {
    // If you already have a dedicated function, prefer it
    if (typeof activateSkill1 === "function") { activateSkill1(); return true; }

    // Minimal safe implementation using your existing variables/functions
    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();

    if (typeof skill1ActiveUntilMs !== "undefined" && nowAbs < skill1ActiveUntilMs) {
      if (typeof triggerSkill1HotbarNack === "function") triggerSkill1HotbarNack();
      return false;
    }
    if (typeof skill1CdUntilMs !== "undefined" && nowAbs < skill1CdUntilMs) {
      if (typeof triggerSkill1HotbarNack === "function") triggerSkill1HotbarNack();
      return false;
    }

    // Match the old click-to-cast behavior: Skill 1 requires a wand equipped
    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
        levelToastText = "Equip a wand to use Skill 1";
        levelToastUntilMs = performance.now() + 1500;
      } else {
        hotbarToast("Equip a wand to use Skill 1");
      }
      return false;
    }

    // Aim at the last mouse position (no click required). If we don't have a mouse yet, fire forward.
    let wx = null, wy = null, mx = null, my = null;
    if (typeof lastAim !== "undefined" && lastAim && lastAim.has) {
      wx = lastAim.wx; wy = lastAim.wy; mx = lastAim.mx; my = lastAim.my;
    } else {
      const px = me?.x ?? 0;
      const py = me?.y ?? 0;
      const fx = me?.facing?.x ?? 0;
      const fy = me?.facing?.y ?? 1;
      const len = Math.hypot(fx, fy) || 1;
      const dirx = fx / len, diry = fy / len;
      const range = 220;
      wx = px + dirx * range;
      wy = py + diry * range;
    }

        // Brief casting pose for wand skills (local-only visual)
    if (typeof performance !== "undefined") {
      const nowUi = performance.now();
      castingPoseDurationMs = CASTING_POSE_MS;
      castingPoseUntilMs = nowUi + castingPoseDurationMs;
    }

// Arm + immediately fire (no extra click)
    if (typeof sendSkill1Arm === "function") sendSkill1Arm();
    if (typeof sendAttackAtWorld === "function") {
      sendAttackAtWorld(wx, wy, mx, my, { skill1: true });
    } else {
      hotbarToast("Skill1 not available (sendAttackAtWorld missing)");
      return false;
    }

    // Ensure we don't leave a primed state hanging around
    if (typeof skill1Primed !== "undefined") skill1Primed = false;
    if (typeof skill1PrimedUntilMs !== "undefined") skill1PrimedUntilMs = 0;

    return true;
  }

  // Skill5: Familiar (wand-only toggle)
  if (skillId === "skill5") {
    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      hotbarToast("Equip a wand to use Familiar");
      return false;
    }
    if (typeof sendSkill5FamiliarToggle === "function") {
      sendSkill5FamiliarToggle();
      return true;
    }
    hotbarToast("Skill5 not available (sendSkill5FamiliarToggle missing)");
    return false;
  }

  // Skill6: Healing Cloud (wand-only)
  if (skillId === "skill6") {
    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      hotbarToast("Equip a wand to use Healing Cloud");
      return false;
    }

    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
    if (typeof skill6CloudUntilMs === "number" && nowAbs < skill6CloudUntilMs) {
      return false;
    }

    if (typeof sendSkill6HealingCloud === "function") {
      // Start a client-side cast time for Healing Cloud; spell fires when cast completes.
      if (typeof performance !== "undefined") {
        const nowUi = performance.now();
        castingPoseDurationMs = SKILL6_CAST_TIME_MS;
        castingPoseUntilMs = nowUi + castingPoseDurationMs;
        skill6CastEndClientMs = castingPoseUntilMs;
        skill6CastArmed = true;

        // Immediately stop any existing movement when starting the cast.
        keys.up = keys.down = keys.left = keys.right = false;
        if (typeof sendInput === "function") {
          sendInput();
        }
      } else {
        // Fallback if performance is unavailable: cast immediately.
        sendSkill6HealingCloud();
      }
      return true;
    }
    hotbarToast("Skill6 not available (sendSkill6HealingCloud missing)");
    return false;
  }

  // Skill2: your spear double-stab
  if (skillId === "skill2") {
    if (typeof activateSkill2 === "function") { activateSkill2(); return true; }

    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
    if (typeof skill2ActiveUntilMs !== "undefined" && nowAbs < skill2ActiveUntilMs) {
      if (typeof triggerSkill2HotbarNack === "function") triggerSkill2HotbarNack();
      return false;
    }
    if (typeof skill2CdUntilMs !== "undefined" && nowAbs < skill2CdUntilMs) {
      if (typeof triggerSkill2HotbarNack === "function") triggerSkill2HotbarNack();
      return false;
    }

    if (typeof sendSkill2DoubleStabAtWorld === "function" && typeof lastAim !== "undefined" && lastAim?.has) {
      sendSkill2DoubleStabAtWorld(lastAim.wx, lastAim.wy, lastAim.mx, lastAim.my);
      return true;
    }
    if (typeof sendSkill2DoubleStab === "function") {
      sendSkill2DoubleStab();
      return true;
    }
    hotbarToast("Skill2 not available (sendSkill2DoubleStab missing)");
    return false;
  }

  // Skill3: Dash Slash (sword-only)
  if (skillId === "skill3") {
    if (typeof activateSkill3 === "function") { activateSkill3(); return true; }

    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
    if (typeof skill3CdUntilMs !== "undefined" && nowAbs < skill3CdUntilMs) {
      if (typeof triggerSkill3HotbarNack === "function") triggerSkill3HotbarNack();
      // Consume any pending double-tap override so it doesn't leak to a future cast.
      skill3DashOverrideDir = null;
      return false;
    }

    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "sword") {
      if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
        levelToastText = "Equip a sword to use Skill 3";
        levelToastUntilMs = performance.now() + 1500;
      } else {
        hotbarToast("Equip a sword to use Skill 3");
      }
      // Consume any pending double-tap override so it doesn't leak to a future cast.
      skill3DashOverrideDir = null;
      return false;
    }

    // If we have a dash direction override (from double-tap), use that instead of the mouse.
    const overrideDir = skill3DashOverrideDir;
    skill3DashOverrideDir = null;

    if (overrideDir && me) {
      let dx = 0, dy = 0;
      if (overrideDir === "left") dx = -1;
      else if (overrideDir === "right") dx = 1;
      else if (overrideDir === "up") dy = -1;
      else if (overrideDir === "down") dy = 1;

      const len = Math.hypot(dx, dy) || 1;
      const aimDirX = dx / len;
      const aimDirY = dy / len;

      const range = 220; // arbitrary visual target distance; server uses aimDirX/aimDirY
      const px = me.x ?? 0;
      const py = me.y ?? 0;
      const wx = px + aimDirX * range;
      const wy = py + aimDirY * range;

      // Update facing similar to sendSkill3DashSlashAtWorld
      if (typeof dirFromVector === "function" && typeof getAnim === "function" && typeof myId !== "undefined") {
        const d = dirFromVector(aimDirX, aimDirY);
        if (d != null) {
          const st = getAnim(myId, px, py);
          st.dir = d;
        }
      }

      if (typeof ws !== "undefined" && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: "skill3DashSlash", aimX: wx, aimY: wy, aimDirX, aimDirY }));
      }
      return true;
    }

    if (typeof sendSkill3DashSlashAtWorld === "function" && typeof lastAim !== "undefined" && lastAim?.has) {
      sendSkill3DashSlashAtWorld(lastAim.wx, lastAim.wy, lastAim.mx, lastAim.my);
      return true;
    }
    if (typeof sendSkill3DashSlash === "function") {
      sendSkill3DashSlash();
      return true;
    }
    hotbarToast("Skill3 not available (sendSkill3DashSlash missing)");
    return false;
  }

  // Skill4: Wide Slash (sword-only)
  if (skillId === "skill4") {
    const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
    if (typeof skill4CdUntilMs !== "undefined" && nowAbs < skill4CdUntilMs) {
      if (typeof triggerSkill4HotbarNack === "function") triggerSkill4HotbarNack();
      return false;
    }

    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "sword") {
      if (typeof levelToastText !== "undefined" && typeof levelToastUntilMs !== "undefined") {
        levelToastText = "Equip a sword to use Skill 4";
        levelToastUntilMs = performance.now() + 1500;
      } else {
        hotbarToast("Equip a sword to use Skill 4");
      }
      return false;
    }

    // Use the last aim position when available, otherwise swing straight ahead
    let wx = null, wy = null, mx = null, my = null;
    if (typeof lastAim !== "undefined" && lastAim && lastAim.has) {
      wx = lastAim.wx; wy = lastAim.wy; mx = lastAim.mx; my = lastAim.my;
    } else if (me) {
      const px = me.x ?? 0;
      const py = me.y ?? 0;
      const fx = me.facing?.x ?? 0;
      const fy = me.facing?.y ?? 1;
      const len = Math.hypot(fx, fy) || 1;
      const dirx = fx / len;
      const diry = fy / len;
      const range = 220;
      wx = px + dirx * range;
      wy = py + diry * range;
    }

    if (typeof sendSkill4WideSlashAtWorld === "function" && wx != null && wy != null) {
      sendSkill4WideSlashAtWorld(wx, wy, mx, my);
      return true;
    }
    if (typeof sendSkill4WideSlash === "function") {
      sendSkill4WideSlash();
      return true;
    }

    hotbarToast("Skill4 not available (sendSkill4WideSlash missing)");
    return false;
  }

  hotbarToast(`Unknown skill: ${skillId}`);
  return false;
}

function useHotbarSlot(n1) {
  // Prevent activating hotbar actions while casting Healing Cloud.
  if (skill6CastArmed && typeof performance !== "undefined") {
    const nowUi = performance.now();
    if (nowUi < skill6CastEndClientMs) {
      return;
    }
  }
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;

  const slot = hotbarSlots[idx];
  if (!slot) {
    hotbarToast(`Hotbar ${n1}: empty`);
    return;
  }

  if (slot.type === "skill") {
    const ok = activateSkillById(slot.id);
    if (ok) triggerHotbarFlashByIndex(idx);
    return;
  }

  if (slot.type === "item") {
    const si = resolveInventorySlotIndex(slot.itemId, slot.preferSlot);
    if (si < 0) {
      hotbarToast(`Hotbar ${n1}: item not found`);
      return;
    }
    if (typeof sendInvClick === "function") {
      sendInvClick(si);
      triggerHotbarFlashByIndex(idx);
    } else {
      hotbarToast("Item use not available (sendInvClick missing)");
    }
    return;
  }

  hotbarToast(`Hotbar ${n1}: invalid`);
}

function bindHotbarItem(n1, itemId, preferSlot) {
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarSlots[idx] = { type: "item", itemId, preferSlot };
  queueHotbarSync();
  hotbarToast(`Bound ${n1} → item`);
}

function bindHotbarSkill(n1, skillId) {
  const idx = n1 - 1;
  if (idx < 0 || idx >= HOTBAR_SIZE) return;
  hotbarSlots[idx] = { type: "skill", id: skillId };
  queueHotbarSync();
  hotbarToast(`Bound ${n1} → ${skillId}`);
}

function hotbarKeyForSkill(skillId) {
  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const s = hotbarSlots[i];
    if (s && s.type === "skill" && s.id === skillId) return String(i + 1);
  }
  return "";
}

// When binding from the Skills menu, we enter a "press 1–6" capture mode.
let pendingSkillBind = null; // { skillId }
let pendingItemBind = null; // { itemId, preferSlot }


// Draw a simple hotbar at the bottom (text-only labels for now)
function drawHotbar() {
  if (typeof ctx === "undefined" || typeof canvas === "undefined") return;

  const layout = getHotbarLayout();
  const box = layout.box, gap = layout.gap;
  const x0 = layout.x0;
  const y0 = layout.y0;
  const totalW = layout.totalW;

  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
    ? worldPlayers?.[myId]
    : null;
  const invSlots = me?.inventory?.slots || [];

  const nowUiMs = performance.now();
  const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();

  ctx.save();

  // slot visuals
  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const x = x0 + i * (box + gap);
    const y = y0;

    // background box
    ctx.fillStyle = "rgba(0,0,0,0.50)";
    ctx.fillRect(x, y, box, box);
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.strokeRect(x + 0.5, y + 0.5, box - 1, box - 1);

    const slot = hotbarSlots[i];
    const isDraggingThisHotbar = draggingHotbar && draggingHotbar.index === i;

    // Draw icon if assigned
    let drewIcon = false;

    if (slot && !isDraggingThisHotbar && slot.type === "skill") {
      const iconImg = hotbarSkillIcons?.[slot.id] || null;
      if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
        const ICON = 30;
        const ix = Math.round(x + (box - ICON) / 2);
        const iy = Math.round(y + (box - ICON) / 2);
        ctx.drawImage(iconImg, ix, iy, ICON, ICON);
        drewIcon = true;
      }
    } else if (slot && !isDraggingThisHotbar && slot.type === "item") {
      const si = resolveInventorySlotIndex(slot.itemId, slot.preferSlot);
      const it = (si >= 0) ? invSlots[si] : null;
      const qty = Number(it?.qty || 0);
      const outOfStock = (si < 0) || (qty <= 0);

      const itemId = it?.id || slot.itemId;
      const img = getItemIconImage(itemId);

      // icon (dim if out of stock)
      if (img && img.complete && img.naturalWidth > 0) {
        const ICON = 30;
        const ix = Math.round(x + (box - ICON) / 2);
        const iy = Math.round(y + (box - ICON) / 2);
        ctx.save();
        if (outOfStock) ctx.globalAlpha = 0.35;
        ctx.drawImage(img, ix, iy, ICON, ICON);
        ctx.restore();
        drewIcon = true;
      } else {
        // fallback label if icon missing
        ctx.save();
        ctx.fillStyle = outOfStock ? "rgba(255,255,255,0.35)" : "rgba(255,255,255,0.85)";
        ctx.font = "11px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Item", x + box / 2, y + box / 2);
        ctx.restore();
      }

      // stack count (consumables) — only when we actually have stock > 1
      if (!outOfStock && qty > 1) {
        ctx.save();
        const txt = `x${qty}`;
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + box - 4;
        const ty = y + box - 3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.80)";
        ctx.strokeText(txt, tx, ty);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(txt, tx, ty);
        ctx.restore();
      }

      // out-of-stock indicator (hotkeyed, but none in inventory)
      if (outOfStock) {
        ctx.save();
        // subtle dark veil
        ctx.fillStyle = "rgba(0,0,0,0.40)";
        ctx.fillRect(x + 2, y + 2, box - 4, box - 4);

        // "0" in corner
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + box - 4;
        const ty = y + box - 3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.85)";
        ctx.strokeText("0", tx, ty);
        ctx.fillStyle = "rgba(255,150,150,0.98)";
        ctx.fillText("0", tx, ty);
        ctx.restore();
      }
    }


    // Cooldown overlay (skills)
    if (slot && !isDraggingThisHotbar && slot.type === "skill") {
      let lockUntil = 0;
      let totalMs = 0;

      if (slot.id === "skill1") {
        // skill1 has an "active" window and a cooldown window; either blocks re-use
        if (typeof skill1ActiveUntilMs === "number" && nowAbs < skill1ActiveUntilMs) {
          lockUntil = Math.max(lockUntil, skill1ActiveUntilMs);
          totalMs = Math.max(totalMs, Number(skill1ActiveTotalMs || 0));
        }
        if (typeof skill1CdUntilMs === "number" && nowAbs < skill1CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill1CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill1CdTotalMs || 0));
        }
      } else if (slot.id === "skill2") {
        if (typeof skill2CdUntilMs === "number" && nowAbs < skill2CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill2CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill2CdTotalMs || 0));
        }
      } else if (slot.id === "skill3") {
        if (typeof skill3CdUntilMs === "number" && nowAbs < skill3CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill3CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill3CdTotalMs || 0));
        }
      } else if (slot.id === "skill4") {
        if (typeof skill4CdUntilMs === "number" && nowAbs < skill4CdUntilMs) {
          lockUntil = Math.max(lockUntil, skill4CdUntilMs);
          totalMs = Math.max(totalMs, Number(skill4CdTotalMs || 0));
        }
      } else if (slot.id === "skill6") {
        // Healing Cloud uses its active duration as a lockout while the cloud persists.
        if (typeof skill6CloudUntilMs === "number" && nowAbs < skill6CloudUntilMs) {
          lockUntil = Math.max(lockUntil, skill6CloudUntilMs);
          totalMs = Math.max(totalMs, Number(SKILL6_CLOUD_ACTIVE_MS || 0));
        }
      }

      const remainMs = Math.max(0, lockUntil - nowAbs);

      if (remainMs > 0) {
        const pct = (totalMs > 0) ? Math.max(0, Math.min(1, remainMs / totalMs)) : 1;

        // darken the whole slot a bit
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(x, y, box, box);

        // thicker fill from bottom indicating time remaining
        const h = Math.max(0, Math.min(box, Math.ceil(box * pct)));
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(x, y + (box - h), box, h);

        // remaining time text
        const sec = remainMs / 1000;
        const txt = (sec < 10) ? sec.toFixed(1) : String(Math.ceil(sec));
        ctx.save();
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.85)";
        ctx.strokeText(txt, x + box / 2, y + box / 2);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText(txt, x + box / 2, y + box / 2);
        ctx.restore();
      }
    }

    // Hotbar "used" flash feedback
    const flashRemain = (hotbarFlashUntilMs[i] || 0) - nowUiMs;
    if (flashRemain > 0) {
      const a = Math.max(0, Math.min(1, flashRemain / HOTBAR_FLASH_MS));
      ctx.fillStyle = `rgba(255,255,255,${(0.55 * a).toFixed(3)})`;
      ctx.fillRect(x, y, box, box);
    }

    // Key label (always)
    ctx.font = "11px system-ui, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText(String(i + 1), x + 4, y + 3);

    // If empty or no icon available, show a subtle placeholder
    if (!slot || !drewIcon) {
      ctx.font = "10px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = slot ? "rgba(255,255,255,0.55)" : "rgba(255,255,255,0.25)";

      let label = "";
      if (slot?.type === "skill") label = (slot.id || "Skill");
      else if (slot?.type === "item") label = "Item";

      if (label) {
        if (label.length > 8) label = label.slice(0, 8) + "…";
        ctx.fillText(label, x + box / 2, y + box / 2 + 9);
      } else {
        ctx.fillText("—", x + box / 2, y + box / 2 + 9);
      }
    }
  }

  ctx.restore();
}


let skillsTab = "wand";
    // (button controls main menu, not inventory)
 // I key toggles inventory UI

/* ======================
   DEBUG MAP EDITOR
   F1: toggle editor
   TAB: switch layer (ground/object)
   [ / ]: cycle tile id
   Left click: paint, Right click: erase
   Ctrl+E: export current map+objects to clipboard/console
====================== */
let editorOpen = false;
let editorLayer = "ground"; // "ground" | "object" | "height" | "zgate" | "mobs"
const EDITOR_LAYERS = ["ground","object","height","zgate","mobs"];
function editorNextLayer() {
  const i = Math.max(0, EDITOR_LAYERS.indexOf(editorLayer));
  editorLayer = EDITOR_LAYERS[(i + 1) % EDITOR_LAYERS.length];
}
function editorPrevLayer() {
  const i = Math.max(0, EDITOR_LAYERS.indexOf(editorLayer));
  editorLayer = EDITOR_LAYERS[(i - 1 + EDITOR_LAYERS.length) % EDITOR_LAYERS.length];
}

let editorShowGrid = true;
let editorShowColl = true;
let editorMouseX = 0, editorMouseY = 0; let editorMouseHas = false;

// Track the last known mouse position so keyboard skills (like 2) can aim like click-attacks.
let lastAim = { mx: 0, my: 0, wx: 0, wy: 0, has: false };

// Allowed tiles to keep you from accidentally breaking portals/statues.
// You can expand these later.
// Ground tiles that are selectable in the editor (auto-built from /assets/tiles.png)
let EDIT_GROUND_TILES = [0, 1];

function rebuildEditorGroundTiles() {
  // Build [0..N-1] from the tilesheet size, excluding the portal tile so we don't accidentally paint portals.
  const img = tileImage;
  const cell = TILE_SIZE + TILE_PAD;

  if (!img || !img.complete || img.naturalWidth <= 0 || img.naturalHeight <= 0) return;

  const cols = TILESET_COLS;
  const rows = Math.max(1, Math.floor(img.naturalHeight / cell));
  const total = rows * cols;

  const list = [];
  for (let i = 0; i < total; i++) {
    list.push(i);
  }
  if (list.length) EDIT_GROUND_TILES = list;
  // Add special editor-only ground tiles (not in tiles.png)
  if (!EDIT_GROUND_TILES.includes(AUTO_DIRTPATH_TILE)) EDIT_GROUND_TILES.push(AUTO_DIRTPATH_TILE);

  if (!EDIT_GROUND_TILES.includes(AUTO_WATER_TILE)) EDIT_GROUND_TILES.push(AUTO_WATER_TILE);
}
          // grass, wall (keep portals/statues unchanged for now)
let EDIT_OBJECT_TILES = [0, 1, 2, 6];    // will expand automatically based on tiles_objects.png
function rebuildEditorObjectTiles() {
  // Allow painting any tile that exists in tiles_objects.png (0 = empty)
  if (!objTileImage.complete || objTileImage.naturalHeight <= 0) return;
  const cell = TILE_SIZE + TILE_PAD;
  const rows = Math.floor((objTileImage.naturalHeight + TILE_PAD) / cell);
  const maxId = Math.max(0, rows * TILESET_COLS);
  const list = [0];
  for (let i = 1; i <= maxId; i++) list.push(i);
  EDIT_OBJECT_TILES = list;
  editorTileIndex = clamp(editorTileIndex, 0, EDIT_OBJECT_TILES.length - 1);
}


// Mob types selectable in the editor (spawn points, not live mobs).
// We try mobCatalog first (server-provided), then fall back to loaded sprite keys.
let EDIT_MOB_TYPES = ["green"]; // default fallback
function rebuildEditorMobTypes() {
  let keys = [];
  try { if (typeof mobCatalog === "object" && mobCatalog) keys = Object.keys(mobCatalog); } catch (_) {}
  if (!keys || !keys.length) {
    try { if (typeof mobSprites === "object" && mobSprites) keys = Object.keys(mobSprites); } catch (_) {}
  }
  keys = (keys || []).filter(k => k && k !== "__proto__").sort();
  if (keys.length) EDIT_MOB_TYPES = keys;
  editorTileIndex = clamp(editorTileIndex, 0, Math.max(0, EDIT_MOB_TYPES.length - 1));
}

let editorTileIndex = 0; // index into allowed list for current layer

// Editor-only mob spawn points (purely authoring data). Stored per mapId and exported with Ctrl+E.
// Format: { type, x, y, count, respawnSec, leash }
const editorMobSpawnsByMapId = new Map();
// Tracks whether the user has interacted with the mobs layer for a given map in this session.
// If they intentionally clear all spawns, we should NOT reseed from base map data.
const editorMobSpawnsTouched = new Set();

function getEditorMobSpawnsFor(mapId) {
  const key = String(mapId ?? "");
  if (!editorMobSpawnsByMapId.has(key)) editorMobSpawnsByMapId.set(key, []);
  return editorMobSpawnsByMapId.get(key);
}

// Seed editor mob spawns for a map from authored map data (mobSpawns) if the editor
// hasn't been used on that map yet. This prevents exporting an empty mobSpawns array
// when you didn't touch the mobs layer.
function seedEditorMobSpawns(mapId, mobSpawns) {
  const key = String(mapId ?? "");
  if (editorMobSpawnsTouched.has(key)) return;
  const list = getEditorMobSpawnsFor(key);
  if (!Array.isArray(list) || list.length > 0) return; // don't overwrite edits
  const base = Array.isArray(mobSpawns) ? mobSpawns : [];
  for (const s of base) {
    if (!s) continue;
    const mobType = String(s.mobType ?? s.type ?? s.mob ?? s.kind ?? "unknown");
    const tx = Number.isFinite(s.tx) ? s.tx : (Number.isFinite(s.x) ? s.x : null);
    const ty = Number.isFinite(s.ty) ? s.ty : (Number.isFinite(s.y) ? s.y : null);
    if (!Number.isFinite(tx) || !Number.isFinite(ty)) continue;
    // Editor list format prefers x/y for hit-testing and painting.
    list.push({
      type: mobType,
      x: tx, y: ty, tx, ty,
      ...(s.id ? { id: s.id } : {}),
      ...(s.mapId ? { mapId: s.mapId } : {}),
      ...(s.count != null ? { count: s.count } : {}),
      ...(s.respawnSec != null ? { respawnSec: s.respawnSec } : {}),
      ...(s.leash != null ? { leash: s.leash } : {}),
      ...(s.speedMul != null ? { speedMul: s.speedMul } : {}),
      ...(s.aggroSpeedMul != null ? { aggroSpeedMul: s.aggroSpeedMul } : {}),
      ...(s.passiveUntilHit != null ? { passiveUntilHit: s.passiveUntilHit } : {}),
      ...(s.maxHp != null ? { maxHp: s.maxHp } : {}),
      ...(s.aggroRadius != null ? { aggroRadius: s.aggroRadius } : {}),
    });
  }
}

function findMobSpawnIndexAt(list, x, y) {
  for (let i = 0; i < list.length; i++) {
    const s = list[i];
    if (!s) continue;
    if ((s.x|0) === (x|0) && (s.y|0) === (y|0)) return i;
  }
  return -1;
}


// Currently selected mob spawn in the editor (for the Mob Spawn panel).
let editorSelectedMobSpawn = null; // { mapId, x, y }

// Read current map id consistently in editor code.
function editorGetCurrentMapId() {
  return (typeof currentMapId !== "undefined") ? currentMapId
       : (typeof currentMap !== "undefined" && currentMap?.id != null) ? currentMap.id
       : 1;
}

function editorGetSelectedSpawnIndex() {
  if (!editorSelectedMobSpawn) return -1;
  const id = String(editorSelectedMobSpawn.mapId ?? "");
  const list = getEditorMobSpawnsFor(id);
  return findMobSpawnIndexAt(list, editorSelectedMobSpawn.x, editorSelectedMobSpawn.y);
}

function editorGetSelectedSpawn() {
  if (!editorSelectedMobSpawn) return null;
  const id = String(editorSelectedMobSpawn.mapId ?? "");
  const list = getEditorMobSpawnsFor(id);
  const idx = editorGetSelectedSpawnIndex();
  if (idx < 0) return null;
  return { list, idx, sp: list[idx] };
}

function setEditorMobPropsVisible(vis) {
  const box = document.getElementById("editorMobProps");
  if (!box) return;
  box.classList.toggle("hidden", !vis);
}

function editorDefaultSpawnForType(mobType, tx, ty) {
  // Keep these modest; server should clamp/validate when it consumes mobSpawns.
  const cat = (typeof mobCatalog === "object" && mobCatalog) ? mobCatalog[mobType] : null;
  const defAggroRadius = 6;
  return {
    type: String(mobType || "unknown"),
    x: tx, y: ty,
    count: 1,
    respawnSec: 30,
    leash: 8,
    aggroRadius: defAggroRadius,
    passiveUntilHit: false,
    speedMul: 1,
    aggroSpeedMul: 1,
    // Leave maxHp undefined by default; if set, it overrides cat.maxHp.
    ...(cat && typeof cat.maxHp === "number" ? {} : {}),
  };
}

function editorClampNum(v, minV, maxV, fallback) {
  const n = Number(v);
  if (!Number.isFinite(n)) return fallback;
  if (minV != null && n < minV) return minV;
  if (maxV != null && n > maxV) return maxV;
  return n;
}

function editorUpdateMobPropsPanel() {
  // Only relevant when editor is open and the mobs layer is active.
  if (!editorOpen || editorLayer !== "mobs") { setEditorMobPropsVisible(false); return; }

  setEditorMobPropsVisible(true);

  const hint = document.getElementById("editorMobPropsHint");
  const grid = document.getElementById("editorMobPropsGrid");

  const sel = editorGetSelectedSpawn();
  const typeEl = document.getElementById("mobPropType");
  const posEl  = document.getElementById("mobPropPos");
  const inCount = document.getElementById("mobPropCount");
  const inResp  = document.getElementById("mobPropRespawn");
  const inLeash = document.getElementById("mobPropLeash");
  const inAggroRad = document.getElementById("mobPropAggroRadius");
  const inPassive = document.getElementById("mobPropPassive");
  const inSpeed = document.getElementById("mobPropSpeed");
  const inAggroSpeed = document.getElementById("mobPropAggroSpeed");
  const inMaxHp = document.getElementById("mobPropMaxHp");

  if (!sel || !sel.sp) {
    if (hint) hint.textContent = "Click a mob spawn on the map to edit its attributes.";
    if (grid) grid.style.opacity = "0.45";
    if (typeEl) typeEl.textContent = "—";
    if (posEl) posEl.textContent = "—";
    if (inMaxHp) inMaxHp.value = "";
    return;
  }

  const sp = sel.sp;
  if (hint) hint.textContent = "Editing the selected mob spawn. (Shift+click an existing spawn to select without changing its type.)";
  if (grid) grid.style.opacity = "1";

  const mobType = String(sp.type || sp.mobType || "unknown");
  const name = mobCatalog?.[mobType]?.name || mobType;

  if (typeEl) typeEl.textContent = name;
  if (posEl) posEl.textContent = `(${sp.x|0}, ${sp.y|0})`;

  if (inCount) inCount.value = String((sp.count|0) || 1);
  if (inResp) inResp.value = String(Number.isFinite(sp.respawnSec) ? sp.respawnSec : 30);
  if (inLeash) inLeash.value = String(Number.isFinite(sp.leash) ? sp.leash : 8);
  if (inAggroRad) inAggroRad.value = String(Number.isFinite(sp.aggroRadius) ? sp.aggroRadius : 6);

  if (inPassive) inPassive.checked = !!sp.passiveUntilHit;
  if (inSpeed) inSpeed.value = String(Number.isFinite(sp.speedMul) ? sp.speedMul : 1);
  if (inAggroSpeed) inAggroSpeed.value = String(Number.isFinite(sp.aggroSpeedMul) ? sp.aggroSpeedMul : 1);
  if (inMaxHp) inMaxHp.value = (sp.maxHp != null && Number.isFinite(Number(sp.maxHp))) ? String(sp.maxHp) : "";
}

function editorApplyMobPropsFromInputs() {
  const sel = editorGetSelectedSpawn();
  if (!sel || !sel.sp) return;
  const sp = sel.sp;

  const inCount = document.getElementById("mobPropCount");
  const inResp  = document.getElementById("mobPropRespawn");
  const inLeash = document.getElementById("mobPropLeash");
  const inAggroRad = document.getElementById("mobPropAggroRadius");
  const inPassive = document.getElementById("mobPropPassive");
  const inSpeed = document.getElementById("mobPropSpeed");
  const inAggroSpeed = document.getElementById("mobPropAggroSpeed");
  const inMaxHp = document.getElementById("mobPropMaxHp");

  sp.count = editorClampNum(inCount?.value, 1, 999, 1) | 0;
  sp.respawnSec = editorClampNum(inResp?.value, 0, 3600, 30) | 0;
  sp.leash = editorClampNum(inLeash?.value, 0, 999, 8) | 0;
  sp.aggroRadius = editorClampNum(inAggroRad?.value, 0, 999, 6) | 0;

  sp.passiveUntilHit = !!(inPassive && inPassive.checked);
  sp.speedMul = editorClampNum(inSpeed?.value, 0.1, 10, 1);
  sp.aggroSpeedMul = editorClampNum(inAggroSpeed?.value, 0.1, 10, 1);

  const mh = inMaxHp ? Number(inMaxHp.value) : NaN;
  if (Number.isFinite(mh) && mh > 0) sp.maxHp = Math.floor(mh);
  else delete sp.maxHp;

  // Mark as touched so export uses the edited list.
  editorMobSpawnsTouched.add(String(editorGetCurrentMapId()));
}


function editorAllowedList() {
  if (editorLayer === "ground") return EDIT_GROUND_TILES;
  if (editorLayer === "object") return EDIT_OBJECT_TILES;
  if (editorLayer === "height") return [0,1,2,3];
  if (editorLayer === "zgate") return [0,1];
  if (editorLayer === "mobs") return EDIT_MOB_TYPES;
  return EDIT_GROUND_TILES;
}
function editorSelectedTile() {
  const list = editorAllowedList();
  return list[clamp(editorTileIndex, 0, list.length - 1)];
}
function editorSetTileIndexByValue(v) {
  const list = editorAllowedList();
  const idx = list.indexOf(v);
  if (idx !== -1) editorTileIndex = idx;
}

// ======================
// Editor DOM Panel (off-canvas UI)
// ======================
let editorDomReady = false;

function setEditorPanelVisible(v){
  const p = document.getElementById("editorPanel");
  if (!p) return;
  p.classList.toggle("hidden", !v);
}

function editorUpdateDomHeader(){
  const layerBtn = document.getElementById("editorLayerBtn");
  const gridBtn  = document.getElementById("editorGridBtn");
  const collBtn  = document.getElementById("editorCollBtn");
  if (layerBtn) layerBtn.textContent = `Layer: ${editorLayer.toUpperCase()}`;
  if (gridBtn)  gridBtn.textContent  = `Grid: ${editorShowGrid ? "ON" : "OFF"}`;
  if (collBtn)  collBtn.textContent  = `Coll: ${editorShowColl ? "ON" : "OFF"}`;

  // Toggle the Mob Spawn attribute panel based on active layer.
  const mobBox = document.getElementById("editorMobProps");
  if (mobBox) {
    if (editorLayer === "mobs") mobBox.classList.remove("hidden");
    else mobBox.classList.add("hidden");
  }
}

function editorUpdateDomStatus(){
  const el = document.getElementById("editorStatus");
  if (!el) return;
  if (!editorOpen || !map || !editorMouseHas) { el.textContent = "Cursor: —"; return; }
  const id = (typeof currentMapId !== "undefined") ? currentMapId
           : (typeof currentMap !== "undefined" && currentMap?.id != null) ? currentMap.id
           : 1;
  const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
  const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
  if (ty < 0 || tx < 0 || ty >= map.length || tx >= map[0].length) { el.textContent = "Cursor: —"; return; }
  const g = map[ty][tx] | 0;
  const o = (objMap && objMap[ty] ? (objMap[ty][tx] | 0) : 0);
  const z = (zMap && zMap[ty] ? (zMap[ty][tx] | 0) : 0);
  const zg = (zGateMap && zGateMap[ty] ? (zGateMap[ty][tx] ? 1 : 0) : 0);
  const mobs = getEditorMobSpawnsFor(id);
  const mi = findMobSpawnIndexAt(mobs, tx, ty);
  const mtxt = (mi !== -1) ? (()=>{ const sp=mobs[mi]; const nm = mobCatalog?.[sp.type]?.name || sp.type; const ct = (sp.count|0)||1; return `${nm} x${ct}`; })() : "—";
  el.textContent = `Cursor: (${tx},${ty}) • Ground:${g} • Obj:${o} • Z:${z} • Gate:${zg} • Mob:${mtxt}`;
}

function editorTileThumbCanvas(tile, layer){
  const c = document.createElement("canvas");
  c.width = 48; c.height = 48;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;

  // Height/zGate layers use synthetic thumbnails
  if (layer === "height") {
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(0,0,48,48);
    g.fillStyle = "rgba(255,255,255,0.85)";
    g.font = "20px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText(String(tile), 24, 24);
    return c;
  }
  if (layer === "zgate") {
    g.fillStyle = tile ? "rgba(80,200,120,0.25)" : "rgba(255,255,255,0.08)";
    g.fillRect(0,0,48,48);
    g.strokeStyle = "rgba(255,255,255,0.35)";
    g.strokeRect(6,6,36,36);
    g.fillStyle = "rgba(255,255,255,0.85)";
    g.font = "14px system-ui";
    g.textAlign = "center";
    g.textBaseline = "middle";
    g.fillText(tile ? "ON" : "OFF", 24, 24);
    return c;
  }

  if (layer === "mobs") {
    const mobType = String(tile || "");
    g.fillStyle = "rgba(120,80,255,0.18)";
    g.fillRect(0,0,48,48);
    g.strokeStyle = "rgba(255,255,255,0.20)";
    g.strokeRect(0.5,0.5,47,47);

    const imgM = (typeof mobSprites !== "undefined" && mobSprites) ? (mobSprites[mobType] || null) : null;
    if (imgM && imgM.complete && imgM.naturalWidth > 0) {
      const fs = getMobFrameSize(imgM);
      const fw = fs?.w || 48;
      const fh = fs?.h || 48;
      g.imageSmoothingEnabled = false;
      g.drawImage(imgM, 0, 0, fw, fh, 4, 4, 40, 40);
    } else {
      g.fillStyle = "rgba(255,255,255,0.85)";
      g.font = "11px system-ui";
      g.textAlign = "center";
      g.textBaseline = "middle";
      g.fillText(mobType ? mobType.slice(0, 8) : "mob", 24, 24);
    }
    return c;
  }

  const img = (layer === "object") ? objTileImage : tileImage;
  if (!img || !img.complete || img.naturalWidth <= 0) return c;

  // 0 is empty for objects
  if (layer === "object" && tile === 0) {
    g.fillStyle = "rgba(255,255,255,0.08)";
    g.fillRect(0,0,48,48);
    g.fillStyle = "rgba(255,255,255,0.35)";
    g.fillRect(6,23,36,2);
    return c;
  }

  
  // Special case: ground autotile thumbnail
  if (layer === "ground" && tile === AUTO_DIRTPATH_TILE) {
    const img2 = autotileDirtImg;
    if (img2 && img2.complete && img2.naturalWidth > 0) {
      const cell2 = TILE_SIZE + TILE_PAD;
      const mask = 15; // show the "connected on all sides" variant in the palette
      const col2 = mask % AUTO_DIRTPATH_COLS;
      const row2 = Math.floor(mask / AUTO_DIRTPATH_COLS);
      const sx2 = col2 * cell2;
      const sy2 = row2 * cell2;
      g.drawImage(img2, sx2, sy2, TILE_SIZE, TILE_SIZE, 0, 0, 48, 48);
      return c;
    }
    // fallback if not loaded yet
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(0,0,48,48);
    g.fillStyle = "rgba(255,255,255,0.55)";
    g.font = "11px system-ui";
    g.fillText("AUTO", 10, 28);
    return c;
  }

  // Special case: animated water brush thumbnail (show frame 0)
  if (layer === "ground" && tile === AUTO_WATER_TILE) {
    const imgW = autotileWaterImg;
    if (imgW && imgW.complete && imgW.naturalWidth > 0) {
      const cellW = TILE_SIZE + TILE_PAD; // water atlas uses same padding convention
      const sxW = 0;
      const syW = 0;
      g.drawImage(imgW, sxW, syW, TILE_SIZE, TILE_SIZE, 0, 0, 48, 48);
      return c;
    }
    // fallback if not loaded yet
    g.fillStyle = "rgba(255,255,255,0.10)";
    g.fillRect(0,0,48,48);
    g.fillStyle = "rgba(255,255,255,0.55)";
    g.font = "11px system-ui";
    g.fillText("WATER", 6, 28);
    return c;
  }


// Object layer IDs are 1-based in the map data (0 = empty), but atlas coords are 0-based.
  const tileIndex = (layer === "object") ? (tile - 1) : tile;

  const col = tileIndex % TILESET_COLS;
  const row = Math.floor(tileIndex / TILESET_COLS);
  const sx = col * (TILE_SIZE + TILE_PAD);
  const sy = row * (TILE_SIZE + TILE_PAD);

  g.drawImage(img, sx, sy, TILE_SIZE, TILE_SIZE, 0, 0, 48, 48);
  return c;
}

function editorBuildTileGrid(){
  const grid = document.getElementById("editorTileGrid");
  if (!grid) return;

  const q = (document.getElementById("editorSearch")?.value || "").trim();
  const list = editorAllowedList().slice();

  let filtered = list;
  // quick filter: numeric substring match
  if (q) {
    if (/^\d+$/.test(q)) {
      filtered = list.filter(t => String(t).includes(q));
    }
  }

  grid.innerHTML = "";
  const sel = editorSelectedTile();

  for (const tile of filtered) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "tile-btn" + (tile === sel ? " selected" : "");
    btn.title = (editorLayer === "mobs") ? `Mob ${tile}` : `Tile ${tile}`;
    btn.appendChild(editorTileThumbCanvas(tile, editorLayer));
    btn.addEventListener("click", () => {
      editorSetTileIndexByValue(tile);
      editorBuildTileGrid();
    editorUpdateMobPropsPanel();
      editorUpdateDomHeader();
      const meta = document.getElementById("editorMeta");
      if (meta) meta.textContent = (editorLayer === "mobs") ? `Selected mob:  • Left click places/selects, Shift+click overwrites, Right click removes` : `Selected: ${editorLayer} tile ${tile} • Left click paints, Right click erases`;
    });
    grid.appendChild(btn);
  }
}

function editorInitDomPanelOnce(){
  if (editorDomReady) return;
  editorDomReady = true;

  const layerBtn = document.getElementById("editorLayerBtn");
  const gridBtn  = document.getElementById("editorGridBtn");
  const collBtn  = document.getElementById("editorCollBtn");
  const expBtn   = document.getElementById("editorExportBtn");
  const search   = document.getElementById("editorSearch");

  layerBtn?.addEventListener("click", () => {
    editorNextLayer();
    if (editorLayer === "mobs") rebuildEditorMobTypes();
    editorTileIndex = 0;
    const list = editorAllowedList();
    if (list.length) editorSetTileIndexByValue(list[0]);
    editorUpdateDomHeader();
    editorBuildTileGrid();
    editorUpdateMobPropsPanel();
  });

  gridBtn?.addEventListener("click", () => {
    editorShowGrid = !editorShowGrid;
    
      editorUpdateDomHeader();
editorUpdateDomHeader();
  });

  collBtn?.addEventListener("click", () => {
    editorShowColl = !editorShowColl;
    
      editorUpdateDomHeader();
editorUpdateDomHeader();
  });

  expBtn?.addEventListener("click", () => {
    exportCurrentMapToClipboard();
  });

  search?.addEventListener("input", () => editorBuildTileGrid());

  // Mob properties panel (only active on Layer: MOBS)
  const mobPropsBox = document.getElementById("editorMobProps");
  const applyDefaultsBtn = document.getElementById("mobPropApplyDefaults");
  const delBtn = document.getElementById("mobPropDelete");

  function wireMobInput(id) {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener("input", () => {
      editorApplyMobPropsFromInputs();
      editorUpdateMobPropsPanel();
    });
    el.addEventListener("change", () => {
      editorApplyMobPropsFromInputs();
      editorUpdateMobPropsPanel();
    });
  }

  wireMobInput("mobPropCount");
  wireMobInput("mobPropRespawn");
  wireMobInput("mobPropLeash");
  wireMobInput("mobPropAggroRadius");
  wireMobInput("mobPropPassive");
  wireMobInput("mobPropSpeed");
  wireMobInput("mobPropAggroSpeed");
  wireMobInput("mobPropMaxHp");

  applyDefaultsBtn?.addEventListener("click", () => {
    const sel = editorGetSelectedSpawn();
    if (!sel || !sel.sp) return;
    const mobType = String(sel.sp.type || sel.sp.mobType || "");
    const def = editorDefaultSpawnForType(mobType, sel.sp.x|0, sel.sp.y|0);
    // Keep position/type; reset tunables
    for (const k of ["count","respawnSec","leash","aggroRadius","passiveUntilHit","speedMul","aggroSpeedMul"]) {
      sel.sp[k] = def[k];
    }
    delete sel.sp.maxHp;
    editorMobSpawnsTouched.add(String(editorGetCurrentMapId()));
    editorUpdateMobPropsPanel();
  });

  delBtn?.addEventListener("click", () => {
    const sel = editorGetSelectedSpawn();
    if (!sel) return;
    sel.list.splice(sel.idx, 1);
    editorSelectedMobSpawn = null;
    editorMobSpawnsTouched.add(String(editorGetCurrentMapId()));
    editorUpdateMobPropsPanel();
  });

  // Initial visibility sync
  if (mobPropsBox) editorUpdateMobPropsPanel();

}

// Re-use your existing Ctrl+E export logic by dispatching a synthetic hotkey.
function exportCurrentMapToClipboardHotkey(){
  const evt = new KeyboardEvent("keydown", { key: "e", ctrlKey: true, bubbles: true });
  window.dispatchEvent(evt);
}


// send tile edit to server (server will validate)
function sendEditTile(layer, tx, ty, tile) {
  wsSend({ type: "editTile", layer, x: tx, y: ty, tile });
}

function fallbackCopyTextToClipboard(txt) {
  try {
    const ta = document.createElement("textarea");
    ta.value = txt;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    const ok = document.execCommand && document.execCommand("copy");
    document.body.removeChild(ta);
    return !!ok;
  } catch (e) {
    return false;
  }
}

function showExportOverlay(txt) {
  let overlay = document.getElementById("mapExportOverlay");
  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "mapExportOverlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.right = "0";
    overlay.style.bottom = "0";
    overlay.style.background = "rgba(0,0,0,0.55)";
    overlay.style.zIndex = "999999";
    overlay.style.display = "none";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.padding = "18px";

    const panel = document.createElement("div");
    panel.style.width = "min(980px, 92vw)";
    panel.style.maxHeight = "86vh";
    panel.style.background = "rgba(20,20,24,0.98)";
    panel.style.border = "1px solid rgba(255,255,255,0.12)";
    panel.style.borderRadius = "12px";
    panel.style.boxShadow = "0 12px 40px rgba(0,0,0,0.45)";
    panel.style.padding = "14px";
    panel.style.display = "flex";
    panel.style.flexDirection = "column";
    panel.style.gap = "10px";
    panel.style.color = "#fff";
    panel.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";

    const title = document.createElement("div");
    title.textContent = "Map Export";
    title.style.fontSize = "18px";
    title.style.fontWeight = "700";

    const tip = document.createElement("div");
    tip.textContent = "Clipboard is blocked in this context. The export is shown below — click inside, then press Ctrl+C to copy.";
    tip.style.fontSize = "13px";
    tip.style.opacity = "0.85";

    const ta = document.createElement("textarea");
    ta.id = "mapExportText";
    ta.spellcheck = false;
    ta.wrap = "off";
    ta.style.width = "100%";
    ta.style.height = "60vh";
    ta.style.resize = "vertical";
    ta.style.background = "rgba(0,0,0,0.35)";
    ta.style.color = "#fff";
    ta.style.border = "1px solid rgba(255,255,255,0.18)";
    ta.style.borderRadius = "10px";
    ta.style.padding = "10px";
    ta.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ta.style.fontSize = "12px";
    ta.style.lineHeight = "1.35";

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "10px";
    row.style.justifyContent = "flex-end";

    const btnCopy = document.createElement("button");
    btnCopy.textContent = "Try Copy Again";
    btnCopy.style.padding = "8px 12px";
    btnCopy.style.borderRadius = "10px";
    btnCopy.style.border = "1px solid rgba(255,255,255,0.22)";
    btnCopy.style.background = "rgba(255,255,255,0.08)";
    btnCopy.style.color = "#fff";
    btnCopy.style.cursor = "pointer";

    const btnClose = document.createElement("button");
    btnClose.textContent = "Close";
    btnClose.style.padding = "8px 12px";
    btnClose.style.borderRadius = "10px";
    btnClose.style.border = "1px solid rgba(255,255,255,0.22)";
    btnClose.style.background = "rgba(255,255,255,0.08)";
    btnClose.style.color = "#fff";
    btnClose.style.cursor = "pointer";

    btnClose.onclick = () => { overlay.style.display = "none"; };
    overlay.onclick = (e) => { if (e.target === overlay) overlay.style.display = "none"; };

    btnCopy.onclick = async () => {
      const t = document.getElementById("mapExportText")?.value ?? "";
      let ok = false;
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(t);
          ok = true;
        }
      } catch {}
      if (!ok) ok = fallbackCopyTextToClipboard(t);
      levelToastText = ok ? "Export copied to clipboard" : "Copy still blocked — use Ctrl+C";
      levelToastUntilMs = performance.now() + 2500;
      if (ok) overlay.style.display = "none";
    };

    row.appendChild(btnCopy);
    row.appendChild(btnClose);

    panel.appendChild(title);
    panel.appendChild(tip);
    panel.appendChild(ta);
    panel.appendChild(row);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
  }

  const ta = document.getElementById("mapExportText");
  if (ta) ta.value = txt;

  overlay.style.display = "flex";
  setTimeout(() => {
    const t = document.getElementById("mapExportText");
    if (t) {
      t.focus();
      t.select();
    }
  }, 0);
}

async function exportCurrentMapToClipboard() {
  if (!map) return;

  // Use whatever your client already tracks as the "current map id"
  // If yours is named differently, swap this line only.
  const id = (typeof currentMapId !== "undefined") ? currentMapId
           : (typeof currentMap !== "undefined" && currentMap?.id != null) ? currentMap.id
           : 1;

  // If your maps are numeric (1/2/3/4), this makes makeMapA/B/C/D automatically.
  // If your ids are strings (like "mapA"), see note below.
  const letter = (typeof id === "number" && id >= 1 && id <= 26)
    ? String.fromCharCode(64 + id)
    : String(id);

  const fnName = `makeMap${letter}`;

  const w = map?.[0]?.length || 0;
  const h = map?.length || 0;

  const ground = map;
  const objects = objMap || Array.from({ length: h }, () => Array(w).fill(0));
  const z = zMap || Array.from({ length: h }, () => Array(w).fill(0));
  const zGate = zGateMap || Array.from({ length: h }, () => Array(w).fill(0));

  // Editor-only mob spawns (purely authoring data)
// Primary source: editorMobSpawnsByMapId (what you paint in the editor)
// Fallback source: currentMap.mobSpawns (so legacy map data still exports even if you never "touched" mobs in-editor)
  const mobs = (() => {
    const mapKey = String(id);

    // Base authored mob spawns from the map data (legacy)
    const baseList = (typeof currentMap !== "undefined" && currentMap && Array.isArray(currentMap.mobSpawns))
      ? currentMap.mobSpawns
      : [];

    // If this map has been edited in the Mobs layer (add/delete/edit), export EXACTLY what the editor has (even if empty).
    // Otherwise, export the legacy authored list unchanged.
    const editorList = getEditorMobSpawnsFor(mapKey) || [];
    const touched = editorMobSpawnsTouched.has(mapKey);

    if (touched) return editorList;

    // If legacy has nothing and somehow we have editor entries without being marked touched, fall back to editor entries.
    return (baseList && baseList.length) ? baseList : editorList;
})();;

  const mobSpawns = mobs.map((s, i) => {
    const mobType = (s && (s.mobType ?? s.type)) ?? "unknown";
    const tx = (s && (Number.isFinite(s.tx) ? s.tx : (Number.isFinite(s.x) ? s.x : undefined)));
    const ty = (s && (Number.isFinite(s.ty) ? s.ty : (Number.isFinite(s.y) ? s.y : undefined)));
    const out = {
      // id is optional; server will auto-generate if missing
      ...(s && s.id ? { id: s.id } : {}),
      ...(s && s.mapId ? { mapId: s.mapId } : {}),
      mobType,
      ...(Number.isFinite(tx) ? { tx } : {}),
      ...(Number.isFinite(ty) ? { ty } : {}),
    };
    // Preserve any optional tuning knobs if present on the editor object
    if (s && s.speedMul != null) out.speedMul = s.speedMul;
    if (s && s.aggroSpeedMul != null) out.aggroSpeedMul = s.aggroSpeedMul;
    if (s && s.passiveUntilHit != null) out.passiveUntilHit = s.passiveUntilHit;
          if (s.count != null) out.count = s.count;
          if (s.respawnSec != null) out.respawnSec = s.respawnSec;
          if (s.leash != null) out.leash = s.leash;
          if (s.maxHp != null) out.maxHp = s.maxHp;
          if (s.aggroRadius != null) out.aggroRadius = s.aggroRadius;
    return out;
  });


  // If your client has portals synced, include them; otherwise export empty list
  const portalList = (typeof portals !== "undefined" && Array.isArray(portals)) ? portals : [];

  // Export NPC placements if available. Prefer worldNpcs snapshot (it often includes sprite/name),
  // otherwise fall back to rendered entities list.
  function snapCenteredTile(v) {
    // If v looks like N+0.5 (tile-center), convert to N. Keep real fractional tiles intact.
    const frac = v - Math.floor(v);
    if (Math.abs(frac - 0.5) < 1e-6) return v - 0.5;
    return v;
  }

  const npcList = (() => {
    // 1) If the game has a worldNpcs snapshot, export from it.
    if (typeof worldNpcs !== "undefined" && worldNpcs && typeof worldNpcs === "object") {
      const out = [];
      for (const [id, n] of Object.entries(worldNpcs)) {
        if (!n) continue;
        // Prefer tx/ty if present; otherwise derive from x/y pixel coords.
        const tx = Number.isFinite(n.tx) ? n.tx : (Number.isFinite(n.x) ? snapCenteredTile(n.x / TILE_SIZE) : 0);
    const ty = Number.isFinite(n.ty) ? n.ty : (Number.isFinite(n.y) ? snapCenteredTile(n.y / TILE_SIZE) : 0);
        out.push({
          id: String(n.id ?? id),
          name: String(n.name ?? n.npcName ?? "NPC"),
          tx: Math.round(tx * 100) / 100,
          ty: Math.round(ty * 100) / 100,
          sprite: String(n.sprite ?? n.npcSprite ?? n.spritePath ?? ""),
        });
      }
      return out;
    }

    // 2) Fallback: derive from render entities (may only have id + position).
    const ents = (typeof entities !== "undefined" && Array.isArray(entities)) ? entities : [];
    const out = [];
    for (const e of ents) {
      if (!e || e.kind !== "npc") continue;
      const tx = Number.isFinite(e.tx) ? e.tx : (Number.isFinite(e.x) ? snapCenteredTile(e.x / TILE_SIZE) : 0);
      const ty = Number.isFinite(e.ty) ? e.ty : (Number.isFinite(e.y) ? snapCenteredTile(e.y / TILE_SIZE) : 0);
      out.push({
        id: String(e.id ?? "npc"),
        name: String(e.name ?? "NPC"),
        tx: Math.round(tx * 100) / 100,
        ty: Math.round(ty * 100) / 100,
        sprite: String(e.sprite ?? ""),
      });
    }
    return out;
  })();

  const payload =
`// Paste into maps_data.js
export function ${fnName}() {
  const w = ${w};
  const h = ${h};

  const map = ${JSON.stringify(ground)};
  const obj = ${JSON.stringify(objects)};
  const z = ${JSON.stringify(z)};
  const zGate = ${JSON.stringify(zGate)};

  const portals = ${JSON.stringify(portalList, null, 2)};
  const npcs = ${JSON.stringify(npcList, null, 2)};
  const mobSpawns = ${JSON.stringify(mobSpawns, null, 2)};

  return { id: ${JSON.stringify(id)}, w, h, map, obj, z, zGate, portals, npcs, mobSpawns };
}
`;

  console.log(payload);

  let copied = false;
try {
  // Modern API (works on https / localhost with permission)
  if (navigator.clipboard && (window.isSecureContext || location.hostname === "localhost")) {
    await navigator.clipboard.writeText(payload);
    copied = true;
  }
} catch (err) {
  copied = false;
}

// Fallback for http / blocked clipboard contexts
if (!copied) copied = fallbackCopyTextToClipboard(payload);

if (copied) {
  levelToastText = "Exported makeMap() to clipboard (also logged to console)";
  levelToastUntilMs = performance.now() + 2500;
} else {
  console.warn("Clipboard blocked — showing export overlay");
  levelToastText = "Clipboard blocked — showing export box";
  levelToastUntilMs = performance.now() + 2500;
  showExportOverlay(payload);
}
}



let invUI = null; // cached inventory UI layout for click handling

// Inventory tabs (3 bags, each 24 slots shown at a time)
const INV_TAB_SIZE = 24; // must match server (6x4 grid)
const INV_TAB_COUNT = 3;
const INV_TOTAL_SLOTS = INV_TAB_SIZE * INV_TAB_COUNT;
const INV_TABS = [
  { key: "equipment", label: "Equipment" },
  { key: "consumable", label: "Consumables" },
  { key: "other", label: "Other" },
];
let invActiveTab = 0; // 0=equipment, 1=consumables, 2=other

let dropConfirm = null; // { slotIndex, itemId }

// Inventory window (draggable)
let invWinX = null;
let invWinY = null;
let invWinW = 0;
let invWinH = 0;
let invDragging = false;
let invDragOffX = 0;
let invDragOffY = 0;
let invCloseRect = null;
let invHeaderRect = null;

// Skills window (draggable)
let skillsUI = null; // cached skills UI layout for click handling
let skillsWinX = null;
let skillsWinY = null;
let skillsWinW = 0;
let skillsWinH = 0;
let skillsDragging = false;
let skillsDragOffX = 0;
let skillsDragOffY = 0;
let skillsCloseRect = null;
let skillsHeaderRect = null;

// Monster Book (draggable)
let monsterBookOpen = false;
let monsterBook = {};     // { mobType: { kills } }
let mobCatalog = {};      // from server (authoritative): { mobType: {name,maxHp,damage,drops:[] } }
let bookUI = null;        // cached layout for click/scroll
let bookWinX = null;
let bookWinY = null;
let bookWinW = 0;
let bookWinH = 0;
let bookDragging = false;
let bookDragOffX = 0;
let bookDragOffY = 0;
let bookCloseRect = null;
let bookHeaderRect = null;
let bookScrollY = 0;


let skillsTabRects = null; // {sword:{...}, spear:{...}, wand:{...}}
let skillsItemRects = null; // [{id, rect}, ...]


// Mouse position in screen-space (for inventory hover tooltips)
let uiMouse = { mx: 0, my: 0, has: false };
let invHover = null; // { id, qty, source, rect }
let invItemMenu = null; // { x, y, slotIndex, itemId }
let invItemMenuUI = null; // { panel, btnUse, btnBind }

let draggingInv = null; // { fromSlot, itemId }
let invPointerDownSlot = null;
let invPointerDownX = 0;
let invPointerDownY = 0;
let invPointerDownShift = false;
const INV_DRAG_THRESHOLD = 4;

let draggingHotbar = null; // { index }
let hotbarPointerDownIndex = null;
let hotbarPointerDownX = 0;
let hotbarPointerDownY = 0;
const HOTBAR_DRAG_THRESHOLD = 4;

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function rectHit(r, mx, my) {
  return !!r && mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h;
}
function lerp(a, b, t) { return a + (b - a) * t; }
function easeInOut(t) { return t * t * (3 - 2 * t); }
function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
function snap2(x, y) { return { x: Math.round(x), y: Math.round(y) }; }

// Show mob HP bars if you're nearby OR the mob is currently aggro/provoked.
function shouldShowMobHp(mob, me, wx, wy) {
  // Server sets aggroUntil when a mob is provoked (eg, after being hit)
  if (mob && typeof mob.aggroUntil === "number" && mob.aggroUntil > serverNowMs()) return true;
  if (!me) return true;
  return dist(me.x, me.y, wx, wy) <= MOB_HPBAR_DIST;
}

/* ======================
   ASSETS
====================== */
const tileImage    = new Image();
tileImage.onload = rebuildEditorGroundTiles;
tileImage.src = "/assets/tiles.png";
const objTileImage = new Image();
objTileImage.onload = rebuildEditorObjectTiles;
objTileImage.src = "/assets/tiles_objects.png";

// 16-tile autotile atlas (4x4)
const autotileDirtImg = new Image();
autotileDirtImg.onload = () => {
  // Ensure the tile palette thumbnails refresh when this loads.
  if (typeof editorBuildTileGrid === "function") editorBuildTileGrid();
};
autotileDirtImg.src = "/assets/autotile_dirtpath.png";

// 4-frame animated water atlas (1x4)
const autotileWaterImg = new Image();
autotileWaterImg.onload = () => {
  // Ensure the tile palette thumbnails refresh when this loads.
  if (typeof editorBuildTileGrid === "function") editorBuildTileGrid();
};
autotileWaterImg.src = "/assets/autotile_water.png";
// Skill 1 black hole spritesheet (8 frames vertical: 64x64 each)
const SKILL1_BLACKHOLE = {
  src: "/assets/skills/skill_blackhole.png",
  frameW: 64,
  frameH: 64,
  frames: 8,
  frameMs: 90, // ~11 FPS
};
const blackholeImg = new Image();
blackholeImg.src = SKILL1_BLACKHOLE.src;
const skill1IconImg = new Image();
skill1IconImg.src = "/assets/skills/icons/icon_skill_blackhole.png";
const skill2IconImg = new Image();
skill2IconImg.src = "/assets/skills/icons/icon_skill_double_stab.png";
const skill3IconImg = new Image();
skill3IconImg.src = "/assets/skills/icons/icon_skill_dash_slash.png";

const skill4IconImg = new Image();
skill4IconImg.src = "/assets/skills/icons/icon_skill_big_slash.png";

// Skill 5 icon (placeholder: reuse existing icon until a dedicated familiar icon is added)
const skill5IconImg = new Image();
skill5IconImg.src = "/assets/skills/icons/icon_skill_mage_orb.png";

// Skill 6 icon (Healing Cloud) – reuse the cloud sprite as an icon for now
const skill6IconImg = new Image();
skill6IconImg.src = "/assets/skills/icons/icon_skill_cloud.png";

// Hotbar icon lookup for skills
const hotbarSkillIcons = {
  skill1: skill1IconImg,
  skill2: skill2IconImg,
  skill3: skill3IconImg,
  skill4: skill4IconImg,
  skill5: skill5IconImg,
  skill6: skill6IconImg,
};

function getItemIconImage(itemId) {
  // Prefer inventory/equipment icons; fall back to drop sprites if needed
  return (typeof equipIcons !== "undefined" && equipIcons[itemId]) ? equipIcons[itemId]
       : (typeof itemSprites !== "undefined" && itemSprites[itemId]) ? itemSprites[itemId]
       : null;
}

// In case the image is already cached/complete
setTimeout(rebuildEditorObjectTiles, 0);
setTimeout(rebuildEditorGroundTiles, 0);
const playerSprite = new Image(); playerSprite.src = "/assets/player_image.png";
const playerIdleSprite = new Image(); playerIdleSprite.src = "/assets/player_idle.png";
const npcSprite    = new Image(); npcSprite.src = "/assets/npc.png";

// Static NPC images (new system)
const NPC_DRAW_W = 64;
const NPC_DRAW_H = 64;
const NPC_SORT_Y_OFFSET = 22;

const npcImages = {
  "npcs/npc_crystal.png": new Image(),
  "npcs/npc_girl.png": new Image(),
  "npcs/npc_jangoon.png": new Image(),
};
npcImages["npcs/npc_crystal.png"].src = "/assets/npcs/npc_crystal.png";
npcImages["npcs/npc_girl.png"].src    = "/assets/npcs/npc_girl.png";
npcImages["npcs/npc_jangoon.png"].src = "/assets/npcs/npc_jangoon.png";


// Attack weapon sprites (spears can swap art based on equipped spear item)
const spearSprites = {
  training_spear: new Image(),
  blue_umbrella_spear: new Image(),
  candy_cane_spear: new Image(),
  fang_spear: new Image(),

  trident_spear:  new Image(),
};
spearSprites.training_spear.src = "/assets/basic_spear.png";
spearSprites.blue_umbrella_spear.src = "/assets/blue_umbrella_spear.png";
spearSprites.candy_cane_spear.src = "/assets/candy_cane_spear.png";
spearSprites.fang_spear.src = "/assets/fang_spear.png";


spearSprites.trident_spear.src = "/assets/trident_spear.png";
// Projectile sprites (server sends pr.sprite key; fallback draws a simple bolt if missing)
const projectileSprites = {
  wand_projectile: new Image(),
  skill1_projectile: new Image(),
};
// Put your custom wand projectile here:
projectileSprites.wand_projectile.src = "/assets/wand_projectile.png";
// Skill 1 projectile sprite (used only for Skill 1 primed shots)
projectileSprites.skill1_projectile.src = "/assets/skill1_projectile.png";

// Familiar orb sprite for Skill 5 (wand familiar)
const familiarOrbImg = new Image();
familiarOrbImg.src = "/assets/skills/skill_orb.png";

// Healing Cloud sprite for Skill 6 (wand-only heal cloud)
const healingCloudImg = new Image();
healingCloudImg.src = "/assets/skills/skill_cloud.png";

// Visual easing constants for Healing Cloud
const HEALING_CLOUD_FADE_MS = 600;        // fade-in duration
const HEALING_CLOUD_FADE_OUT_MS = 600;        // fade-out duration
const HEALING_CLOUD_OFFSET_START =  60;    // px above feet at spawn
const HEALING_CLOUD_OFFSET_FINAL =  90;    // px above feet when “settled”
const HEALING_CLOUD_FLOAT_PIXELS = 16;        // upward drift on fade-out

function getSpearSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return spearSprites[wid] || null;
}


// Held-weapon overlay sprites (NOT the inventory icons).
// Icons live under /assets/equipment/*, but the in-hand overlays live under /assets/*.
const swordSprites = {
  training_sword: new Image(),
  branch_sword: new Image(),


  bone_sword: new Image(),
};
swordSprites.training_sword.src = "/assets/training_sword.png";
swordSprites.branch_sword.src = "/assets/branch_sword.png";


swordSprites.bone_sword.src = "/assets/bone_sword.png";
const wandSprites = {
  training_wand: new Image(),
  bone_wand: new Image(),
};
wandSprites.training_wand.src = "/assets/training_wand.png";
wandSprites.bone_wand.src = "/assets/bone_wand.png";

function getSwordSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return swordSprites[wid] || null;
}
function getWandSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return wandSprites[wid] || null;
}


function getSwordHand(dir) {
  // Shared sword hand anchor so held + slash align perfectly.
  // Tune these 4 numbers and both visuals will follow.
  return ({
    [DIR.RIGHT]: { x: -6,  y: 16 },
    [DIR.LEFT]:  { x:  6,  y: 16 },
    [DIR.DOWN]:  { x: -12, y: 16 },
    [DIR.UP]:    { x:  10, y: 16 },
  }[dir] || { x: 0, y: 0 });
}

function getSpearHand(dir) {
  return ({
    [DIR.RIGHT]: { x: -10, y: 15 },
    [DIR.LEFT]:  { x:  10, y: 15 },
    [DIR.DOWN]:  { x: -14, y: -3 },
    [DIR.UP]:    { x:  10, y: 25 },
  }[dir] || { x: 32, y: 32 });
}


function drawSwordHeld(x, y, dir, swordImg) {
  x = Math.round(x); y = Math.round(y);

  // Use the shared anchor so held + slash never drift apart.
  const hand = getSwordHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  const img = swordImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Keep the sword upright (no 90° rotation). Mirror for LEFT so it sits naturally.
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = 32, H = 64;

  // Grip point inside the sprite (from top-left of the 32x64 image).
  // Starter values: bottom-center-ish.
  const gripX = 16;
  const gripY = 50;

  ctx.imageSmoothingEnabled = false;
  if (ready) ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  else {
    // fallback: simple blade
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-1, -44, 2, 40);
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-6, -10, 12, 6);
  }
  ctx.restore();
}

function drawWandHeld(x, y, dir, wandImg) {
  x = Math.round(x); y = Math.round(y);

  // Starter hand anchors (tune as needed)
  const hand = ({
    [DIR.RIGHT]: { x: -6,  y: 20 },
    [DIR.LEFT]:  { x:  6,  y: 20 },
    [DIR.DOWN]:  { x: -12, y: 20 },
    [DIR.UP]:    { x:  10, y: 20 },
  }[dir] || { x: 0, y: 0 });

  const px = x + hand.x;
  const py = y + hand.y;

  const img = wandImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Keep the wand/staff upright (no 90° rotation). Mirror for LEFT.
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = 32, H = 64;

  // Grip point (starter): bottom-center-ish
  const gripX = 16;
  const gripY = 52;

  ctx.imageSmoothingEnabled = false;
  if (ready) ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  else {
    // fallback: simple staff
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -50, 4, 48);
    ctx.fillStyle = "#bde0fe";
    ctx.fillRect(-4, -54, 8, 6);
  }
  ctx.restore();
}

function drawDebugCircle(x, y, r, stroke) {
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();
}

function weaponKeyFromEquippedId(wid) {
  if (!wid) return null;
  if (wid.includes("spear")) return "spear";
  if (wid.includes("wand")) return "wand";
  if (wid.includes("sword")) return "sword";
  return null;
}

function dirVecFromAtkDir(atkDir, facing) {
  if (atkDir === "left") return { x: -1, y: 0 };
  if (atkDir === "right") return { x: 1, y: 0 };
  if (atkDir === "up") return { x: 0, y: -1 };
  if (atkDir === "down") return { x: 0, y: 1 };
  const fx = facing?.x ?? 0;
  const fy = facing?.y ?? 0;
  const ax = Math.abs(fx), ay = Math.abs(fy);
  if (ax > ay) return { x: fx >= 0 ? 1 : -1, y: 0 };
  if (ay > 0) return { x: 0, y: fy >= 0 ? 1 : -1 };
  return { x: 0, y: 1 };
}
const mobSprites = {
  green: new Image(),
  pink: new Image(),
  orange: new Image(),
  purple: new Image(),
  rainbow: new Image(),
  snail_blue: new Image(),
  snail_red: new Image(),
};
mobSprites.green.src   = "/assets/mobs/slime_green.png";
mobSprites.pink.src    = "/assets/mobs/slime_pink.png";
mobSprites.orange.src  = "/assets/mobs/slime_orange.png";
mobSprites.purple.src  = "/assets/mobs/slime_purple.png";
mobSprites.rainbow.src = "/assets/mobs/slime_rainbow.png";
mobSprites.snail_blue.src = "/assets/mobs/snail_blue.png";
mobSprites.snail_red.src  = "/assets/mobs/snail_red.png";
/* ======================
   EQUIPMENT ICONS (32x32)
====================== */
var equipIcons = {
  training_sword: new Image(),
  branch_sword: new Image(),
  bone_sword:    new Image(),
  training_spear: new Image(),
  blue_umbrella_spear: new Image(),
  training_wand:  new Image(),
  bone_wand:      new Image(),
  cloth_armor:    new Image(),
  cloth_hat:      new Image(),
  lucky_charm:    new Image(),
  candy_cane_spear: new Image(),
  fang_spear:       new Image(),
  trident_spear:    new Image(),
  charger_helmet: new Image(),
  red_duke:       new Image(),
  charger_suit: new Image(),
  orange_flan: new Image(),
  potion_green: new Image(),
  potion_purple: new Image(),
  green_jelly: new Image(),
  orange_jelly: new Image(),
  pink_jelly: new Image(),
  purple_jelly: new Image(),
  rainbow_jelly: new Image(),


};

// coin icon (used by drops list + inventory; safe if missing)
equipIcons.coin = new Image();
equipIcons.coin.src = "/assets/items/gold_coin.png";

equipIcons.training_sword.src = "/assets/equipment/training_sword.png";
equipIcons.branch_sword.src = "/assets/equipment/branch_sword.png";

equipIcons.bone_sword.src = "/assets/equipment/bone_sword.png";
equipIcons.training_spear.src = "/assets/equipment/training_spear.png";
equipIcons.blue_umbrella_spear.src = "/assets/equipment/blue_umbrella_spear.png";
equipIcons.training_wand.src  = "/assets/equipment/training_wand.png";
equipIcons.bone_wand.src      = "/assets/equipment/bone_wand.png";
equipIcons.cloth_armor.src    = "/assets/equipment/cloth_armor.png";
equipIcons.cloth_hat.src      = "/assets/equipment/cloth_hat.png";
equipIcons.charger_helmet.src = "/assets/equipment/charger_helmet.png";
equipIcons.red_duke.src       = "/assets/equipment/red_duke.png";
equipIcons.charger_suit.src = "/assets/equipment/charger_suit.png";
equipIcons.orange_flan.src = "/assets/items/orange_flan.png";
equipIcons.lucky_charm.src    = "/assets/equipment/lucky_charm.png";
equipIcons.candy_cane_spear.src = "/assets/equipment/candy_cane_spear.png";
equipIcons.fang_spear.src       = "/assets/equipment/fang_spear.png";

equipIcons.trident_spear.src = "/assets/equipment/trident_spear.png";
equipIcons.potion_green.src  = "/assets/items/potion_green.png";
equipIcons.potion_purple.src = "/assets/items/potion_purple.png";
equipIcons.green_jelly.src = "/assets/items/green_jelly.png";
equipIcons.orange_jelly.src = "/assets/items/orange_jelly.png";
equipIcons.pink_jelly.src = "/assets/items/pink_jelly.png";
equipIcons.purple_jelly.src = "/assets/items/purple_jelly.png";
equipIcons.rainbow_jelly.src = "/assets/items/rainbow_jelly.png";



function drawItemIcon(itemId, x, y, slotSize) {
  const img = equipIcons[itemId];
  if (!img || !img.complete || img.naturalWidth === 0) return false;

  const ICON = 32;
  const ix = Math.round(x + (slotSize - ICON) / 2);
  const iy = Math.round(y + (slotSize - ICON) / 2);
  ctx.drawImage(img, ix, iy, ICON, ICON);
  return true;
}

/* ======================
   PAPER-DOLL OVERLAYS (48x48 frames)
====================== */
const armorOverlays = {
  cloth_armor: new Image(),
  charger_suit: new Image(),
};
armorOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_cloth_armor.png";

armorOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_charger_suit.png";
// Hat overlays for walking/moving (3 cols x 4 rows, 64x64 frames)
const hatOverlays = { cloth_hat: new Image(), charger_helmet: new Image(), red_duke: new Image() };
hatOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_cloth_hat.png";


hatOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_charger_helmet.png";
hatOverlays.red_duke.src = "/assets/equipment/overlays/overlay_red_duke.png";
// Idle overlays (2 cols x 4 rows, 64x64 frames)
const armorIdleOverlays = { cloth_armor: new Image(), charger_suit: new Image() };
armorIdleOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_idle_cloth_armor.png";
armorIdleOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_idle_charger_suit.png";
const hatIdleOverlays = { cloth_hat: new Image(), charger_helmet: new Image(), red_duke: new Image() };
hatIdleOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_idle_cloth_hat.png";




hatIdleOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_idle_charger_helmet.png";
hatIdleOverlays.red_duke.src = "/assets/equipment/overlays/overlay_idle_red_duke.png";

// Default hair overlays (shown when no hat is equipped)
// Update these paths if your filenames differ.
const defaultHairOverlays = { default: new Image() };
defaultHairOverlays.default.src = "/assets/equipment/overlays/overlay_hair.png";

const defaultHairIdleOverlays = { default: new Image() };
defaultHairIdleOverlays.default.src = "/assets/equipment/overlays/overlay_idle_hair.png";
/* ======================
   CANVAS
====================== */
const canvas = document.getElementById("c");

// Hamburger menu button (opens inventory) — keeps 'I' hotkey too.
var invBtn = document.getElementById("invBtn");

// --- Main (hamburger) menu state ---
let mainMenuOpen = false;
let mainMenu = document.getElementById("mainMenu");

function updateMenuBtnState() {
  if (!invBtn) invBtn = document.getElementById("invBtn");
  if (!invBtn) return;
  invBtn.setAttribute("aria-expanded", mainMenuOpen ? "true" : "false");
}

function setMainMenuOpen(open) {
  mainMenuOpen = !!open;
  if (!mainMenu) mainMenu = document.getElementById("mainMenu");
  if (mainMenu) mainMenu.classList.toggle("open", mainMenuOpen);
  updateMenuBtnState();
}

function toggleMainMenu() {
  setMainMenuOpen(!mainMenuOpen);
}

// Back-compat: some places may still call updateInvBtnState from earlier patching.
function updateInvBtnState() { updateMenuBtnState(); }

// Button toggles the menu (not inventory)
if (invBtn) {
  invBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    toggleMainMenu();
  });
}

// Prevent menu clicks from interacting with the canvas (attacks / movement)
if (mainMenu) {
  mainMenu.addEventListener("pointerdown", (e) => {
    e.stopPropagation();
    // Prevent pointerdown from ever reaching the canvas
    // (helps on some browsers where pointer events behave oddly)
    e.preventDefault();
  });
}

// Close the menu when clicking outside
document.addEventListener("pointerdown", (e) => {
  if (!mainMenuOpen) return;
  const t = e.target;
  if (t === invBtn) return;
  if (mainMenu && mainMenu.contains(t)) return;
  setMainMenuOpen(false);
});

// Menu item actions (Items wired now; others can be enabled later)
if (mainMenu) {
  mainMenu.addEventListener("click", (e) => {
    // Keep menu interactions from triggering canvas actions
    e.stopPropagation();

    const btn = e.target && e.target.closest ? e.target.closest(".main-menu-item") : null;
    if (!btn) return;
    if (btn.disabled || btn.classList.contains("disabled")) return;

    const action = btn.getAttribute("data-action");
    if (action === "items") {
      toggleInventory();
      setMainMenuOpen(false);
      return;
    }
    if (action === "skills") {
      toggleSkills();
      setMainMenuOpen(false);
      return;
    }
    if (action === "book") {
      toggleMonsterBook();
      setMainMenuOpen(false);
      return;
    }
  });
}
// Escape closes the menu (and keeps existing ESC behavior elsewhere)
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && mainMenuOpen) {
    setMainMenuOpen(false);
  }
});


function updateInvBtnState() {
  // If this runs before invBtn is assigned, try to grab it.
  if (!invBtn) invBtn = document.getElementById("invBtn");
  if (!invBtn) return;
  invBtn.setAttribute("aria-expanded", inventoryOpen ? "true" : "false");
}

function guessWeaponTab() {
  const me = worldPlayers && worldPlayers[myId];
  const w = me?.equipment?.weapon ?? me?.weapon ?? null;
  const wid = (typeof w === "string") ? w : (w && typeof w === "object" ? (w.id || w.itemId || w.type) : "");
  const s = String(wid || "").toLowerCase();
  if (s.includes("spear")) return "spear";
  if (s.includes("wand")) return "wand";
  if (s.includes("sword")) return "sword";
  return "wand";
}

function toggleSkills() {
  skillsOpen = !skillsOpen;
  pendingSkillBind = null;

  if (skillsOpen) {
    monsterBookOpen = false;
    bookUI = null;
    bookDragging = false;
    // Only show one window at a time for now
    inventoryOpen = false;
    invUI = null;
    invHover = null;

    // pick a reasonable default tab (based on equipped weapon)
    skillsTab = guessWeaponTab();

    // lazy init window position
    if (skillsWinX == null || skillsWinY == null) {
      skillsWinX = Math.floor(canvas.width / 2 - 190);
      skillsWinY = Math.floor(canvas.height / 2 - 170);
    }
  }

  skillsDragging = false;
}


function toggleMonsterBook() {
  monsterBookOpen = !monsterBookOpen;

  if (monsterBookOpen) {
    // Only show one window at a time for now
    inventoryOpen = false;
    invUI = null;
    invHover = null;
    invDragging = false;

    skillsOpen = false;
    skillsUI = null;
    skillsDragging = false;

    // reset any bind mode
    pendingSkillBind = null;
    pendingItemBind = null;
  }

  // lazy init window position
  if (monsterBookOpen && (bookWinX == null || bookWinY == null)) {
    bookWinX = Math.floor(canvas.width / 2 - 560 / 2);
    bookWinY = Math.floor(canvas.height / 2 - 420 / 2);
  }
}



function toggleInventory() {
  inventoryOpen = !inventoryOpen;

  if (inventoryOpen) {
    monsterBookOpen = false;
    bookUI = null;
    bookDragging = false;
    invItemMenu = null;
    invItemMenuUI = null;
    pendingItemBind = null;

    skillsOpen = false;
    skillsUI = null;
    skillsDragging = false;
  }
  // lazy init window position
  if (inventoryOpen && (invWinX == null || invWinY == null)) {
    invWinX = Math.floor(canvas.width / 2 - 180);
    invWinY = Math.floor(canvas.height / 2 - 180);
  }

  if (!inventoryOpen) {
    invDragging = false;
    invItemMenu = null;
    invItemMenuUI = null;
    pendingItemBind = null;
    dropConfirm = null;
  }

  updateInvBtnState();
}

const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// Hit-flash uses an offscreen canvas; cache per sprite size.
const fxCache = new Map(); // key: "{w}x{h}" => { c, ctx }
function getFxCtx(w, h) {
  const key = `${w}x${h}`;
  let entry = fxCache.get(key);
  if (!entry) {
    const c = document.createElement("canvas");
    c.width = w;
    c.height = h;
    const ctx2 = c.getContext("2d");
    ctx2.imageSmoothingEnabled = false;
    entry = { c, ctx: ctx2 };
    fxCache.set(key, entry);
  }
  return entry;
}


/* ======================
   FADE TRANSITION
====================== */
let fadeState = "none";
let fadeA = 0;
let fadeTimer = 0;
let portalSent = false;
let portalWaitTimer = 0;

// Small local throttle to avoid spamming portal requests (server also enforces its own cooldown)
let nextPortalAtMs = 0;
const PORTAL_COOLDOWN_MS = 450;

const FADE_OUT_DUR = 0.18;
const FADE_IN_DUR  = 0.18;

function startPortalFade() {
  if (fadeState !== "none") return;

  const nowMs = performance.now();
  if (nowMs < nextPortalAtMs) return;
  nextPortalAtMs = nowMs + PORTAL_COOLDOWN_MS;

  fadeState = "fadingOut";
  fadeTimer = 0;
  fadeA = 0;
  portalSent = false;
  portalWaitTimer = 0;

  // Send portal request immediately
  portalSent = true;
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "portal" }));

  // Freeze movement instantly
  keys.up = keys.down = keys.left = keys.right = false;
  sendInput();
}

function updateFade(dt) {
  if (fadeState === "none") return;
  fadeTimer += dt;

  if (fadeState === "fadingOut") {
    fadeA = Math.min(fadeTimer / FADE_OUT_DUR, 1);
    if (fadeTimer >= FADE_OUT_DUR) {
      fadeState = "waitingMap";
      fadeA = 1;
      portalWaitTimer = 0;
    }
  } else if (fadeState === "waitingMap") {
    fadeA = 1;
    portalWaitTimer += dt;

    // Safety fallback — never stay black forever
    if (portalWaitTimer > 1.2) {
      fadeState = "fadingIn";
      fadeTimer = 0;
      levelToastText = "Portal failed — stand fully on portal and press E";
      levelToastUntilMs = performance.now() + 2400;
    }
  } else if (fadeState === "fadingIn") {
    fadeA = 1 - Math.min(fadeTimer / FADE_IN_DUR, 1);
    if (fadeTimer >= FADE_IN_DUR) {
      fadeState = "none";
      fadeA = 0;
    }
  }
}

function drawFadeOverlay() {
  if (fadeA <= 0) return;
  ctx.save();
  ctx.globalAlpha = fadeA;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
/* ======================
   NETWORK
====================== */
const wsProto = (location.protocol === "https:") ? "wss" : "ws";
let ws = null;
let wsReconnectTimer = null;

function scheduleWsReconnect(delayMs = 800) {
  if (document.visibilityState === "hidden") return;
  if (wsReconnectTimer) return;
  wsReconnectTimer = setTimeout(() => {
    wsReconnectTimer = null;
    connectWs();
  }, delayMs);
}

function connectWs() {
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

  try {
    ws = new WebSocket(`${wsProto}://${location.host}`);
  } catch (err) {
    scheduleWsReconnect(1000);
    return;
  }

  ws.addEventListener("open", handleWsOpen);
  ws.onmessage = handleWsMessage;
  ws.addEventListener("close", () => {
    scheduleWsReconnect(700);
  });
  ws.addEventListener("error", () => {
    try { ws.close(); } catch {}
  });
}

function wsSend(obj) {
  if (!ws || ws.readyState !== 1) return false;
  try {
    ws.send(JSON.stringify(obj));
    return true;
  } catch {
    return false;
  }
}

// --- Server clock sync (Render can be ~0-2s ahead/behind your PC clock).
// Server timestamps (startMs/endMs/cooldowns) are serverNowMs()-based epoch ms.
// We estimate the offset so visuals/cooldowns line up instantly everywhere.
let serverClockOffsetMs = 0; // localNow - serverNow
let haveServerClock = false;
function serverNowMs() { return Date.now() - serverClockOffsetMs; }

let myName = (() => {
  try {
    const saved = localStorage.getItem("playerName");
    return (typeof saved === "string" && saved.trim()) ? saved.trim() : null;
  } catch {
    return null;
  }
})();
let nameSent = false;

function promptForName() {
  // Only prompt once per page load unless rejected.
  while (true) {
    const raw = window.prompt("Enter your name (letters only, 4-8 chars):", myName || "") || "";
    const name = raw.trim();
    if (/^[A-Za-z]{4,8}$/.test(name)) {
      myName = name;
      try { localStorage.setItem("playerName", myName); } catch {}
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: "setName", name }));
        nameSent = true;
      }
      break;
    }
    alert("Name must be letters only, 4-8 characters.");
  }
}

function handleWsOpen() {
  if (myName && /^[A-Za-z]{4,8}$/.test(myName)) {
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: "setName", name: myName }));
      nameSent = true;
    }
    return;
  }
  promptForName();
}

connectWs();


let myId = null;
let map = null;
let objMap = null;
let zMap = null;
let zGateMap = null;
let currentMapId = null;
// Minimal map metadata we keep client-side for editor exports (e.g., authored mobSpawns).
let currentMap = null;
let portals = []; // [{x,y,to,...}] current map portal positions

let worldPlayers = {};
let worldNpcs = {};
let worldMobs = {};

// Spawn fade-in tracking (client-side)
const MOB_SPAWN_FADE_MS = 200; // how long mobs fade in after spawning/respawning
const mobSpawnAtMs = new Map(); // mobId -> performance.now() when it became alive
let worldDrops = {};
const dropAnim = new Map(); // dropId -> { spawnUiMs, seed } for hop + bob
let worldProjectiles = {};
let whirlpools = []; // active skill1 vortices from server [{x,y,rad,endMs,...}]

const netState = new Map();

/* --- HIT FX STATE --- */
const hitFx = new Map();
let familiarHitPulseUntilMs = 0;
const familiarTrails = new Map();
const familiarStates = new Map();
let screenShakeUntilMs = 0;
let screenShakeMag = 0;

function startScreenShake(mag = 4, ms = 140) {
  screenShakeMag = Math.max(screenShakeMag, mag);
  screenShakeUntilMs = Math.max(screenShakeUntilMs, performance.now() + ms);
}


/* ======================
   SKILLS UI (Tabbed)
====================== */
function drawSkillsMenu() {
  const tabs = ["sword", "spear", "wand"];
  const tabLabels = { sword: "Sword", spear: "Spear", wand: "Wand" };

  // Basic skill catalog (placeholder-friendly)
  const skillCatalog = {
    sword: [
      {
        id: "skill3",
        name: "Dash Slash",
        key: "3",
        icon: skill3IconImg,
        desc: "Dash forward and slash. Requires a sword.",
      },
      {
        id: "skill4",
        name: "Wide Slash",
        key: "4",
        icon: skill4IconImg,
        desc: "A wide sword swing that hits up to 3 nearby enemies. Requires a sword.",
      },
    ],
    spear: [
      {
        id: "skill2",
        name: "Double Stab",
        key: "2",
        icon: skill2IconImg,
        desc: "Stab twice quickly. Requires a spear.",
      },
    ],
    wand: [
      {
        id: "skill1",
        name: "Anomaly",
        key: "1",
        icon: skill1IconImg,
        desc: "Shoot a bolt that creates a whirlpool on impact. Requires a wand.",
      },
      {
        id: "skill5",
        name: "Wisp",
        key: "5",
        icon: skill5IconImg,
        desc: "Summon a familiar that follows you. When you hit a mob with a wand bolt, the familiar attacks it (1 hit/sec). Requires a wand.",
      },
      {
        id: "skill6",
        name: "Nimbus",
        key: "6",
        icon: skill6IconImg,
        desc: "Summon a cloud above you that rains gentle healing for 10 seconds. Requires a wand.",
      },
    ],
  };

  const HEADER_H = 26;
  const TAB_H = 26;
  const PAD = 14;

  const panelW = 380;
  const panelH = 320;

  // init window if needed
  if (skillsWinX == null || skillsWinY == null) {
    skillsWinX = Math.floor(canvas.width / 2 - panelW / 2);
    skillsWinY = Math.floor(canvas.height / 2 - panelH / 2);
  }

  // clamp to screen
  skillsWinX = clamp(skillsWinX, 10, canvas.width - panelW - 10);
  skillsWinY = clamp(skillsWinY, 10, canvas.height - panelH - 10);

  const x = skillsWinX;
  const y = skillsWinY;
  const w = panelW;
  const h = panelH;

  skillsWinW = w;
  skillsWinH = h;

  // panel
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.80)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

  // header
  ctx.fillStyle = "rgba(255,255,255,0.08)";
  ctx.fillRect(x, y, w, HEADER_H);
  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.font = "13px system-ui, sans-serif";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";
  ctx.fillText("Skills", x + 10, y + HEADER_H / 2);

  // close button
  const closeSize = 18;
  const cx = x + w - closeSize - 6;
  const cy = y + (HEADER_H - closeSize) / 2;
  ctx.fillStyle = "rgba(255,255,255,0.10)";
  ctx.fillRect(cx, cy, closeSize, closeSize);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(cx + 0.5, cy + 0.5, closeSize - 1, closeSize - 1);
  ctx.fillStyle = "rgba(255,255,255,0.80)";
  ctx.textAlign = "center";
  ctx.fillText("×", cx + closeSize / 2, cy + closeSize / 2 + 0.5);

  skillsCloseRect = { x: cx, y: cy, w: closeSize, h: closeSize };
  skillsHeaderRect = { x, y, w, h: HEADER_H };

  // tabs
  const tabY = y + HEADER_H;
  const tabW = Math.floor((w - PAD * 2) / tabs.length);
  const tabX0 = x + PAD;

  skillsTabRects = {};
  for (let i = 0; i < tabs.length; i++) {
    const t = tabs[i];
    const tx = tabX0 + i * tabW;
    const active = (skillsTab === t);

    ctx.fillStyle = active ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.06)";
    ctx.fillRect(tx, tabY, tabW - 6, TAB_H);
    ctx.strokeStyle = active ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.14)";
    ctx.strokeRect(tx + 0.5, tabY + 0.5, tabW - 6 - 1, TAB_H - 1);

    ctx.fillStyle = active ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.70)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(tabLabels[t], tx + (tabW - 6) / 2, tabY + TAB_H / 2);

    skillsTabRects[t] = { x: tx, y: tabY, w: tabW - 6, h: TAB_H };
  }

  // content area
  const contentX = x + PAD;
  const contentY = tabY + TAB_H + 10;
  const contentW = w - PAD * 2;
  const contentH = h - (contentY - y) - PAD;

  ctx.fillStyle = "rgba(255,255,255,0.04)";
  ctx.fillRect(contentX, contentY, contentW, contentH);
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.strokeRect(contentX + 0.5, contentY + 0.5, contentW - 1, contentH - 1);

  const list = skillCatalog[skillsTab] || [];
  skillsItemRects = [];

  const cardH = 62;
  const iconS = 34;
  const gap = 10;

  if (list.length === 0) {
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("No skills yet for this weapon.", contentX + contentW / 2, contentY + 26);
    ctx.fillStyle = "rgba(255,255,255,0.40)";
    ctx.fillText("Add more skills later and they'll show up here.", contentX + contentW / 2, contentY + 46);
  } else {
    for (let i = 0; i < list.length; i++) {
      const s = list[i];
      const cy2 = contentY + 10 + i * (cardH + 10);
      const cardX = contentX + 10;
      const cardW = contentW - 20;

      // card bg
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(cardX, cy2, cardW, cardH);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(cardX + 0.5, cy2 + 0.5, cardW - 1, cardH - 1);

      // icon box
      const ix = cardX + 10;
      const iy = cy2 + Math.floor((cardH - iconS) / 2);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(ix, iy, iconS, iconS);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(ix + 0.5, iy + 0.5, iconS - 1, iconS - 1);

      // draw icon if ready
      const img = s.icon;
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, ix + 1, iy + 1, iconS - 2, iconS - 2);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.18)";
        ctx.font = "10px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("ICON", ix + iconS / 2, iy + iconS / 2);
      }

      // name + desc
      const tx = ix + iconS + gap;
      ctx.textAlign = "left";
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "13px system-ui, sans-serif";
      ctx.fillText(s.name, tx, cy2 + 18);

      ctx.fillStyle = "rgba(255,255,255,0.62)";
      ctx.font = "11px system-ui, sans-serif";
      ctx.fillText(s.desc, tx, cy2 + 38);

      // key badge
      const badge = hotbarKeyForSkill(s.id);
      const bw = 28;
      const bh = 18;
      const bx = cardX + cardW - bw - 10;
      const by = cy2 + 12;

      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(bx, by, bw, bh);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(bx + 0.5, by + 0.5, bw - 1, bh - 1);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(badge, bx + bw / 2, by + bh / 2);

      // assign button (click to bind to a hotbar key)
      const abw = 62;
      const abh = 18;
      const abx = cardX + cardW - abw - 10;
      const aby = by + bh + 8;

      const isBinding = !!(pendingSkillBind && pendingSkillBind.skillId === s.id);

      ctx.fillStyle = isBinding ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.08)";
      ctx.fillRect(abx, aby, abw, abh);
      ctx.strokeStyle = isBinding ? "rgba(255,255,255,0.32)" : "rgba(255,255,255,0.18)";
      ctx.strokeRect(abx + 0.5, aby + 0.5, abw - 1, abh - 1);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(isBinding ? "Press 1-6" : "Assign", abx + abw / 2, aby + abh / 2);

      skillsItemRects.push({
        id: s.id,
        rect: { x: cardX, y: cy2, w: cardW, h: cardH },
        badgeRect: { x: bx, y: by, w: bw, h: bh },
        assignRect: { x: abx, y: aby, w: abw, h: abh }
      });
    }
  }

  ctx.restore();

  // expose hit-test data
  skillsUI = {
    x, y, w, h,
    close: skillsCloseRect,
    header: skillsHeaderRect,
    tabs: skillsTabRects,
    items: skillsItemRects,
  };
}


/* --- DAMAGE POPUPS --- */
const damagePops = []; // {x,y,text,color,untilMs}

/* --- HIT SPARKS (impact bursts) --- */
const hitSparks = []; // {x,y,dir,untilMs}

/**
 * Direction-specific anchor so impacts feel "heavier".
 * We bias sparks toward the side the hit came from (relative to the TARGET sprite).
 */
function getHitSparkOffset(dir, kind) {
  // Tweak these 4 numbers if you want different "impact points".
  // Player sprites are 64x64; mobs are 48x48, but these offsets read well for both.
  const common = {
    [DIR.RIGHT]: { x:  22, y:  -6 },
    [DIR.LEFT]:  { x: -22, y:  -6 },
    [DIR.DOWN]:  { x:   0, y:  14 },
    [DIR.UP]:    { x:   0, y: -22 },
  }[dir] || { x: 0, y: 0 };

  // Slightly closer-in for mobs so it doesn't look like it's floating off the slime.
  if (kind === "mob") {
    return { x: Math.round(common.x * 0.85), y: Math.round(common.y * 0.85) };
  }
  return common;
}

function spawnHitSparksAt(x, y, dir, kind) {
  const now = performance.now();
  const off = getHitSparkOffset(dir, kind);

  // 1 "main" spark burst + a couple secondary pops
  const baseX = x + off.x;
  const baseY = y + off.y;

  hitSparks.push({ x: baseX, y: baseY, dir, untilMs: now + 160 });
  hitSparks.push({ x: baseX + rand(-4, 4), y: baseY + rand(-3, 3), dir, untilMs: now + 120 });
  hitSparks.push({ x: baseX + rand(-6, 6), y: baseY + rand(-4, 4), dir, untilMs: now + 100 });
}

function drawHitSparks() {
  const now = performance.now();

  for (let i = hitSparks.length - 1; i >= 0; i--) {
    const s = hitSparks[i];
    if (now > s.untilMs) { hitSparks.splice(i, 1); continue; }

    const life = 170;
    const t = clamp(1 - ((s.untilMs - now) / life), 0, 1);
    const alpha = clamp(1 - t, 0, 1);

    // small outward "burst"
    const burst = Math.round(6 + t * 10);

    // direction-biased drift (so it "kicks" in the hit direction)
    let dx = 0, dy = 0;
    if (s.dir === DIR.RIGHT) dx = 1;
    else if (s.dir === DIR.LEFT) dx = -1;
    else if (s.dir === DIR.DOWN) dy = 1;
    else if (s.dir === DIR.UP) dy = -1;

    const cx = Math.round(s.x + dx * t * 6);
    const cy = Math.round(s.y + dy * t * 6);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";

    // starburst: 4 lines
    ctx.beginPath();
    ctx.moveTo(cx - burst, cy); ctx.lineTo(cx + burst, cy);
    ctx.moveTo(cx, cy - burst); ctx.lineTo(cx, cy + burst);
    ctx.moveTo(cx - burst + 2, cy - burst + 2); ctx.lineTo(cx + burst - 2, cy + burst - 2);
    ctx.moveTo(cx - burst + 2, cy + burst - 2); ctx.lineTo(cx + burst - 2, cy - burst + 2);
    ctx.stroke();

    ctx.restore();
  }
}

// tiny helper
function rand(a, b) { return a + Math.random() * (b - a); }


/* --- LOOT POPUPS --- */
const lootPops = []; // {x,y,text,untilMs}

function upsertNet(id, x, y, now) {
  const WARP_DIST = TILE_SIZE * 3;

  if (!netState.has(id)) {
    netState.set(id, {
      prev: { x, y, t: now },
      curr: { x, y, t: now },
      vx: 0, vy: 0,
      smoothX: x, smoothY: y
    });
    return;
  }

  const s = netState.get(id);

  const dxWarp = x - s.curr.x;
  const dyWarp = y - s.curr.y;
  if (Math.hypot(dxWarp, dyWarp) > WARP_DIST) {
    s.prev = { x, y, t: now };
    s.curr = { x, y, t: now };
    s.vx = 0; s.vy = 0;
    s.smoothX = x; s.smoothY = y;
    return;
  }

  const old = s.curr;
  s.prev = s.curr;
  s.curr = { x, y, t: now };

  const dt = s.curr.t - old.t;
  if (dt > 0.0001) {
    s.vx = (s.curr.x - old.x) / dt;
    s.vy = (s.curr.y - old.y) / dt;
  }
}

let activeDialogue = null;

// level toast
let levelToastUntilMs = 0;
let levelToastText = "";


function drawMonsterBook() {
  const PAD = 14;
  const HEADER_H = 28;

  const panelW = 560;
  const panelH = 420;

  if (bookWinX == null || bookWinY == null) {
    bookWinX = Math.floor(canvas.width / 2 - panelW / 2);
    bookWinY = Math.floor(canvas.height / 2 - panelH / 2);
  }

  const x = bookWinX;
  const y = bookWinY;
  const w = panelW;
  const h = panelH;

  bookWinW = w;
  bookWinH = h;

  // clamp position to screen
  bookWinX = clamp(bookWinX, 8, canvas.width - w - 8);
  bookWinY = clamp(bookWinY, 8, canvas.height - h - 8);

  ctx.save();

  // Panel
  ctx.fillStyle = "rgba(0,0,0,0.72)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(x, y, w, h);

  // Header
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(x, y, w, HEADER_H);
  ctx.fillStyle = "rgba(255,255,255,0.90)";
  ctx.font = "16px sans-serif";
  ctx.textBaseline = "middle";
  ctx.fillText("Monster Book", x + PAD, y + HEADER_H / 2);

  // Close
  const closeSize = 22;
  const closeX = x + w - PAD - closeSize;
  const closeY = y + (HEADER_H - closeSize) / 2;
  ctx.fillStyle = "rgba(255,255,255,0.10)";
  ctx.fillRect(closeX, closeY, closeSize, closeSize);
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "16px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("×", closeX + closeSize / 2, closeY + closeSize / 2 + 1);
  ctx.textAlign = "left";

  const headerRect = { x, y, w, h: HEADER_H };
  const closeRect = { x: closeX, y: closeY, w: closeSize, h: closeSize };

  // Content area
  const contentX = x + PAD;
  const contentY = y + HEADER_H + PAD;
  const contentW = w - PAD * 2;
  const contentH = h - HEADER_H - PAD * 2;

  // Build list of discovered mobs
  const discovered = Object.keys(monsterBook || {}).filter(k => (monsterBook[k]?.kills ?? 0) > 0);
  discovered.sort((a, b) => {
    const an = (mobCatalog?.[a]?.name || a);
    const bn = (mobCatalog?.[b]?.name || b);
    return an.localeCompare(bn);
  });

  const rowH = 74;
  const totalH = discovered.length * rowH;
  const maxScroll = Math.max(0, totalH - contentH);
  bookScrollY = clamp(bookScrollY, 0, maxScroll);

  // clip content
  ctx.save();
  ctx.beginPath();
  ctx.rect(contentX, contentY, contentW, contentH);
  ctx.clip();

  const items = [];

  let yy = contentY - bookScrollY;
  for (const mobType of discovered) {
    const cat = mobCatalog?.[mobType] || {};
    const nm = cat.name || mobType;
    const maxHp = cat.maxHp ?? 0;
    const dmg = cat.damage ?? 0;
    const kills = monsterBook?.[mobType]?.kills ?? 0;

    // row bg
    ctx.fillStyle = "rgba(255,255,255,0.04)";
    ctx.fillRect(contentX, yy, contentW, rowH - 8);
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.strokeRect(contentX, yy, contentW, rowH - 8);

    // left icon area (simple)
    const iconBox = 46;
    const ix = contentX + 10;
    const iy = yy + 10;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(ix, iy, iconBox, iconBox);

    // mob still image (if available) — first frame only
    const mobImg = (typeof mobSprites !== "undefined") ? (mobSprites[mobType] || null) : null;
    if (mobImg && mobImg.complete && mobImg.naturalWidth > 0) {
      // Your mob spritesheets are 3 columns x 4 direction rows. Show the very first frame (col 0, row 0).
      const { w: fw, h: fh } = getMobFrameSize(mobImg);
      const sx = 0;
      const sy = 0;
      ctx.drawImage(mobImg, sx, sy, fw, fh, ix + 4, iy + 4, iconBox - 8, iconBox - 8);
    } else {
      // fallback: first letter
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.font = "18px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText((nm || "?").slice(0, 1).toUpperCase(), ix + iconBox / 2, iy + iconBox / 2);
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
    }


    // name + stats
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "16px sans-serif";
    ctx.textBaseline = "top";
    ctx.fillText(nm, ix + iconBox + 12, yy + 10);

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "13px sans-serif";
    ctx.fillText(`HP: ${maxHp}   ATK: ${dmg}   Defeated: ${kills}`, ix + iconBox + 12, yy + 32);

    // drops
    const drops = Array.isArray(cat.drops) ? cat.drops : [];
    const dx0 = ix + iconBox + 12;
    let dx = dx0;
    const dy = yy + 52;

    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = "12px sans-serif";
    ctx.fillText("Drops:", dx, dy);
    dx += 44;

    for (let di = 0; di < Math.min(drops.length, 10); di++) {
      const d = drops[di];
      const itemId = d?.itemId || "coin";
      const img = equipIcons?.[itemId] || null;

      const sz = 18;
      const bx = dx;
      const by = dy - 3;

      ctx.fillStyle = "rgba(0,0,0,0.30)";
      ctx.fillRect(bx, by, sz, sz);

      if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, bx + 1, by + 1, sz - 2, sz - 2);
      } else {
        // coin / missing icon fallback
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(itemId === "coin" ? "¢" : "?", bx + sz / 2, by + sz / 2);
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
      }

      // chance label
      const chance = typeof d?.chance === "number" ? d.chance : 0;
      const pct = Math.round(chance * 100);
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.font = "10px sans-serif";
      ctx.textBaseline = "top";
      ctx.fillText(`${pct}%`, bx + sz + 4, by + 4);

      dx += 56;
      if (dx > contentX + contentW - 70) break;
    }

    items.push({ mobType, rect: { x: contentX, y: yy, w: contentW, h: rowH - 8 } });

    yy += rowH;
  }

  if (discovered.length === 0) {
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "15px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Defeat a monster to unlock an entry.", contentX + contentW / 2, contentY + contentH / 2);
    ctx.textAlign = "left";
  }

  ctx.restore(); // clip
  ctx.restore();

  // expose hit-test data
  bookUI = {
    x, y, w, h,
    close: closeRect,
    header: headerRect,
    content: { x: contentX, y: contentY, w: contentW, h: contentH },
    items,
    maxScroll,
  };

  bookCloseRect = closeRect;
  bookHeaderRect = headerRect;
}


function handleWsMessage(e) {
  const msg = JSON.parse(e.data);

  if (msg.type === "nameRejected") {
    // Re-prompt (server-side validation is source of truth)
    nameSent = false;
    setTimeout(promptForName, 0);
    return;
  }
  if (msg.type === "nameAccepted") {
    myName = msg.name || myName;
    try { if (myName) localStorage.setItem("playerName", myName); } catch {}
    return;
  }


  if (msg.type === "hotbarState") {
    hotbarSlots = sanitizeHotbarSlots(msg.slots);
    return;
  }

  if (msg.type === "skill5Rejected") {
    hotbarToast(msg.reason || "Can't use Familiar");
    return;
  }

  if (msg.type === "skill6Rejected") {
    hotbarToast(msg.reason || "Can't use Healing Cloud");
    return;
  }


if (msg.type === "devSpawnResult") {
  if (msg.ok) {
    const id = msg.itemId || "item";
    const qty = msg.qty || 1;
    hotbarToast(`Spawned ${id} x${qty}`);
  } else {
    hotbarToast(`Spawn failed: ${msg.reason || "unknown error"}`);
  }
  return;
}

  if (msg.type === "skill5State") {
    // Immediate feedback; actual state comes from snapshots.
    const on = !!msg.active;

    // When familiar skill is toggled on, snap orb back to the player by
    // clearing any cached client-side familiar state/trail for this owner.
    if (on && myId) {
      familiarStates.delete(myId);
      familiarTrails.delete(myId);
    }

    return;
  }




  if (msg.type === "skill2Fx") {
    // Map-scoped visual cue for double-stab spear scaling/jut
    if (msg.casterId != null && typeof msg.startMs === "number") {
      skill2FxByCaster.set(String(msg.casterId), { startMs: msg.startMs });
    }
    return;
  }

if (msg.type === "skill3Fx") {
    // Optional dash trail visuals
    if (msg.casterId != null && typeof msg.startMs === "number") {
      const from = (msg.from && typeof msg.from === "object")
        ? { x: Number(msg.from.x) || 0, y: Number(msg.from.y) || 0 }
        : null;
      const to = (msg.to && typeof msg.to === "object")
        ? { x: Number(msg.to.x) || 0, y: Number(msg.to.y) || 0 }
        : null;
      if (from && to) skill3FxByCaster.set(String(msg.casterId), { startMs: msg.startMs, from, to });
    }
    return;
  }

  if (msg.type === "welcome") {
    myId = msg.id;
    map = msg.map;
    objMap = msg.objMap || objMap;
    if (msg.zMap) zMap = msg.zMap;
    if (msg.zGateMap) zGateMap = msg.zGateMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    currentMapId = msg.mapId ?? currentMapId;

    // Keep authored map metadata (for editor export fallbacks)
    if (msg.mapId != null) {
      const ms = Array.isArray(msg.mobSpawns) ? msg.mobSpawns : [];
      currentMap = { id: msg.mapId, mobSpawns: ms };
      seedEditorMobSpawns(msg.mapId, ms);
    }

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;
    if (msg.mobCatalog && typeof msg.mobCatalog === "object") { mobCatalog = msg.mobCatalog; rebuildEditorMobTypes(); }
    if (msg.monsterBook && typeof msg.monsterBook === "object") monsterBook = msg.monsterBook;
    return;
  }


  if (msg.type === "monsterBookUpdate") {
    const mobType = String(msg.mobType || "");
    if (!mobType) return;
    if (msg.entry && typeof msg.entry === "object") {
      monsterBook[mobType] = msg.entry;
    } else {
      monsterBook[mobType] = { kills: (monsterBook[mobType]?.kills ?? 0) + 1 };
    }
    if (msg.isNew) {
      const nm = mobCatalog?.[mobType]?.name || mobType;
      hotbarToast(`New Monster Book Entry: ${nm}`, 1600);
    }
    return;
  }

  if (msg.type === "monsterBook") {
    if (msg.book && typeof msg.book === "object") monsterBook = msg.book;
    return;
  }

  if (msg.type === "snapshot") {
    if (typeof msg.nowMs === "number") {
      const sample = Date.now() - msg.nowMs; // local - server
      if (!haveServerClock) { serverClockOffsetMs = sample; haveServerClock = true; }
      else { serverClockOffsetMs = serverClockOffsetMs * 0.9 + sample * 0.1; } // smooth
    }

    const now = performance.now() / 1000;

    const newMapId = msg.mapId ?? currentMapId;
    const mapChanged = (currentMapId != null && newMapId !== currentMapId);
    currentMapId = newMapId;

    // Update authored metadata when provided (server now includes mobSpawns).
    // Only *seed* the editor list when entering a map (or first time we learn its spawns),
    // so an intentional in-editor clear (empty list) isn't undone by the next snapshot.
    const hasMobSpawns = Array.isArray(msg.mobSpawns);
    if (hasMobSpawns || mapChanged || !currentMap || currentMap.id !== newMapId) {
      const ms = hasMobSpawns ? msg.mobSpawns : (currentMap?.mobSpawns || []);
      currentMap = { id: newMapId, mobSpawns: ms };
      if (mapChanged || !editorMobSpawnsByMapId.has(String(newMapId))) {
        seedEditorMobSpawns(newMapId, ms);
      }
    }

    if (msg.map) map = msg.map;
    if (msg.objMap) objMap = msg.objMap;
    if (msg.zMap) zMap = msg.zMap;
    if (msg.zGateMap) zGateMap = msg.zGateMap;

if (Array.isArray(msg.whirlpools)) whirlpools = msg.whirlpools;
    if (msg.selfMonsterBook && typeof msg.selfMonsterBook === "object") monsterBook = msg.selfMonsterBook;


    // Skill 1 timers for local HUD/hotbar
    const _nowAbs = serverNowMs();
    if (typeof msg.selfSkill1ActiveUntilMs === "number") {
      skill1ActiveUntilMs = msg.selfSkill1ActiveUntilMs;
      if (skill1ActiveUntilMs > _nowAbs && skill1ActiveUntilMs !== _lastSkill1ActiveUntilMs) {
        skill1ActiveTotalMs = Math.max(0, skill1ActiveUntilMs - _nowAbs);
        _lastSkill1ActiveUntilMs = skill1ActiveUntilMs;
      }
    }
    if (typeof msg.selfSkill1CdUntilMs === "number") {
      skill1CdUntilMs = msg.selfSkill1CdUntilMs;
      if (skill1CdUntilMs > _nowAbs && skill1CdUntilMs !== _lastSkill1CdUntilMs) {
        skill1CdTotalMs = Math.max(0, skill1CdUntilMs - _nowAbs);
        _lastSkill1CdUntilMs = skill1CdUntilMs;
      }

    // Skill 2 timers for local HUD/hotbar
    if (typeof msg.selfSkill2CdUntilMs === "number") {
      skill2CdUntilMs = msg.selfSkill2CdUntilMs;
      if (skill2CdUntilMs > _nowAbs && skill2CdUntilMs !== _lastSkill2CdUntilMs) {
        skill2CdTotalMs = Math.max(0, skill2CdUntilMs - _nowAbs);
        _lastSkill2CdUntilMs = skill2CdUntilMs;
      }
    }
    // Skill 3 timers for local HUD/hotbar
    if (typeof msg.selfSkill3CdUntilMs === "number") {
      skill3CdUntilMs = msg.selfSkill3CdUntilMs;
      if (skill3CdUntilMs > _nowAbs && skill3CdUntilMs !== _lastSkill3CdUntilMs) {
        skill3CdTotalMs = Math.max(0, skill3CdUntilMs - _nowAbs);
        _lastSkill3CdUntilMs = skill3CdUntilMs;
      }
    }

    // Skill 4 timers for local HUD/hotbar
    if (typeof msg.selfSkill4CdUntilMs === "number") {
      skill4CdUntilMs = msg.selfSkill4CdUntilMs;
      if (skill4CdUntilMs > _nowAbs && skill4CdUntilMs !== _lastSkill4CdUntilMs) {
        skill4CdTotalMs = Math.max(0, skill4CdUntilMs - _nowAbs);
        _lastSkill4CdUntilMs = skill4CdUntilMs;
      }
    }

    }

    objMap = msg.objMap || objMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;

    worldPlayers = msg.players || {};
    worldNpcs = msg.npcs || {};
    const prevMobs = worldMobs;
    worldMobs = msg.mobs || {};
    worldDrops = msg.drops || {};
    syncDropAnimFromSnapshot(worldDrops);
    worldProjectiles = msg.projectiles || {};

    // Skill 6: Healing Cloud – capture our own active-until timer from snapshot
    if (typeof myId !== "undefined" && worldPlayers) {
      const me = worldPlayers[myId];
      if (me && typeof me.healingCloudUntilMs === "number") {
        skill6CloudUntilMs = me.healingCloudUntilMs;
      } else {
        skill6CloudUntilMs = 0;
      }
    }

    // Track mob spawn/respawn so we can fade them in smoothly
    const nowMs = performance.now();
    for (const [id, mob] of Object.entries(worldMobs)) {
      const prev = prevMobs ? prevMobs[id] : undefined;
      const wasDead = !!prev?.dead;
      const isAliveNow = !mob?.dead;
      const isNew = !prev;
      if (isAliveNow && (isNew || wasDead)) {
        mobSpawnAtMs.set(id, nowMs);
      }
    }
    // Clean up spawn timestamps for mobs that no longer exist
    for (const id of Array.from(mobSpawnAtMs.keys())) {
      if (!worldMobs[id]) mobSpawnAtMs.delete(id);
    }


    for (const [id, p] of Object.entries(worldPlayers)) upsertNet(id, p.x, p.y, now);
    for (const [id, n] of Object.entries(worldNpcs)) upsertNet(id, n.x, n.y, now);
    for (const [id, m0] of Object.entries(worldMobs)) upsertNet(id, m0.x, m0.y, now);

    const alive = new Set([
      ...Object.keys(worldPlayers),
      ...Object.keys(worldNpcs),
      ...Object.keys(worldMobs),
    ]);
    for (const id of Array.from(netState.keys())) if (!alive.has(id)) netState.delete(id);

	if (mapChanged) {
    // Clear client-side familiar visuals when the map changes
    familiarStates.clear();
    familiarTrails.clear();

	  // Always resolve fade if map actually changed
	  fadeState = "fadingIn";
	  fadeTimer = 0;
	}

    return;
  }


  if (msg.type === "mapPatch") {
    // Small server-authoritative map edit (used by the in-game editor)
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    if (!Number.isInteger(tx) || !Number.isInteger(ty) || !Number.isInteger(tile)) return;
    if (!map || ty < 0 || tx < 0 || ty >= map.length || tx >= map[0].length) return;

    if (layer === "ground") {
      map[ty][tx] = tile;
    } else if (layer === "object") {
      if (!objMap) objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
      objMap[ty][tx] = tile;
    } else if (layer === "height") {
      if (!zMap) zMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
      zMap[ty][tx] = tile;
    } else if (layer === "zgate") {
      if (!zGateMap) zGateMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
      zGateMap[ty][tx] = tile;
    }
    return;
  }


  if (msg.type === "editAck") {
    // Server response for editor edits (helps diagnose why something "didn't work")
    const ok = !!msg.ok;
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    const reason = msg.reason ? String(msg.reason) : "";
    if (ok) {
      levelToastText = `Edit OK: ${layer} (${tx},${ty}) = ${tile}`;
    } else {
      levelToastText = `Edit REJECTED: ${layer} (${tx},${ty}) = ${tile}${reason ? ` (${reason})` : ""}`;
    }
    levelToastUntilMs = performance.now() + 2500;
    return;
  }


  if (msg.type === "dialogue") {
    activeDialogue = {
      npcId: msg.npcId,
      npcName: msg.npcName || msg.npcId,
      text: msg.text || "",
      untilMs: performance.now() + 4000
    };
    return;
  }

  if (msg.type === "hit") {
    const targetId = String(msg.targetId || "");
    const kind = msg.targetKind || "mob";
    const amount = Number(msg.amount || 0);

    const srcX = +msg.srcX || 0;
    const srcY = +msg.srcY || 0;

    // Use fx to distinguish familiar hits from normal hits
    const fxKind = String(msg.fx || "");

    let tx = 0, ty = 0;
    const rawP = worldPlayers[targetId];
    const rawM = worldMobs[targetId];

    if (rawP) { tx = rawP.x; ty = rawP.y; }
    else if (rawM) { tx = rawM.x; ty = rawM.y; }

    if (amount > 0 && (rawP || rawM)) {
      damagePops.push({
        x: tx,
        y: ty - 10,
        text: `${amount}`,
        color: (kind === "player") ? "#ff6b6b" : "#ffffff",
        untilMs: performance.now() + 650
      });
    }

    const dx = tx - srcX;
    const dy = ty - srcY;
    const l = Math.hypot(dx, dy) || 1;
    const ax = dx / l, ay = dy / l;

    // Direction-specific impact sparks (world-space)
    const sparkDir = dirFromVector(ax, ay) ?? DIR.DOWN;
    if (rawP || rawM) spawnHitSparksAt(tx, ty, sparkDir, kind);

    const isMe = (targetId === myId);

    // Familiar hits: no visual knockback / bump.
    const bumpScale = (fxKind === "familiar") ? 0 : 6;

    if (fxKind === "familiar") {
      familiarHitPulseUntilMs = performance.now() + 220;
    }

hitFx.set(targetId, {
      untilMs: performance.now() + 220,
      color: (kind === "player") ? "rgba(255,0,0,0.45)" : "rgba(255,255,255,0.45)",
      bumpX: ax * bumpScale,
      bumpY: ay * bumpScale,
    });

    if (isMe && bumpScale !== 0) startScreenShake(5, 160);
    return;
  }


  
  if (msg.type === "heal") {
    const targetId = String(msg.targetId || "");
    const amount = Number(msg.amount || 0);

    const rawP = worldPlayers[targetId];
    if (amount <= 0 || !rawP) return;

    // Green healing number popup
    damagePops.push({
      x: rawP.x,
      y: rawP.y - 10,
      text: `${amount}`,
      color: "#3cff9c",
      untilMs: performance.now() + 650
    });

    // Gentle green/white flash on the healed player, similar to hitFx but without bump.
    hitFx.set(targetId, {
      untilMs: performance.now() + 220,
      color: "rgba(160,255,200,0.55)",
      bumpX: 0,
      bumpY: 0,
    });

    return;
  }

if (msg.type === "levelup") {
    levelToastText = `LEVEL UP!  Lv ${msg.level}`;
    levelToastUntilMs = performance.now() + 1600;
    return;
  }

  if (msg.type === "loot") {
    const me = getMyPos();
    if (me && msg.kind === "gold") {
      lootPops.push({
        x: me.x,
        y: me.y - 18,
        text: `+${msg.amount}g`,
        untilMs: performance.now() + 700
      });
    }
    return;
  }
};

/* ======================
   INPUT
====================== */
const keys = { up:false, down:false, left:false, right:false };
let lastEPressed = 0;

// Double-tap detection for Dash Slash (Skill 3, sword-only).
// Only triggers if Skill 3 is actually bound to any hotbar slot (1–6).
const DOUBLE_TAP_DASH_WINDOW_MS = 260;
const lastMoveTapMs = {
  up: 0,
  down: 0,
  left: 0,
  right: 0,
};

function maybeTriggerDashSlashFromMoveKey(dir, e) {
  // Only care about key **down**, not repeats or keyup
  if (!e || e.repeat) return;

  // Don't dash while UI overlays or editor are open
  if (inventoryOpen || skillsOpen || monsterBookOpen || editorOpen) return;

  // Respect Healing Cloud's cast lock (same behavior as hotbar usage)
  if (skill6CastArmed && typeof performance !== "undefined") {
    const nowUi = performance.now();
    if (nowUi < skill6CastEndClientMs) return;
  }

  // Require Skill 3 to be actually on the hotbar (slots 1–6)
  if (typeof hotbarKeyForSkill !== "function" || typeof useHotbarSlot !== "function") return;
  const keyLabel = hotbarKeyForSkill("skill3");
  if (!keyLabel) return; // not bound => no dash-on-double-tap

  const now = (typeof performance !== "undefined") ? performance.now() : Date.now();
  const last = lastMoveTapMs[dir] || 0;
  lastMoveTapMs[dir] = now;

  // Detect double-tap in the configured window
  if (now - last <= DOUBLE_TAP_DASH_WINDOW_MS) {
    const n = Number(keyLabel);
    if (!Number.isFinite(n)) return;

    // Set dash direction override so Skill3 uses the movement direction instead of the mouse.
    skill3DashOverrideDir = dir;

    // Use the hotbar slot directly so all cooldown / gating / flashes stay consistent
    useHotbarSlot(n);
  }
}

function sendInput() {
  // While channeling Healing Cloud, freeze movement inputs so the player cannot move.
  if (skill6CastArmed && typeof performance !== "undefined") {
    const nowUi = performance.now();
    if (nowUi < skill6CastEndClientMs) {
      const frozen = { up:false, down:false, left:false, right:false };
      if (ws.readyState === 1) ws.send(JSON.stringify({ type: "input", ...frozen }));
      return;
    }
  }
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "input", ...keys }));
}

function setMoveKey(e, down) {
  if (fadeState !== "none") return;
  const k = e.key.toLowerCase();
  let dir = null;

  if (k === "w" || e.key === "ArrowUp")  { keys.up    = down; dir = "up"; }
  if (k === "s" || e.key === "ArrowDown"){ keys.down  = down; dir = "down"; }
  if (k === "a" || e.key === "ArrowLeft"){ keys.left  = down; dir = "left"; }
  if (k === "d" || e.key === "ArrowRight"){ keys.right = down; dir = "right"; }

  // On key **down** for a movement key, check for double-tap dash
  if (down && dir) {
    maybeTriggerDashSlashFromMoveKey(dir, e);
  }

  sendInput();
}


function getMouseCanvasFromEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  return { mx, my, rect, scaleX, scaleY };
}

function getMouseWorldFromEvent(e) {
  const { mx, my } = getMouseCanvasFromEvent(e);
  return { mx, my, wx: camX + mx, wy: camY + my };
}


// Keep an updated mouse->world aim point even when you aren't clicking.
// This lets keyboard-triggered skills aim in the same direction as click-attacks.
canvas.addEventListener("mousemove", (e) => {
  // Track cursor for both aiming and UI hover.
  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);

  uiMouse.mx = mx; uiMouse.my = my; uiMouse.has = true;
  lastAim.mx = mx;
  lastAim.my = my;
  lastAim.wx = wx;
  lastAim.wy = wy;
  lastAim.has = true;

  // If we're dragging the HUD or hotbar bar, update their positions (Ctrl-drag).
  if (draggingHudBar && typeof canvas !== "undefined") {
    const layout = getHudLayout();
    const outerW = layout.w + 8;
    const outerH = layout.hpH + layout.xpH + layout.padding * 2;
    const rawX = mx - hudDragOffsetX;
    const rawY = my - hudDragOffsetY;
    const clampedX = clamp(rawX, 0, canvas.width - outerW);
    const clampedY = clamp(rawY, 0, canvas.height - outerH);
    hudPos = { x: clampedX + 4, y: clampedY + 4 };
    return;
  }

  if (draggingHotbarBar && typeof canvas !== "undefined") {
    const layout = getHotbarLayout();
    const rawX = mx - hotbarBarDragOffsetX;
    const rawY = my - hotbarBarDragOffsetY;
    const clampedX = clamp(rawX, 0, canvas.width - layout.totalW);
    const clampedY = clamp(rawY, 0, canvas.height - layout.box);
    hotbarPos = { x: clampedX, y: clampedY };
    return;
  }

  // Hotbar drag start detection (only if mouse was pressed on a hotbar slot)
  if (hotbarPointerDownIndex != null && !draggingHotbar) {
    const dx = mx - hotbarPointerDownX;
    const dy = my - hotbarPointerDownY;
    if (Math.abs(dx) > HOTBAR_DRAG_THRESHOLD || Math.abs(dy) > HOTBAR_DRAG_THRESHOLD) {
      draggingHotbar = { index: hotbarPointerDownIndex };
    }
  }

  // Inventory drag start detection
  if (inventoryOpen && invUI && invPointerDownSlot != null && !draggingInv) {
    const dx = mx - invPointerDownX;
    const dy = my - invPointerDownY;
    if (Math.abs(dx) > INV_DRAG_THRESHOLD || Math.abs(dy) > INV_DRAG_THRESHOLD) {
      const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
      const slots = me?.inventory?.slots || [];
      const slot = slots[invPointerDownSlot];
      if (slot) {
        draggingInv = { fromSlot: invPointerDownSlot, itemId: slot.id };
      } else {
        invPointerDownSlot = null;
      }
    }
  }
});


function dirFromVector(dx, dy) {
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);
  if (ax < 1e-3 && ay < 1e-3) return null;
  if (ax > ay) return dx >= 0 ? DIR.RIGHT : DIR.LEFT;
  return dy >= 0 ? DIR.DOWN : DIR.UP;
}

function calcAimFromWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return null;
  // Derive aim direction from screen-space (mouse relative to the player's rendered position).
  // This avoids "opposite direction" when camera smoothing lags behind the server position.
  let dx = wx - me.x;
  let dy = wy - me.y;
  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }
  const dir = dirFromVector(dx, dy);
  const len = Math.hypot(dx, dy) || 1;
  return { me, dx, dy, dir, aimDirX: dx / len, aimDirY: dy / len };
}

function sendAttackAtWorld(wx, wy, mx = null, my = null, extra = null) {
  const aim = calcAimFromWorld(wx, wy, mx, my);
  if (!aim) return;
  const { me, dir: d, aimDirX, aimDirY } = aim;

  // drive local attack animation direction immediately
  if (d != null) {
    // Update facing immediately so the server sees your intended direction,
    // but DO NOT start a local swing animation here. We only animate when the server accepts the attack.
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  const payload = { type: "attack", aimX: wx, aimY: wy, aimDirX, aimDirY };
  if (extra && typeof extra === "object") Object.assign(payload, extra);
  wsSend(payload);
}

// Hold-to-attack (mouse button held): server-authoritative repeat respecting weapon attack speed.
let attackHoldDown = false;
let _lastAttackHoldAimSentMs = 0;

function sendAttackHoldState(down, wx, wy, mx = null, my = null) {
  if (ws.readyState !== 1) return;
  const aim = calcAimFromWorld(wx, wy, mx, my);
  if (!aim) return;
  ws.send(JSON.stringify({
    type: "attackHold",
    down: !!down,
    aimX: wx,
    aimY: wy,
    aimDirX: aim.aimDirX,
    aimDirY: aim.aimDirY,
  }));
}

function sendAttackHoldAim(wx, wy, mx = null, my = null) {
  if (ws.readyState !== 1) return;
  const now = performance.now();
  // Light throttle so we don't spam aim updates.
  if (now - _lastAttackHoldAimSentMs < 50) return;
  _lastAttackHoldAimSentMs = now;
  const aim = calcAimFromWorld(wx, wy, mx, my);
  if (!aim) return;
  ws.send(JSON.stringify({
    type: "attackHoldAim",
    aimX: wx,
    aimY: wy,
    aimDirX: aim.aimDirX,
    aimDirY: aim.aimDirY,
  }));
}

function sendAttackHoldStop() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "attackHold", down: false }));
}

function sendAttack() {
  const me = worldPlayers[myId];
  const wid = me?.equipment?.weapon;
  if (!wid) {
    levelToastText = "Equip a weapon to attack";
    levelToastUntilMs = performance.now() + 1800;
    return;
  }
  // fallback: attack in current facing (server will use last facing)
  const nowMs = performance.now();
  if (nowMs < nextAttackAtMs) return;
  const delayMs = Math.round((getSwingDurByWeaponId(wid) + FLAT_ATTACK_LOCKOUT_SEC) * 1000);
  nextAttackAtMs = nowMs + delayMs;
  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "attack" }));
}

function sendInvClick(slot) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "invClick", slot }));
}

function sendInvMove(from, to) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "invMove", from, to }));
}

function sendDropItem(slot) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "dropItem", slot }));
}

function sendUnequip(slotName) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "unequip", slot: slotName }));
}

function sendSkill1Arm() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill1Arm" }));
}

function sendSkill5FamiliarToggle() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill5FamiliarToggle" }));
}

function sendSkill6HealingCloud() {
  if (!ws || ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill6HealingCloud" }));
}

function sendSkill2DoubleStabAtWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return;

  // Derive aim direction from screen-space (mouse relative to the player's rendered position),
  // matching sendAttackAtWorld().
  let dx = wx - me.x;
  let dy = wy - me.y;

  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }

  const d = dirFromVector(dx, dy);

  // Drive local facing immediately (no local swing; we still wait for server atkAnim)
  if (d != null) {
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  const len = Math.hypot(dx, dy) || 1;
  const aimDirX = dx / len;
  const aimDirY = dy / len;

  if (ws.readyState === 1) {
    ws.send(JSON.stringify({ type: "skill2DoubleStab", aimX: wx, aimY: wy, aimDirX, aimDirY }));
  }
}

function sendSkill2DoubleStab() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill2DoubleStab" }));
}




function sendSkill3DashSlashAtWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return;

  // Derive aim direction from screen-space (mouse relative to the player's rendered position),
  // matching sendAttackAtWorld().
  let dx = wx - me.x;
  let dy = wy - me.y;

  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }

  const d = dirFromVector(dx, dy);

  // Drive local facing immediately (no local swing; we still wait for server atkAnim)
  if (d != null) {
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  const len = Math.hypot(dx, dy) || 1;
  const aimDirX = dx / len;
  const aimDirY = dy / len;

  if (ws.readyState === 1) {
    ws.send(JSON.stringify({ type: "skill3DashSlash", aimX: wx, aimY: wy, aimDirX, aimDirY }));
  }
}

function sendSkill3DashSlash() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill3DashSlash" }));
}

function sendSkill4WideSlashAtWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return;

  // Derive aim direction from screen-space (mouse relative to the player's rendered position),
  // matching sendAttackAtWorld().
  let dx = wx - me.x;
  let dy = wy - me.y;

  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }

  const d = dirFromVector(dx, dy);

  // Drive local facing immediately (no local swing; we still wait for server atkAnim)
  if (d != null) {
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  const len = Math.hypot(dx, dy) || 1;
  const aimDirX = dx / len;
  const aimDirY = dy / len;

  if (ws.readyState === 1) {
    ws.send(JSON.stringify({ type: "skill4WideSlash", aimX: wx, aimY: wy, aimDirX, aimDirY }));
  }
}

function sendSkill4WideSlash() {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "skill4WideSlash" }));
}



window.addEventListener("keydown", (e) => {
  const key = e.key;
  const k = key.toLowerCase();

  // If the Skills menu is waiting for a hotbar key, capture 1–6 (or Esc to cancel).
  if (pendingSkillBind) {
    if (key === "Escape") {
      e.preventDefault();
      pendingSkillBind = null;
      hotbarToast("Skill bind canceled");
      return;
    }
    if (!e.repeat && k >= "1" && k <= "6") {
      e.preventDefault();
      bindHotbarSkill(Number(k), pendingSkillBind.skillId);
      pendingSkillBind = null;
      return;
    }
    // While binding, don't let number keys trigger other actions.
    if (k >= "1" && k <= "6") {
      e.preventDefault();
      return;
    }
  }

  // If the Inventory item bind flow is waiting for a hotbar key, capture 1–6 (or Esc to cancel).
  if (pendingItemBind) {
    if (key === "Escape") {
      e.preventDefault();
      pendingItemBind = null;
      hotbarToast("Item bind canceled");
      return;
    }
    if (!e.repeat && k >= "1" && k <= "6") {
      e.preventDefault();
      bindHotbarItem(Number(k), pendingItemBind.itemId, pendingItemBind.preferSlot);
      pendingItemBind = null;
      return;
    }
    // swallow other keys while binding an item
    if (!e.repeat) {
      e.preventDefault();
      return;
    }
  }


  // Debug editor hotkeys
  if (key === "F1") {
    e.preventDefault();
    if (!e.repeat) {
      editorOpen = !editorOpen;
      if (editorOpen) { rebuildEditorGroundTiles(); rebuildEditorObjectTiles(); rebuildEditorMobTypes(); }
      // reset selection for layer
      editorTileIndex = 0;
      const list = editorAllowedList();
      if (list.length) editorSetTileIndexByValue(list[0]);
      levelToastText = editorOpen ? "Editor ON (TAB layer, [ ] tile, Ctrl+E export)" : "Editor OFF";
      levelToastUntilMs = performance.now() + 2200;

      // Off-canvas editor panel
      editorInitDomPanelOnce();
      setEditorPanelVisible(editorOpen);
      editorUpdateDomHeader();
      if (editorOpen) editorBuildTileGrid();
    }
    return;
  }

  // Debug collision overlay
  if (key === "F3") {
    e.preventDefault();
    if (!e.repeat) {
      debugHitboxes = !debugHitboxes;
      levelToastText = debugHitboxes ? "Hitboxes ON" : "Hitboxes OFF";
      levelToastUntilMs = performance.now() + 1600;
    }
    return;
  }


// DEV: spawn an item into your inventory for testing
// Usage: press F9 and enter `itemId` or `itemId:qty` (e.g. potion_small:5, gold:250, trident_spear)
if (key === "F9") {
  e.preventDefault();
  if (e.repeat) return;
  if (typeof ws === "undefined" || !ws || ws.readyState !== 1) {
    hotbarToast("Not connected");
    return;
  }
  const raw = prompt("DEV Spawn item into inventory:\n\nFormat: itemId or itemId:qty\nExamples: potion_small:5  gold:250  trident_spear");
  if (!raw) return;
  const s = String(raw).trim();
  if (!s) return;
  const parts = s.split(":");
  const itemId = (parts[0] || "").trim();
  const qty = (parts.length > 1) ? parseInt(parts[1], 10) : 1;
  ws.send(JSON.stringify({ type: "devSpawnItem", itemId, qty }));
  hotbarToast(`Spawn request: ${itemId}${Number.isFinite(qty) ? " x" + qty : ""}`);
  return;
}

  if (editorOpen) {
    // keep panel in sync
    editorInitDomPanelOnce();
    setEditorPanelVisible(true);
    // Don't let movement keys interfere while editing unless you want them.
    if (key === "Tab") {
      e.preventDefault();
      editorNextLayer();
      editorTileIndex = 0;
      editorSetTileIndexByValue(0);
      editorUpdateDomHeader();
      editorBuildTileGrid();
      return;
    }

    if (key === "[") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex - 1 + list.length) % list.length;
      
      editorBuildTileGrid();
return;
    }
    if (key === "]") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex + 1) % list.length;
      
      editorBuildTileGrid();
return;
    }

    if (k === "g") {
      e.preventDefault();
      editorShowGrid = !editorShowGrid;
      return;
    }

    if (k === "c") {
      e.preventDefault();
      editorShowColl = !editorShowColl;
      return;
    }

    if ((e.ctrlKey || e.metaKey) && k === "e") {
      e.preventDefault();
      exportCurrentMapToClipboard();
      return;
    }
  }

  // Toggle Skills
  if (k === "k") {
    e.preventDefault();
    if (!e.repeat) {
      if (typeof setMainMenuOpen === "function") setMainMenuOpen(false);
      toggleSkills();
    }
    return;
  }


  // Toggle Monster Book
  if (k === "b") {
    e.preventDefault();
    if (!e.repeat) {
      if (typeof setMainMenuOpen === "function") setMainMenuOpen(false);
      toggleMonsterBook();
    }
    return;
  }
  // Toggle Inventory
  if (k === "i") {
    e.preventDefault();
    if (!e.repeat) {
      if (typeof setMainMenuOpen === "function") setMainMenuOpen(false);
      toggleInventory();
    }
    return;
  }


  // Escape closes Monster Book
  if (key === "Escape" && monsterBookOpen) {
    e.preventDefault();
    monsterBookOpen = false;
    bookDragging = false;
    return;
  }
  // Hotbar 1..6 (use or bind)
  if (k >= "1" && k <= "6") {
    e.preventDefault();
    if (e.repeat) return;

    const n = Number(k);

    // Ctrl/Cmd+number binds hovered inventory item (grid) to that hotbar slot
    if (e.ctrlKey || e.metaKey) {
      if (inventoryOpen && typeof invHover !== "undefined" && invHover && invHover.source === "grid") {
        bindHotbarItem(n, invHover.id, invHover.slotIndex);
        return;
      }
      hotbarToast("Hover an inventory item then press Ctrl+1-6 to bind");
      return;
    }

    useHotbarSlot(n);
    return;
  }

  // Interact
  if (k === "e") {
    e.preventDefault();
    const now = performance.now();
    if (!e.repeat && now - lastEPressed > 200) {
      lastEPressed = now;
      if (isOnPortal()) startPortalFade();
      else tryInteract();
    }
    return;
  }

  // Movement keys: respect Healing Cloud casting lock.
  if (skill6CastArmed && typeof performance !== "undefined") {
    const nowUi = performance.now();
    if (nowUi < skill6CastEndClientMs) {
      // Ignore movement key presses while casting.
      return;
    }
  }

  setMoveKey(e, true);
});


window.addEventListener("keyup", (e) => setMoveKey(e, false));

// Prevent "stuck walking" if the window loses and regains focus while
// movement keys are held (the browser may never send the keyup event).
function clearMovementKeysAndSend() {
  keys.up = false;
  keys.down = false;
  keys.left = false;
  keys.right = false;
  sendInput();
}

window.addEventListener("blur", () => {
  clearMovementKeysAndSend();
});

window.addEventListener("focus", () => {
  clearMovementKeysAndSend();
});


// Editor painting
canvas.addEventListener("contextmenu", (e) => {
  if (!editorOpen) return;
  e.preventDefault();
});

canvas.addEventListener("mousemove", (e) => {
  if (!editorOpen) return;
  const { mx, my } = getMouseCanvasFromEvent(e);
  editorMouseX = mx;
  editorMouseY = my;
  editorMouseHas = true;
  editorUpdateDomStatus();
});

canvas.addEventListener("mouseleave", () => { editorMouseHas = false; });

// Inventory tooltip hover reset
canvas.addEventListener("mouseleave", () => { uiMouse.has = false; });

canvas.addEventListener("mousedown", (e) => {


  if (!editorOpen) return;

  // If inventory is open and click is inside it, let inventory handle it.
  if (inventoryOpen && invUI) {
    const { mx, my } = getMouseCanvasFromEvent(e);
    // treat inventory window as a block region
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory mousedown run
    }
  }

  e.preventDefault();
  e.stopImmediatePropagation();

  const { mx, my } = getMouseCanvasFromEvent(e);

  if (!map) return;
  const tx = Math.floor((camX + mx) / TILE_SIZE);
  const ty = Math.floor((camY + my) / TILE_SIZE);
  if (tx < 0 || ty < 0 || ty >= map.length || tx >= map[0].length) return;

  const isRight = (e.button === 2);
  const tile = isRight ? 0 : editorSelectedTile();

  if (editorLayer === "ground") {
    // keep portals/statues intact (server also validates)
    map[ty][tx] = tile;
    sendEditTile("ground", tx, ty, tile);
    return;
  }

  if (editorLayer === "object") {
    if (!objMap) objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
    objMap[ty][tx] = tile;
    sendEditTile("object", tx, ty, tile);
    return;
  }

  if (editorLayer === "height") {
    if (!zMap) zMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
    zMap[ty][tx] = tile;
    sendEditTile("height", tx, ty, tile);
    return;
  }

  if (editorLayer === "zgate") {
    if (!zGateMap) zGateMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
    zGateMap[ty][tx] = tile ? 1 : 0;
    sendEditTile("zgate", tx, ty, tile ? 1 : 0);
    return;
  }

  if (editorLayer === "mobs") {
    const id = editorGetCurrentMapId();
    const list = getEditorMobSpawnsFor(id);
    const idx = findMobSpawnIndexAt(list, tx, ty);

    editorMobSpawnsTouched.add(String(id));

    if (isRight) {
      if (idx !== -1) {
        const removing = list[idx];
        list.splice(idx, 1);
        // If we deleted the selected spawn, clear selection.
        if (editorSelectedMobSpawn && (editorSelectedMobSpawn.mapId == id) && (editorSelectedMobSpawn.x|0) === (removing.x|0) && (editorSelectedMobSpawn.y|0) === (removing.y|0)) {
          editorSelectedMobSpawn = null;
        }
      }
      editorUpdateMobPropsPanel();
      return;
    }

    // LEFT click:
    // - Normal click on an existing spawn: select it for editing (no overwrite)
    // - Shift+click: force overwrite/replace using the currently selected mob type
    if (idx !== -1 && !e.shiftKey) {
      editorSelectedMobSpawn = { mapId: id, x: tx, y: ty };
      editorUpdateMobPropsPanel();
      return;
    }

    const mobType = String(editorSelectedTile() || "");
    if (!mobType) return;

    const base = editorDefaultSpawnForType(mobType, tx, ty);

    if (idx !== -1) {
      // Keep any existing tuning unless we're changing type; we still overwrite type & position.
      const prev = list[idx] || {};
      list[idx] = { ...prev, ...base };
    } else {
      list.push(base);
    }

    // Select the spawn we just placed/updated.
    editorSelectedMobSpawn = { mapId: id, x: tx, y: ty };
    editorUpdateMobPropsPanel();
    return;
  }
});

// Inventory click handling (equip / use / consume)
canvas.addEventListener("mousedown", (e) => {
  if (!inventoryOpen || !invUI) return;

  // Inventory consumes clicks (including the close X) so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const { mx, my } = getMouseCanvasFromEvent(e);

  // If a drop confirmation dialog is open, handle it first.
  if (dropConfirm) {
    const layout = getDropConfirmLayout();
    if (layout) {
      const { panel, btnYes, btnNo } = layout;

      if (rectHit(btnYes, mx, my)) {
        // Confirm drop
        const slotIndex = dropConfirm.slotIndex;
        dropConfirm = null;
        if (Number.isInteger(slotIndex)) {
          sendDropItem(slotIndex);
        }
        return;
      }

      if (rectHit(btnNo, mx, my) || rectHit(panel, mx, my)) {
        // Cancel drop on Cancel button or clicking the panel background.
        dropConfirm = null;
        return;
      }

      // Click outside the dialog cancels it as well.
      dropConfirm = null;
      return;
    }
  }

  // If an item submenu is open, handle it first.
  if (invItemMenu && invItemMenuUI) {
    if (rectHit(invItemMenuUI.panel, mx, my)) {
      if (rectHit(invItemMenuUI.btnUse, mx, my)) {
        sendInvClick(invItemMenu.slotIndex);
        invItemMenu = null;
        invItemMenuUI = null;
        return;
      }
      if (rectHit(invItemMenuUI.btnBind, mx, my)) {
        pendingItemBind = { itemId: invItemMenu.itemId, preferSlot: invItemMenu.slotIndex };
        invItemMenu = null;
        invItemMenuUI = null;
        hotbarToast("Press 1–6 to bind item (Esc to cancel)");
        return;
      }
      return; // clicked inside the panel but not on a button
    } else {
      // click outside closes the submenu (and continues)
      invItemMenu = null;
      invItemMenuUI = null;
    }
  }


  // close button
  if (invCloseRect && mx >= invCloseRect.x && mx <= invCloseRect.x + invCloseRect.w && my >= invCloseRect.y && my <= invCloseRect.y + invCloseRect.h) {
    e.preventDefault();
    e.stopImmediatePropagation();
    inventoryOpen = false;
    invDragging = false;
    return;
  }

  // drag header (but not when clicking inside slots)
  if (invHeaderRect && mx >= invHeaderRect.x && mx <= invHeaderRect.x + invHeaderRect.w && my >= invHeaderRect.y && my <= invHeaderRect.y + invHeaderRect.h) {
    invDragging = true;
    invDragOffX = mx - invWinX;
    invDragOffY = my - invWinY;
    return;
  }

  // inventory tabs
  if (invUI.tabs) {
    const tabOrder = ["equipment", "consumable", "other"];
    for (let ti = 0; ti < tabOrder.length; ti++) {
      const r = invUI.tabs[tabOrder[ti]];
      if (r && mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        invActiveTab = ti;
        // closing menus feels better when switching pages
        invItemMenu = null;
        invItemMenuUI = null;
        dropConfirm = null;
        return;
      }
    }
  }

  // equipment slots
  for (const [slotName, r] of Object.entries(invUI.equipSlots)) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      // If it is already equipped, unequip. If empty, server will ignore.
      sendUnequip(slotName);
      return;
    }
  }


  // inventory grid
  const g = invUI.grid;
  if (mx < g.x || my < g.y || mx > g.x + g.w || my > g.y + g.h) return;

  const sx = Math.floor((mx - g.x) / g.slotSize);
  const sy = Math.floor((my - g.y) / g.slotSize);
  if (sx < 0 || sy < 0 || sx >= g.cols || sy >= g.rows) return;

  const relIndex = sy * g.cols + sx;
  const slotIndex = (Number.isFinite(g.offset) ? g.offset : 0) + relIndex;

  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
  const slots = me?.inventory?.slots || [];
  const slot = slots[slotIndex];

  // Record pointer down for potential drag or click; do not perform the action yet.
  if (!slot) {
    invItemMenu = null;
    invItemMenuUI = null;
    invPointerDownSlot = null;
    return;
  }

  invPointerDownSlot = slotIndex;
  invPointerDownX = mx;
  invPointerDownY = my;
  invPointerDownShift = !!e.shiftKey;

  // Close any existing submenu; we'll reopen it on mouseup if needed.
  invItemMenu = null;
  invItemMenuUI = null;
});



canvas.addEventListener("mouseup", (e) => {
  if (!inventoryOpen || !invUI) {
    invPointerDownSlot = null;
    invPointerDownShift = false;
    draggingInv = null;
    return;
  }

  // If we never pressed down inside a slot and we're not dragging, ignore.
  if (invPointerDownSlot == null && !draggingInv) return;

  const { mx, my } = getMouseCanvasFromEvent(e);

  const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined") ? worldPlayers?.[myId] : null;
  const slots = me?.inventory?.slots || [];

  // If we are currently dragging, try to move, bind, or drop the item.
  if (draggingInv && draggingInv.fromSlot != null) {
    const fromSlot = draggingInv.fromSlot;

    // 1) Check if we dropped onto the hotbar: bind this item to that hotbar slot.
    const hotHit = getHotbarSlotHit(mx, my);
    if (hotHit) {
      const slot = slots[fromSlot];
      const itemId = slot?.id;
      if (itemId) {
        // Prefer the original inventory slot index so the hotbar can re-find it later.
        bindHotbarItem(hotHit.index + 1, itemId, fromSlot);
      }
      draggingInv = null;
      invPointerDownSlot = null;
      invPointerDownShift = false;
      return;
    }

    // 2) If we dropped completely outside the inventory window, ask for drop confirmation.
    if (invWinX != null && invWinY != null && invWinW > 0 && invWinH > 0) {
      const insideInv =
        mx >= invWinX && mx <= invWinX + invWinW &&
        my >= invWinY && my <= invWinY + invWinH;

      if (!insideInv) {
        const slot = slots[fromSlot];
        const itemId = slot?.id;
        if (slot && itemId) {
          dropConfirm = { slotIndex: fromSlot, itemId };
        }
        draggingInv = null;
        invPointerDownSlot = null;
        invPointerDownShift = false;
        return;
      }
    }

    // 3) Otherwise, try to move the item between inventory slots.
    let toSlot = null;

    // First, try to resolve a grid slot based purely on the cursor position,
    // so that dropping onto an *empty* cell still counts.
    const g = invUI.grid;
    if (mx >= g.x && my >= g.y && mx <= g.x + g.w && my <= g.y + g.h) {
      const sx = Math.floor((mx - g.x) / g.slotSize);
      const sy = Math.floor((my - g.y) / g.slotSize);
      if (sx >= 0 && sy >= 0 && sx < g.cols && sy < g.rows) {
        toSlot = (Number.isFinite(g.offset) ? g.offset : 0) + (sy * g.cols + sx);
      }
    }

    // Fallback: use getInventoryHover in case the helper has extra logic,
    // but only care about "grid" sources.
    if (toSlot == null) {
      const hover = getInventoryHover(mx, my, me?.inventory, me?.equipment, me);
      if (hover && hover.source === "grid") {
        toSlot = hover.slotIndex;
      }
    }

    if (Number.isInteger(toSlot) && toSlot >= 0 && toSlot < slots.length && toSlot !== fromSlot) {
      sendInvMove(fromSlot, toSlot);
    }

    draggingInv = null;
    invPointerDownSlot = null;
    invPointerDownShift = false;
    return;
  }

  // No drag started -> treat as a normal click.
  const slotIndex = invPointerDownSlot;
  invPointerDownSlot = null;

  const slot = slots[slotIndex];
  if (!slot) {
    invItemMenu = null;
    invItemMenuUI = null;
    return;
  }

  const g = invUI.grid;

  // No drag + no modifier: treat as a normal click (use/equip/menu).
  invPointerDownShift = false;

  // If this is a consumable, open the submenu instead of immediately using it.
  if (isConsumableItemId(slot.id)) {
    const relIndex = slotIndex - (Number.isFinite(g.offset) ? g.offset : 0);
    const sx = relIndex % g.cols;
    const sy = Math.floor(relIndex / g.cols);
    const slotX = g.x + sx * g.slotSize;
    const slotY = g.y + sy * g.slotSize;

    invItemMenu = {
      x: slotX + g.slotSize + 8,
      y: slotY,
      slotIndex,
      itemId: slot.id,
    };
    return;
  }

  // Non-consumables keep the old behavior (equip / etc.)
  sendInvClick(slotIndex);
});

canvas.addEventListener("mousedown", (e) => {
  if (!skillsOpen || !skillsUI) return;

  // Skills menu consumes clicks so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const { mx, my } = getMouseCanvasFromEvent(e);

  // close button
  const c = skillsUI.close;
  if (c && mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
    skillsOpen = false;
    skillsDragging = false;
    pendingSkillBind = null;
    return;
  }

  // tabs
  if (skillsUI.tabs) {
    for (const [t, r] of Object.entries(skillsUI.tabs)) {
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        skillsTab = t;
        return;
      }
    }
  }

  // drag header (but not when clicking close)
  const h = skillsUI.header;
  if (h && mx >= h.x && mx <= h.x + h.w && my >= h.y && my <= h.y + h.h) {
    skillsDragging = true;
    skillsDragOffX = mx - skillsWinX;
    skillsDragOffY = my - skillsWinY;
    return;
  }

  // click a skill card (for now just a toast)
  if (skillsUI.items) {
    for (const it of skillsUI.items) {
      const r = it.rect;
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        // Clicking any skill card enters a bind mode: press 1–6 to assign to hotbar.
        pendingSkillBind = { skillId: it.id };
        levelToastText = "Press 1-6 to bind that skill to your hotbar (Esc to cancel).";
        levelToastUntilMs = performance.now() + 1800;
        return;
      }
    }
  }
});

canvas.addEventListener("mousemove", (e) => {
  if (!skillsOpen || !skillsDragging) return;
  const { mx, my } = getMouseCanvasFromEvent(e);

  skillsWinX = Math.round(mx - skillsDragOffX);
  skillsWinY = Math.round(my - skillsDragOffY);
});


window.addEventListener("mousemove", (e) => {
  if (!inventoryOpen || !invDragging) return;
  const { mx, my } = getMouseCanvasFromEvent(e);

  invWinX = Math.round(mx - invDragOffX);
  invWinY = Math.round(my - invDragOffY);

  // keep on-screen
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
});



canvas.addEventListener("mousedown", (e) => {
  if (!monsterBookOpen || !bookUI) return;

  // Monster Book consumes clicks so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const { mx, my } = getMouseCanvasFromEvent(e);

  // close button
  if (bookCloseRect && mx >= bookCloseRect.x && mx <= bookCloseRect.x + bookCloseRect.w && my >= bookCloseRect.y && my <= bookCloseRect.y + bookCloseRect.h) {
    monsterBookOpen = false;
    bookDragging = false;
    return;
  }

  // drag header
  if (bookHeaderRect && mx >= bookHeaderRect.x && mx <= bookHeaderRect.x + bookHeaderRect.w && my >= bookHeaderRect.y && my <= bookHeaderRect.y + bookHeaderRect.h) {
    bookDragging = true;
    bookDragOffX = mx - bookWinX;
    bookDragOffY = my - bookWinY;
    return;
  }
});


// Click-to-attack (left mouse button). Determines attack direction by click quadrant.
// For wand, the click position determines projectile trajectory (server computes direction).
canvas.addEventListener("mousedown", (e) => {
  // Mobile: ignore synthetic mousedown events generated by touch taps.
  if (isTouchOriginMouseEvent(e)) return;

  if (e.button !== 0) return; // left click only
  if (editorOpen) return; // editor uses clicks for painting

  // Block basic attacks while Healing Cloud is still casting.
  if (skill6CastArmed && typeof performance !== "undefined") {
    const nowUi = performance.now();
    if (nowUi < skill6CastEndClientMs) {
      return;
    }
  }
  if (inventoryOpen && invUI) {
    const { mx, my } = getMouseCanvasFromEvent(e);
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory consume the click
    }
  }

  // avoid selecting text / dragging
  e.preventDefault();

  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);

  // Ctrl+drag HUD / hotbar to reposition them.
  if (e.ctrlKey) {
    const hudRect = (typeof getHudHitRect === "function") ? getHudHitRect() : null;
    if (hudRect && rectHit(hudRect, mx, my)) {
      draggingHudBar = true;
      hudDragOffsetX = mx - hudRect.x;
      hudDragOffsetY = my - hudRect.y;
      return;
    }

    const hotBounds = (typeof getHotbarBounds === "function") ? getHotbarBounds() : null;
    if (hotBounds && rectHit(hotBounds, mx, my)) {
      draggingHotbarBar = true;
      hotbarBarDragOffsetX = mx - hotBounds.x;
      hotbarBarDragOffsetY = my - hotBounds.y;
      return;
    }
  }

  // Hotbar press: record potential drag and block attacks while over the bar.
  const hotHit = getHotbarSlotHit(mx, my);
  if (hotHit && hotbarSlots[hotHit.index]) {
    hotbarPointerDownIndex = hotHit.index;
    hotbarPointerDownX = mx;
    hotbarPointerDownY = my;
    return;
  }
  hotbarPointerDownIndex = null;

  // If Skill 1 is primed, consume it on this wand shot.
  // Also start hold-to-attack so subsequent basic attacks repeat while the button stays down.
  attackHoldDown = true;
  sendAttackHoldState(true, wx, wy, mx, my);

  if (skill1Primed) {
    skill1Primed = false; // must press 1 again to try again (even if the shot misses)
    const me = worldPlayers[myId];
    const weaponKey = me?.weapon || null;
    if (weaponKey !== "wand") {
      levelToastText = "Equip a wand to use Skill 1";
      levelToastUntilMs = performance.now() + 1500;
      attackHoldDown = false;
      sendAttackHoldState(false, wx, wy, mx, my);
      return;
    }
    sendAttackAtWorld(wx, wy, mx, my, { skill1: true });
    return;
  }

  sendAttackAtWorld(wx, wy, mx, my);
});

// While holding the mouse button to attack, stream aim updates to the server.
// This lets the player "drag" their aim without releasing the click.
window.addEventListener("mousemove", (e) => {
  if (!attackHoldDown) return;
  // Don't send aim updates while interacting with the in-canvas editor.
  if (editorOpen) return;
  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);
  sendAttackHoldAim(wx, wy, mx, my);
});



window.addEventListener("mousemove", (e) => {
  if (!monsterBookOpen || !bookDragging) return;
  const { mx, my } = getMouseCanvasFromEvent(e);

  bookWinX = Math.round(mx - bookDragOffX);
  bookWinY = Math.round(my - bookDragOffY);

  // keep on-screen
  bookWinX = clamp(bookWinX, 8, canvas.width - bookWinW - 8);
  bookWinY = clamp(bookWinY, 8, canvas.height - bookWinH - 8);
});



window.addEventListener("wheel", (e) => {
  if (!monsterBookOpen || !bookUI) return;
  const { mx, my } = getMouseCanvasFromEvent(e);
  const c = bookUI.content;
  if (!c) return;
  if (mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
    e.preventDefault();
    bookScrollY = clamp(bookScrollY + e.deltaY, 0, bookUI.maxScroll || 0);
  }
}, { passive: false });


window.addEventListener("mouseup", (e) => {
  // Stop hold-to-attack on left button release.
  if (attackHoldDown && (!e || e.button === 0)) {
    attackHoldDown = false;
    sendAttackHoldStop();
  }

  invDragging = false;
  skillsDragging = false;
  bookDragging = false;

  // Finish HUD / hotbar reposition drags (Ctrl-drag).
  if (draggingHudBar || draggingHotbarBar) {
    draggingHudBar = false;
    draggingHotbarBar = false;
    saveUiLayout();
  }

  // Cancel any inventory drag if the mouse is released outside the canvas.
  if (draggingInv) {
    draggingInv = null;
    invPointerDownSlot = null;
    invPointerDownShift = false;
  }

  // Complete or cancel hotbar drags on mouse release.
  if (draggingHotbar) {
    const from = draggingHotbar.index;
    if (typeof from === "number") {
      if (uiMouse && uiMouse.has) {
        const hit = getHotbarSlotHit(uiMouse.mx, uiMouse.my);
        if (!hit) {
          // Dropped off the bar -> clear the assignment.
          hotbarSlots[from] = null;
          queueHotbarSync();
        } else {
          const to = hit.index;
          if (to !== from) {
            const tmp = hotbarSlots[to];
            hotbarSlots[to] = hotbarSlots[from];
            hotbarSlots[from] = tmp;
            queueHotbarSync();
          }
        }
      } else {
        // Mouseup occurred away from the canvas – treat as clearing the slot.
        hotbarSlots[from] = null;
        queueHotbarSync();
      }
    }
    draggingHotbar = null;
  }

  // In all cases, clear any pressed-hotbar state.
  hotbarPointerDownIndex = null;
});

/* ======================
   SMOOTH POS
====================== */
function getSmoothedPos(id, rawX, rawY) {
  const s = netState.get(id);
  if (!s) return { x: rawX, y: rawY };

  const renderTime = performance.now() / 1000 - INTERP_DELAY;

  const t0 = s.prev.t;
  const t1 = s.curr.t;

  let alpha = 0;
  if (t1 > t0) alpha = clamp((renderTime - t0) / (t1 - t0), 0, 1);
  alpha = easeInOut(alpha);

  let x = lerp(s.prev.x, s.curr.x, alpha);
  let y = lerp(s.prev.y, s.curr.y, alpha);

  if (renderTime > t1) {
    const extra = clamp(renderTime - t1, 0, 0.10);
    x = s.curr.x + s.vx * extra;
    y = s.curr.y + s.vy * extra;
  }

  const SMOOTHING = 0.15;
  s.smoothX = lerp(s.smoothX, x, SMOOTHING);
  s.smoothY = lerp(s.smoothY, y, SMOOTHING);

  return { x: s.smoothX, y: s.smoothY };
}

function getMyPos() {
  if (!myId) return null;
  const raw = worldPlayers[myId];
  if (!raw) return null;
  return getSmoothedPos(myId, raw.x, raw.y);
}

function getMyStats() {
  const raw = myId ? worldPlayers[myId] : null;
  return {
    hp: raw?.hp ?? 0,
    maxHp: raw?.maxHp ?? 1,
    level: raw?.level ?? 1,
    xp: raw?.xp ?? 0,
    xpNext: raw?.xpNext ?? 1,
    gold: raw?.gold ?? 0,
    equippedWeaponId: raw?.equipment?.weapon ?? null,
  };
}


/* ======================
   CAMERA + SHAKE
====================== */
let camX = 0;
let camY = 0;

function getWorldSize() {
  if (!map) return { w: 0, h: 0 };
  return { w: map[0].length * TILE_SIZE, h: map.length * TILE_SIZE };
}

function updateCamera() {
  const me = getMyPos();
  if (!me || !map) return;

  const viewW = canvas.width;
  const viewH = canvas.height;
  const world = getWorldSize();

  let targetX = me.x - viewW / 2;
  let targetY = me.y - viewH / 2;

  targetX = clamp(targetX, 0, Math.max(0, world.w - viewW));
  targetY = clamp(targetY, 0, Math.max(0, world.h - viewH));

  const CAM_SMOOTH = 0.18;
  camX = lerp(camX, targetX, CAM_SMOOTH);
  camY = lerp(camY, targetY, CAM_SMOOTH);

  camX = Math.round(camX);
  camY = Math.round(camY);
}

function getShakeOffset() {
  if (performance.now() > screenShakeUntilMs) return { x: 0, y: 0 };
  const t = (screenShakeUntilMs - performance.now()) / 160;
  const mag = Math.max(0, screenShakeMag) * clamp(t, 0, 1);
  return {
    x: Math.round((Math.random() * 2 - 1) * mag),
    y: Math.round((Math.random() * 2 - 1) * mag)
  };
}

/* ======================
   DRAW MAP
====================== */
function drawMap() {
  if (!map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const tile = map[y][x];
      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);

      
// Special case: animated water (4-frame atlas)
if (tile === AUTO_WATER_TILE && autotileWaterImg && autotileWaterImg.complete && autotileWaterImg.naturalWidth > 0) {
  const cellW = TILE_SIZE + TILE_PAD;
  const t = performance.now() * 0.001;

  // Add a stable per-tile phase so big lakes don't look perfectly synchronized.
  const phase = autoWaterPhase01(x, y) * AUTO_WATER_FRAMES; // 0..frames
  const frame = Math.floor(t * AUTO_WATER_FPS + phase) % AUTO_WATER_FRAMES;

  const sxW = frame * cellW;
  const syW = 0;
  ctx.drawImage(autotileWaterImg, sxW, syW, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
}
// Special case: 16-variant autotile (drawn from its own atlas)
else if (tile === AUTO_DIRTPATH_TILE && autotileDirtImg && autotileDirtImg.complete && autotileDirtImg.naturalWidth > 0) {
  const cell = TILE_SIZE + TILE_PAD;
  const mask = autoDirtPathMaskAt(x, y); // 0..15
  const col = mask % AUTO_DIRTPATH_COLS;
  const row = Math.floor(mask / AUTO_DIRTPATH_COLS);
  const sx = col * cell;
  const sy = row * cell;
  ctx.drawImage(autotileDirtImg, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
} else if (tileImage.complete && tileImage.naturalWidth > 0) {
  const cell = TILE_SIZE + TILE_PAD;
  const col = tile % TILESET_COLS;
  const row = Math.floor(tile / TILESET_COLS);
  const sx = col * cell;
  const sy = row * cell;
  ctx.drawImage(tileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
} else {
        ctx.fillStyle = isSolid(tile) ? "#555" : "#2b2b2b";
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}


/* ======================
   OBJECT LAYER (tiles_objects.png)
====================== */
function objTileRow1Based(objTile) {
  // objTile is 1-based for tiles_objects.png (0 = empty)
  if (!objTile) return 0;
  const idx0 = objTile - 1; // 0-based index in the sheet
  const row0 = Math.floor(idx0 / TILESET_COLS);
  return row0 + 1; // 1-based row
}

// Odd rows (1,3,5,...) are canopy: passable, drawn in the canopy pass on top of players
function isObjCanopy(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 1);
}

// Even rows (2,4,6,...) are solid: blocks movement and is depth-sorted with entities

function groundTileRow1Based(tile) {
  if (tile == null || tile < 0) return 0;
  const row0 = Math.floor(tile / TILESET_COLS);
  return row0 + 1;
}
function isSolid(tile) {
  const r = groundTileRow1Based(tile);
  return r > 0 && (r % 2 === 0);
}

function tileAtWorld(wx, wy) {
  if (!map) return WALL_TILE;
  const tx = Math.floor(wx / TILE_SIZE);
  const ty = Math.floor(wy / TILE_SIZE);
  if (ty < 0 || ty >= map.length) return WALL_TILE;
  if (tx < 0 || tx >= map[0].length) return WALL_TILE;
  return map[ty][tx] | 0;
}

function objAtWorld(wx, wy) {
  if (!objMap) return 0;
  const tx = Math.floor(wx / TILE_SIZE);
  const ty = Math.floor(wy / TILE_SIZE);
  if (ty < 0 || ty >= objMap.length) return 0;
  if (tx < 0 || tx >= objMap[0].length) return 0;
  return objMap[ty][tx] | 0;
}

function isBlockedWorld(wx, wy) {
  return isSolid(tileAtWorld(wx, wy)) || isObjSolid(objAtWorld(wx, wy));
}

function isObjSolid(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 0);
} 

function drawSkill1Overlays() {
  const me = worldPlayers[myId];
  if (!me) return;

  // (Targeting radius outline removed — animation is now the only indicator.)

  // Active whirlpools (server)
  if (whirlpools && whirlpools.length) {
    for (const w of whirlpools) {
const cx = w.x;
const cy = w.y;
const r = w.rad || SKILL1_EFFECT_RADIUS_PX;

// Use epoch time for server-authored startMs/endMs (they are serverNowMs()-based)
const nowAbsMs = serverNowMs();
const elapsed = Math.max(0, nowAbsMs - (w.startMs || nowAbsMs));

// Animated black hole spritesheet (8 frames, vertical strip)
const pulse = 0.92 + 0.08 * Math.sin(elapsed * 0.006);
const size = r * 2;

ctx.save();
ctx.translate(cx, cy);

if (blackholeImg.complete && blackholeImg.naturalWidth > 0) {
  const frame = Math.floor(elapsed / SKILL1_BLACKHOLE.frameMs) % SKILL1_BLACKHOLE.frames;
  const sx = 0;
  const sy = frame * SKILL1_BLACKHOLE.frameH;

  ctx.globalAlpha = 0.92 * pulse;

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(
    blackholeImg,
    sx, sy, SKILL1_BLACKHOLE.frameW, SKILL1_BLACKHOLE.frameH,
    -size / 2, -size / 2, size, size
  );

  // subtle inner glow
  ctx.globalAlpha = 0.18 * pulse;
  ctx.fillStyle = "rgba(255, 255, 255, 1)";
  ctx.beginPath();
  ctx.arc(0, 0, Math.max(0, r - 18), 0, Math.PI * 2);
  ctx.fill();
} else {
  // Fallback (if the sprite isn't loaded yet): simple soft dot
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "rgba(0,0,0,1)";
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();
}

ctx.restore();

}
  }
}

// 1=tree canopy

function drawObjectTile(objTile, px, py) {
  if (!objTile) return;
  const cell = TILE_SIZE + TILE_PAD;
  const idx = objTile - 1; // object tiles use 1-based ids; 0=empty
  const col = idx % TILESET_COLS;
  const row = Math.floor(idx / TILESET_COLS);
  const sx = col * cell;
  const sy = row * cell;

  if (objTileImage.complete && objTileImage.naturalWidth > 0) {
    ctx.drawImage(objTileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
  } else {
    // fallback
    ctx.fillStyle = isObjCanopy(objTile) ? "#1f6" : "#888";
    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
  }
}

function drawObjects(pass) {
  if (!objMap || !map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const t = objMap[y][x];
      if (!t) continue;

      const canopy = isObjCanopy(t);
      if (pass === "below" && canopy) continue;
      if (pass === "canopy" && !canopy) continue;

      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);
      drawObjectTile(t, px, py);
    }
  }
}

/* ======================
   PORTAL + PROMPT
====================== */
function isOnPortal() {
  const me = getMyPos();
  if (!me) return false;
  // Use the same "feet" anchor as collision/sorting so you're standing on the portal tile.
  const tx = Math.floor(me.x / TILE_SIZE);
  const ty = Math.floor((me.y + DBG_PLAYER_FOOT_Y) / TILE_SIZE);
  if (!Number.isFinite(tx) || !Number.isFinite(ty)) return false;
  return Array.isArray(portals) && portals.some(p => p && p.x === tx && p.y === ty);
}
function drawPrompt(near, text = "Press E", spriteH = PLAYER_FRAME_H) {
  const anchor = snap2(near.x, near.y);

  ctx.font = "14px system-ui";
  ctx.textBaseline = "middle";
  const padding = 6;
  const w = Math.ceil(ctx.measureText(text).width + padding * 2);
  const h = 22;

  const x = Math.round(anchor.x - w/2);
  const y = Math.round(anchor.y - spriteH/2 - 18 - h);

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + padding, y + h/2);
}

/* ======================
   SPRITE ANIM
====================== */
const DIR = { DOWN:0, LEFT:1, RIGHT:2, UP:3 };
const animState = new Map();

function getAnim(id, x, y) {
  if (!animState.has(id)) {
    animState.set(id, { lastX:x, lastY:y, dir:DIR.DOWN, frame:0, walkT:0, sinceMove:999, dirLock:0, idleT:0, idleFrame:0 });
  }
  return animState.get(id);
}

function dirFromInput() {
  const h = (keys.right ? 1 : 0) + (keys.left ? -1 : 0);
  const v = (keys.down ? 1 : 0) + (keys.up ? -1 : 0);

  if (h !== 0 && v === 0) return h > 0 ? DIR.RIGHT : DIR.LEFT;
  if (v !== 0 && h === 0) return v > 0 ? DIR.DOWN : DIR.UP;
  return null;
}

function updateAnim(id, x, y, dt) {
  const st = getAnim(id, x, y);

  const dx = x - st.lastX;
  const dy = y - st.lastY;
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);

  const moved = (ax + ay) > 0.02;
  st.dirLock = Math.max(0, st.dirLock - dt);

  if (moved) {
    if (id === myId) {
      // Don't let movement inputs overwrite facing while we're in a locked swing direction.
      if (st.dirLock <= 0) {
        const d = dirFromInput();
        if (d != null) st.dir = d;
      }
    } else {
      const DOM = 1.6;
      const LOCK = 0.14;

      let cand = st.dir;
      if (ax > ay * DOM) cand = dx >= 0 ? DIR.RIGHT : DIR.LEFT;
      else if (ay > ax * DOM) cand = dy >= 0 ? DIR.DOWN : DIR.UP;

      if (cand !== st.dir && st.dirLock <= 0) {
        st.dir = cand;
        st.dirLock = LOCK;
      }
    }
  }

  if (moved) st.sinceMove = 0;
  else st.sinceMove += dt;

  const moving = (id === myId)
    ? (keys.left || keys.right || keys.up || keys.down)
    : (st.sinceMove < 0.22);

  if (moving) {
    st.walkT += dt;
    // 4-step cadence: 1,2,1,3
    st.frame = WALK_SEQ[Math.floor(st.walkT * 8) % WALK_SEQ.length];
    st.idleT = 0;
    st.idleFrame = 0;
  } else {
    st.frame = 0;
    st.walkT = 0;

    // idle cadence (2 frames, slow)
    st.idleT += dt;
    if (st.idleT >= IDLE_FRAME_TIME) {
      st.idleT = 0;
      st.idleFrame = 1 - (st.idleFrame || 0);
    }
  }

  st.lastX = x;
  st.lastY = y;
  return st;
}

function drawSprite(img, x, y, dirRow, frameCol, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;
  x = Math.round(x); y = Math.round(y);
  const sx = frameCol * frameW;
  const sy = dirRow * frameH;
  const dx = x - frameW / 2;
  const dy = y - frameH / 2;
  ctx.drawImage(img, sx, sy, frameW, frameH, dx, dy, frameW, frameH);
}

/* ======================
   HIT FLASH (sprite-only)
====================== */
function drawHitTintOnTop(img, x, y, dirRow, frameCol, rgbaColor, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;

  x = Math.round(x); y = Math.round(y);

  const sx = frameCol * frameW;
  const sy = dirRow * frameH;

  const { c: fxCanvas, ctx: fxCtx } = getFxCtx(frameW, frameH);

  // draw sprite frame into offscreen
  fxCtx.clearRect(0, 0, frameW, frameH);
  fxCtx.drawImage(img, sx, sy, frameW, frameH, 0, 0, frameW, frameH);

  // tint only the non-transparent pixels
  fxCtx.globalCompositeOperation = "source-atop";
  fxCtx.fillStyle = rgbaColor;
  fxCtx.fillRect(0, 0, frameW, frameH);
  fxCtx.globalCompositeOperation = "source-over";

  const dx = x - frameW / 2;
  const dy = y - frameH / 2;

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(fxCanvas, 0, 0, frameW, frameH, dx, dy, frameW, frameH);
  ctx.restore();
}

/* ======================
   ATTACK VISUALS
====================== */

function drawSwordSlash(x, y, dir, phase01, swordImg, atkKind = null) {
  // Sword slash: uses the equipped sword overlay image and a wide arc "swish".
  // Visual-only; server controls actual hit logic.
  x = Math.round(x); y = Math.round(y);

  const t = clamp(phase01, 0, 1);

  // Hand anchor (shared with held sword)
  const hand = getSwordHand(dir);
  const px = x + hand.x;
  const py = y + hand.y;

  // Attack-only nudge: adjust the slash position without changing the idle/held placement.
  // (Keeps held sword natural, fixes DOWN slash drifting away from the body.)
  let nudgeX = 0, nudgeY = 0;
  if (dir === DIR.DOWN) { nudgeX = 4; nudgeY = -4; }


  // Swing profile: quick accel -> follow-through -> return
  function easeOutCubic(u) { return 1 - Math.pow(1 - u, 3); }
  function easeInOut(u) { return u * u * (3 - 2 * u); }

  // Build a swing angle for each direction.
  // Angles are in radians, measured from +X axis.
  // We sweep a wide arc (about 120°) to feel distinct from spear thrust.
  const sweep = (Math.PI * 2) / 3; // 120°

  // Timing/feel tweak:
  // - Spend MORE of the animation budget on the main swing (slower, smoother arc)
  // - Spend LESS on the end "bounce"/settle (snappier finish)
  const SWING_T = 0.75;   // portion of time used for the main swing
  const SWING_U = 0.92;   // portion of arc completed by the end of the swing

  let u;
  if (t < SWING_T) {
    // Main swing: ease-in-out so it doesn't snap instantly.
    u = easeInOut(t / SWING_T) * SWING_U;
  } else {
    // Quick settle: finish the last bit fast + a tiny overshoot that returns by the end.
    const v = clamp((t - SWING_T) / (1 - SWING_T), 0, 1);
    const base = SWING_U + (1 - SWING_U) * easeOutCubic(v);
    const bounce = 0.05 * Math.sin(Math.PI * v) * (1 - v); // small, fast "bounce"
    u = base + bounce;
  }

  // u goes 0..~1 with a brief overshoot during the settle phase.
// Base angles (start -> end) per facing direction
  let a0 = 0, a1 = 0;
  if (dir === DIR.RIGHT) { a0 = -Math.PI/3; a1 = a0 + sweep; }
  else if (dir === DIR.LEFT) { a0 = Math.PI + Math.PI/3; a1 = a0 - sweep; }
  else if (dir === DIR.DOWN) { a0 = Math.PI/2 - Math.PI/3; a1 = a0 + sweep; }
  else { // UP
    a0 = -Math.PI/2 + Math.PI/3; a1 = a0 - sweep;
  }

  const ang = a0 + (a1 - a0) * clamp(u, 0, 1.06); // allow tiny overshoot for the bounce

  // Base geometry for the blade + arc so Skill 4 can scale it up cleanly
  const baseReach = 18;
  const baseR = 30;
  const baseW = 32;
  const baseH = 64;
  const baseGripX = 16;
  const baseGripY = 50;

  const scale = (atkKind === "skill4") ? 1.4 : 1.0;

  // Slight outward reach so the blade clears the body
  const reach = baseReach * scale;
  const ox = Math.cos(ang) * reach;
  const oy = Math.sin(ang) * reach;

  // --- Draw the "swish" arc (behind the blade slightly) ---
  ctx.save();
  ctx.translate(px + nudgeX, py + nudgeY);
  ctx.globalAlpha = (t < 0.12) ? (t / 0.12) : (t > 0.9 ? (1 - (t - 0.9) / 0.1) : 1);
  ctx.globalAlpha *= 0.55;

  const r = baseR * scale;
  const start = a0;
  const end = ang;

  ctx.lineWidth = 6;
  ctx.lineCap = "round";
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath();
  // For LEFT/UP we may have end < start; arc handles it but we want a consistent path.
  ctx.arc(0, 0, r, start, end, (dir === DIR.LEFT || dir === DIR.UP));
  ctx.stroke();

  // faint outer arc
  ctx.globalAlpha *= 0.5;
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.beginPath();
  ctx.arc(0, 0, r + 6, start, end, (dir === DIR.LEFT || dir === DIR.UP));
  ctx.stroke();

  ctx.restore();

  // --- Draw the sword sprite as the blade sweeping through the arc ---
  const img = swordImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px + ox + nudgeX, py + oy + nudgeY);
  ctx.rotate(ang + Math.PI/2); // make the blade generally point outward from the hand

  // Mirror for LEFT so the grip stays in the hand
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  const W = baseW * scale, H = baseH * scale;
  const gripX = baseGripX * scale;
  const gripY = baseGripY * scale;

  ctx.imageSmoothingEnabled = false;
  if (ready) {
    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  } else {
    // fallback blade
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-1, -44, 2, 40);
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-6, -10, 12, 6);
  }

  ctx.restore();
}

function drawSpearThrust(x, y, dir, phase01, spearImg, playerId) {
  // Image-based spear thrust. Uses /assets/basic_spear.png (16x32, centered).
  // Visual-only; does not affect hit/collision logic.
  x = Math.round(x); y = Math.round(y);

  // --- Motion profile ---
  // Idea 1) "Slow start" (ease-in) so the first part feels weighted.
  // Idea 2) Brief linger at max extension, then retract a touch.
  const t = clamp(phase01, 0, 1);

  const OUT  = 0.55; // time to extend
  const HOLD = 0.18; // linger at full extension
  const BACK = 1 - OUT - HOLD; // time to retract

  function easeInCubic(u) { return u * u * u; }
  function easeSmooth(u) { return u * u * (3 - 2 * u); } // same as easeInOut()

  let prog = 0; // 0..1 extension amount
  if (t < OUT) {
    const u = clamp(t / OUT, 0, 1);
    prog = easeInCubic(u);          // slow start, fast finish
  } else if (t < OUT + HOLD) {
    prog = 1;                       // linger at max
  } else {
    const u = clamp((t - OUT - HOLD) / BACK, 0, 1);
    prog = 1 - 0.18 * easeSmooth(u); // retract ~18% so it doesn't "snap off"
  }

  const MAX_THRUST = 28;            // pixels pushed outward
  const thrust = prog * MAX_THRUST; // allow sub-pixel movement for smoother motion

  // Side-thrust curve: dip down mid-thrust, return to center.
  // Only applies when facing LEFT/RIGHT (screen-down is positive Y).
  const dipPx = 3; // tweak: 0..8
  const curveY = (dir === DIR.LEFT || dir === DIR.RIGHT)
    ? (dipPx * Math.sin(Math.PI * prog))
    : 0;

  // Use the shared spear-hand anchor so the thrust lines up with the held spear.
  const hand = getSpearHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  // If the sprite isn't loaded yet, fall back to a simple rectangle spear so nothing breaks.
  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  // Move outward along the facing direction (in world space).
  // We apply thrust before rotation by translating in direction coords.
  if (dir === DIR.RIGHT) ctx.translate(thrust, curveY);
  if (dir === DIR.LEFT)  ctx.translate(-thrust, curveY);
  if (dir === DIR.DOWN)  ctx.translate(0, thrust);
  if (dir === DIR.UP)    ctx.translate(0, -thrust);

  ctx.rotate(ang);

  // Skill 2 (Double Stab) visual: temporarily scale spear and add a slight "jut" angle.
  // This is purely visual; server is authoritative for damage.
  let extraScale = 1;
  let extraAng = 0;
  let extraSide = 0;

  const sid = (playerId != null) ? String(playerId) : null;
  const fx = sid ? skill2FxByCaster.get(sid) : null;
  if (fx && typeof fx.startMs === "number") {
    const tAbs = serverNowMs() - fx.startMs;
    if (tAbs >= 0 && tAbs <= SKILL2_VIS_MS) {
      // Two windows: stab 0 then stab 1
      const stabIndex = (tAbs < SKILL2_GAP_MS) ? 0 : 1;
      extraScale = 1.25;
      extraAng = (stabIndex === 0 ? -1 : 1) * (Math.PI / 28);
      // tiny sideways "jut" so the thrust isn't perfectly straight
      const w = Math.sin(Math.min(1, (tAbs % SKILL2_GAP_MS) / SKILL2_GAP_MS) * Math.PI);
      extraSide = (stabIndex === 0 ? -1 : 1) * (2.5 * w);
    }
    if (tAbs > SKILL2_VIS_MS + 200) skill2FxByCaster.delete(sid);
  }

  // Visual "reach": stretch spear length during thrust (LEFT/RIGHT only) without pushing the grip away.
  let lenScale = 1;
  if (dir === DIR.LEFT || dir === DIR.RIGHT) {
    const STRETCH_MAX = 0.25; // tweak: 0.20..0.50
    lenScale = 1 + STRETCH_MAX * prog;
  }

  ctx.rotate(extraAng);
  if (extraScale !== 1 || lenScale !== 1) ctx.scale(extraScale, extraScale * lenScale);
  if (extraSide !== 0) ctx.translate(extraSide, 0);

  // NOTE: We avoid uniform spear scaling; only a length-stretch (Y) for LEFT/RIGHT thrust feel.
  // We draw at the sprite's native resolution (or a 32x64 fallback) so the spear art controls its own size.
  if (ready) {
    const w = img.naturalWidth || 32;
    const h = img.naturalHeight || 64;
    // Grip near the bottom-center of the sprite.
    const gripX = Math.round(w / 2);
    const gripY = Math.round(h * 0.82);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, w, h);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}



function drawSpearHeld(x, y, dir, spearImg) {
  // Persistent spear when equipped (not attacking).
  // Uses the same /assets/basic_spear.png sprite as the thrust, but with no thrust motion.
  x = Math.round(x); y = Math.round(y);

  // Same anchor as the thrust so it stays “in the hands”.
  const hand = getSpearHand(dir);

  const px = x + hand.x;
  const py = y + hand.y;

  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  ctx.rotate(ang);

  // IMPORTANT: no spear scaling.
  // Draw at native sprite size (or 32x64 fallback) so it matches your actual spear art.
  if (ready) {
    const w = img.naturalWidth || 32;
    const h = img.naturalHeight || 64;
    const gripX = Math.round(w / 2);
    const gripY = Math.round(h * 0.82);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, w, h);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}


function drawWandCast(x, y, dir, phase01, wandImg) {
  // Animated wand casting: small lift + tilt based on direction, plus the existing spark.
  x = Math.round(x); y = Math.round(y);

  const t = clamp(phase01 || 0, 0, 1);
  const pulse = 1 - Math.abs(t - 0.5) * 2; // 0 -> 1 -> 0 over the swing

  // Reuse the same hand anchors as drawWandHeld so it lines up with the hands.
  const hand = ({
    [DIR.RIGHT]: { x: -6,  y: 20 },
    [DIR.LEFT]:  { x:  6,  y: 20 },
    [DIR.DOWN]:  { x: -12, y: 20 },
    [DIR.UP]:    { x:  10, y: 20 },
  }[dir] || { x: 0, y: 0 });

  const px = x + hand.x;
  const py = y + hand.y;

  const img = wandImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Mirror for LEFT so art stays consistent.
  if (dir === DIR.LEFT) ctx.scale(-1, 1);

  // Lift the wand slightly at peak of the cast.
  const lift = -Math.round(pulse * 6);
  ctx.translate(0, lift);

  // Subtle tilt during the cast.
      const maxTilt = Math.PI / 14;
      let tilt = 0;
      // Use the same tilt for LEFT and RIGHT; mirroring is handled by scale(-1,1) for LEFT.
      const sideTilt = maxTilt * pulse;
      if (dir === DIR.RIGHT || dir === DIR.LEFT) {
        tilt = sideTilt;
      } else if (dir === DIR.DOWN) {
        // No tilt when facing down; just use vertical lift.
        tilt = 0;
      } else {
        // UP
        tilt = -maxTilt * 0.7 * pulse;
      }
      ctx.rotate(tilt);

  const W = 32, H = 64;
  const gripX = 16;
  const gripY = 52;

  ctx.imageSmoothingEnabled = false;
  if (ready) {
    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, -gripX, -gripY, W, H);
  } else {
    // Fallback: simple staff
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -50, 4, 48);
    ctx.fillStyle = "#bde0fe";
    ctx.fillRect(-4, -54, 8, 6);
  }

  ctx.restore();

  
}




/* ======================
   PROJECTILE DRAW
====================== */
function drawProjectile(pr) {
  const x = Math.round(pr.x);
  const y = Math.round(pr.y);

  // Try sprite-based rendering first
  const key = pr.sprite || null;
  const img = key ? (projectileSprites[key] || null) : null;

  if (img && img.complete && img.naturalWidth > 0) {
    const rad = (pr.rad ?? 10);
    // Slightly larger than hit radius so it reads well visually
    const w = Math.max(12, Math.round(rad * 2.2));
    const h = w;

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, Math.round(x - w / 2), Math.round(y - h), w, h);
    ctx.restore();
    return;
  }

  // Fallback: simple bolt (keeps working even if the image is missing)
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x - 5, y - 5, 10, 10);

  ctx.fillStyle = "#9bf6ff";
  ctx.fillRect(x - 3, y - 3, 6, 6);

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(x - 1, y - 1, 2, 2);
  ctx.restore();
}


/* ======================
   SKILL 5: FAMILIAR (client-only visuals)
====================== */
function _hashStr32(s) {
  // Tiny deterministic hash for stable per-player orbit offsets
  s = String(s || "");
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}


function getFamiliarRenderState(ownerId, ownerPos, targetMob, targetPos, dt) {
  const key = ownerId;
  let st = familiarStates.get(key);
  if (!st) {
    st = {
      x: ownerPos.x,
      y: ownerPos.y - 32,
      orbitAngle: 0,
    };
    familiarStates.set(key, st);
  }

  const hasTarget = !!(targetMob && !targetMob.dead && !(targetMob.corpseMs > 0));
  let anchorX, anchorY;
  if (hasTarget && targetPos) {
    anchorX = targetPos.x;
    anchorY = targetPos.y - 26;
  } else {
    anchorX = ownerPos.x;
    anchorY = ownerPos.y - 32;
  }

  const speed = 260; // travel speed for flying between player/targets
  const dx = anchorX - st.x;
  const dy = anchorY - st.y;
  const dist = Math.hypot(dx, dy) || 1;
  const maxStep = speed * dt;

  if (dist > maxStep) {
    const t = maxStep / dist;
    st.x += dx * t;
    st.y += dy * t;
  } else {
    st.x = anchorX;
    st.y = anchorY;
  }

  // When close to anchor, add a small orbit wobble
  const near = 24;
  if (dist < near) {
    const baseAngSpeed = hasTarget ? 3.0 : 2.2;
    st.orbitAngle += baseAngSpeed * dt;
    const radiusX = hasTarget ? 14 : 18;
    const radiusY = hasTarget ? 6 : 8;
    const ox = Math.cos(st.orbitAngle) * radiusX;
    const oy = Math.sin(st.orbitAngle) * radiusY;
    st.x = anchorX + ox;
    st.y = anchorY + oy;
  }

  const isTargeting = hasTarget;
  const tX = (hasTarget && targetPos) ? targetPos.x : null;
  const tY = (hasTarget && targetPos) ? (targetPos.y - 6) : null;

  return { x: st.x, y: st.y, isTargeting, tX, tY };
}

function drawFamiliarOrb(x, y, isTargeting, tX = null, tY = null) {
  ctx.save();
  x = Math.round(x);
  y = Math.round(y);

  const now = performance.now();
  const pulseT = Math.max(0, familiarHitPulseUntilMs - now);
  const pulsePhase = pulseT > 0 ? (pulseT / 220) : 0; // 0..1
  const pulseScale = 1 + pulsePhase * 0.35;          // up to ~1.35x on hit
  const pulseAlphaBoost = 0.3 * pulsePhase;

  // Slight size bump when it's actively targeting something
  const baseSize = 28;          // sprite is 28x28
  const baseCoreSize = isTargeting ? 30 : baseSize;
  const size = baseCoreSize * pulseScale;
  const half = size / 2;

  // Soft glow behind the orb (keeps the old “magic light” feel)
  const glowR = size * 0.7;
  const glow = ctx.createRadialGradient(x, y, 0, x, y, glowR);
  const innerAlpha = 0.9 + pulseAlphaBoost; // brighter on hit
  glow.addColorStop(0, `rgba(255,255,255,${innerAlpha.toFixed(2)})`);
  glow.addColorStop(1, "rgba(80,200,255,0.0)");
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(x, y, glowR, 0, Math.PI * 2);
  ctx.fill();

  // Main sprite
  const img = familiarOrbImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  if (ready) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(
      img,
      0, 0, img.naturalWidth, img.naturalHeight,
      Math.round(x - half),
      Math.round(y - half),
      size,
      size
    );
  } else {
    // Fallback: simple orb if the sprite hasn't loaded yet
    const baseR = 7 * pulseScale;
    const pulse = 1 + Math.sin(now / 160) * 0.25;
    const r = baseR * pulse;

    const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
    grd.addColorStop(0, "rgba(255,255,255,0.95)");
    grd.addColorStop(1, "rgba(80,200,255,0.0)");
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "rgba(180,230,255,0.85)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  // No explicit tether line; sparkle trail + pulse handle feedback.

  ctx.restore();
}

function drawHealingCloud(e, nowAbsMs) {
  if (!e || !healingCloudImg) return;

  const img = healingCloudImg;
  const ready = img && img.complete && img.naturalWidth > 0;
  const nowUi = performance.now();

  // Approximate "time since spawned" using the known fixed duration and the
  // server-supplied end timestamp, so we get a nice ease-in/out without needing
  // extra per-client state.
  const lifeMs = SKILL6_CLOUD_ACTIVE_MS;
  let elapsedMs = 0;
  if (e.endAbsMs && typeof e.endAbsMs === "number") {
    const remaining = Math.max(0, e.endAbsMs - nowAbsMs);
    elapsedMs = Math.max(0, Math.min(lifeMs, lifeMs - remaining));
  }

  // Fade-in (and slight pop/scale-in) based on HEALING_CLOUD_FADE_MS
  let baseAlpha = 1;
  let offsetY = HEALING_CLOUD_OFFSET_FINAL;
  let scale = 1;
  if (elapsedMs < HEALING_CLOUD_FADE_MS) {
    const tIn = HEALING_CLOUD_FADE_MS > 0 ? (elapsedMs / HEALING_CLOUD_FADE_MS) : 1;
    const easeIn = tIn * tIn * (3 - 2 * tIn); // smoothstep
    baseAlpha = easeIn;
    offsetY = HEALING_CLOUD_OFFSET_START +
      (HEALING_CLOUD_OFFSET_FINAL - HEALING_CLOUD_OFFSET_START) * easeIn;

    // Start slightly smaller and grow in
    const minScale = 0.75;
    scale = minScale + (1 - minScale) * easeIn;
  }

  // Fade-out + float-up near the end of life
  if (elapsedMs > lifeMs - HEALING_CLOUD_FADE_OUT_MS) {
    const raw = (lifeMs - elapsedMs) / HEALING_CLOUD_FADE_OUT_MS;
    const tOut = Math.max(0, Math.min(1, raw));
    const easeOut = tOut * tOut * (3 - 2 * tOut);
    baseAlpha *= easeOut;
    // Drift upward as it fades
    offsetY += (1 - easeOut) * HEALING_CLOUD_FLOAT_PIXELS;
  }

  // Gentle bob / pulse while the cloud is active and "floating"
  if (elapsedMs >= HEALING_CLOUD_FADE_MS &&
      elapsedMs <= lifeMs - HEALING_CLOUD_FADE_OUT_MS) {
    // Small vertical bobbing
    const bob = Math.sin(nowUi / 650) * 4; // px
    offsetY += bob;

    // Tiny scale pulse so it feels alive
    const pulse = 1 + Math.sin(nowUi / 900) * 0.03;
    scale *= pulse;
  }

  const alpha = Math.min(1.0, baseAlpha * 1.05);

  const x = Math.round(e.x);
  const y = Math.round(e.y - offsetY);

  const baseW = 128;
  const baseH = 64;
  const w = baseW * scale;
  const h = baseH * scale;
  const halfW = w / 2;
  const halfH = h / 2;

  ctx.save();

  // Soft shadow under the cloud at ground level (anchored to where it was cast)
  const groundY = e.y;
  const shadowY = groundY +  28;
  const shadowW = w * 0.55;
  const shadowH = 6;
  ctx.globalAlpha = alpha * 0.18;
  ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
  ctx.beginPath();
  ctx.ellipse(x, shadowY, shadowW / 2, shadowH / 2, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.imageSmoothingEnabled = false;
  ctx.globalAlpha = alpha;

  if (ready) {
    ctx.drawImage(
      img,
      0,
      0,
      img.naturalWidth,
      img.naturalHeight,
      x - halfW,
      y - halfH,
      w,
      h
    );
  } else {
    // Simple placeholder rectangle if the sprite isn't ready yet
    ctx.fillStyle = "rgba(180,180,255,0.55)";
    ctx.fillRect(x - halfW, y - halfH, w, h);
  }

  // Very light rain indication – falling drops under the cloud, hitting near the shadow.
// Start raining only after the cloud has fully floated up (post fade-in).
if (elapsedMs >= HEALING_CLOUD_FADE_MS) {
  const rainSpan = w * 0.6;
  const rainStartX = x - rainSpan / 2;
  const rainGroundY = groundY +  28;
  const rainEndY = rainGroundY;

  ctx.strokeStyle = "rgba(200,230,255,0.95)";
  ctx.lineWidth = 1.6;

  const drops = 14;
  const travel = (rainEndY - (y + halfH - 10)); // vertical distance a drop travels
  const cycleMs = 700; // time for a drop to fall from top to bottom

  for (let i = 0; i < drops; i++) {
    const px = rainStartX + (rainSpan * i) / (drops - 1);
    const noiseX = Math.sin((nowUi / 260) + i * 1.11) * 2;
    const phase = ((nowUi + i * 90) % cycleMs) / cycleMs; // 0..1 over the cycle

    const dropHeadY = (y + halfH - 10) + phase * travel;
    const dropTailY = dropHeadY - 10;

    const dropX = px + noiseX;

    // Clamp so drops don't render below the ground line
    const headY = Math.min(dropHeadY, rainEndY);
    const tailY = Math.min(dropTailY, headY);

    // Main falling raindrop
    ctx.beginPath();
    ctx.moveTo(dropX, tailY);
    ctx.lineTo(dropX, headY);
    ctx.stroke();

    // Tiny splash when the drop is near the ground
    if (headY >= rainEndY - 1) {
      const splashY = rainEndY + 1;
      ctx.beginPath();
      ctx.moveTo(dropX - 2, splashY);
      ctx.lineTo(dropX, splashY - 2);
      ctx.lineTo(dropX + 2, splashY);
      ctx.stroke();
    }
  }
}

  ctx.restore();
}

/* ======================
   COIN DRAW
====================== */
function drawCoin(x, y, amount) {
  // Treat (x, y) as the ground contact point. The coin sprite's bottom
  // sits on y, so tall items and coins share the same "foot" position.
  x = Math.round(x);
  y = Math.round(y);

  const size = 24;
  const top = y - size;
  const left = x - size / 2;

  ctx.save();

  const img = equipIcons && equipIcons.coin;
  if (img && img.complete && img.naturalWidth > 0) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(
      img,
      Math.round(left),
      Math.round(top),
      size,
      size
    );
  } else {
    // Fallback: simple pixel coin if the image isn't loaded yet.
    const iLeft = Math.round(left);
    const iTop = Math.round(top);
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(iLeft + 2, iTop + 2, size - 4, size - 4);

    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(iLeft + 4, iTop + 4, size - 8, size - 8);
    ctx.fillStyle = "#ffd966";
    ctx.fillRect(iLeft + 6, iTop + 6, size - 12, size - 12);
  }

  ctx.restore();
}


var itemSprites = {
  orange_flan: new Image(),
  potion_green: new Image(),
  potion_purple: new Image(),
};

itemSprites.orange_flan.src  = "/assets/items/orange_flan.png";
itemSprites.potion_green.src = "/assets/items/potion_green.png";
itemSprites.potion_purple.src = "/assets/items/potion_purple.png";




function getWorldDropSprite(itemId) {
  // Prefer big held-weapon sprites for weapons so they look good on the ground.
  if (typeof swordSprites !== "undefined" && swordSprites && swordSprites[itemId]) {
    return swordSprites[itemId];
  }
  if (typeof spearSprites !== "undefined" && spearSprites && spearSprites[itemId]) {
    return spearSprites[itemId];
  }
  if (typeof wandSprites !== "undefined" && wandSprites && wandSprites[itemId]) {
    return wandSprites[itemId];
  }

  // Fallback to the same icon used in inventory/equipment; then dedicated drop sprites.
  if (typeof getItemIconImage === "function") {
    const icon = getItemIconImage(itemId);
    if (icon) return icon;
  }
  if (typeof itemSprites !== "undefined" && itemSprites) {
    return itemSprites[itemId] || null;
  }
  return null;
}


// ======================
// DROP ANIMATION HELPERS
// ======================
const DROP_SPAWN_HOP_MS = 260;    // duration of the initial hop (ms)
const DROP_HOP_HEIGHT   = 12;     // pixels of vertical hop
const DROP_BOB_AMPLITUDE = 3;     // ongoing bob amplitude (px)
const DROP_BOB_PERIOD_MS = 900;   // bob period (ms)
const DROP_PULSE_SCALE   = 0.06;  // +/- scale pulse after spawn

// Keep dropAnim in sync with snapshot data from the server.
function syncDropAnimFromSnapshot(dropsObj) {
  const nowUi = (typeof performance !== "undefined") ? performance.now() : Date.now();
  const seen = new Set();

  for (const [id, d] of Object.entries(dropsObj || {})) {
    seen.add(id);
    if (!dropAnim.has(id)) {
      dropAnim.set(id, {
        spawnUiMs: nowUi,
        seed: Math.random() * Math.PI * 2, // per-drop phase for bobbing
      });
    }
  }

  // Remove animation entries for drops that no longer exist
  for (const id of dropAnim.keys()) {
    if (!seen.has(id)) dropAnim.delete(id);
  }
}

// Compute current visual state (offset/scale) for a drop.
function getDropAnimState(id, d) {
  const nowUi = (typeof performance !== "undefined") ? performance.now() : Date.now();
  const anim = dropAnim.get(id);
  const spawnMs = anim ? anim.spawnUiMs : nowUi;
  const seed = anim ? anim.seed : 0;
  const age = Math.max(0, nowUi - spawnMs);

  let offsetY = 0;       // how many pixels to lift above the base y
  let scale   = 1.0;     // 1 = normal size

  if (age < DROP_SPAWN_HOP_MS) {
    // Initial hop: fast up then down (sin curve 0→π)
    const t = clamp(age / DROP_SPAWN_HOP_MS, 0, 1);
    const hop = Math.sin(t * Math.PI); // 0 → 1 → 0
    offsetY = DROP_HOP_HEIGHT * hop;
    scale   += 0.12 * hop;             // tiny scale pop
  } else {
    // Gentle idle bob after the hop finishes
    const tBob = (age - DROP_SPAWN_HOP_MS) / DROP_BOB_PERIOD_MS;
    const bob = Math.sin(tBob * Math.PI * 2 + seed);
    offsetY = DROP_BOB_AMPLITUDE * bob;
    scale   += DROP_PULSE_SCALE * bob;
  }

  return { offsetY, scale };
}

function drawItemDrop(itemId, x, y, scale = 1) {
  const img = getWorldDropSprite(itemId);
  if (!img || !img.complete || img.naturalWidth <= 0) return;

  let baseW = img.naturalWidth;
  let baseH = img.naturalHeight;

  // For big weapon sprites, gently scale them down so they don't overwhelm the tile.
  const isWeaponSprite =
    (typeof swordSprites !== "undefined" && swordSprites && swordSprites[itemId]) ||
    (typeof spearSprites !== "undefined" && spearSprites && spearSprites[itemId]) ||
    (typeof wandSprites !== "undefined" && wandSprites && wandSprites[itemId]);

  if (isWeaponSprite) {
    const maxSize = 40;
    const s = Math.min(1, maxSize / Math.max(baseW, baseH));
    baseW = Math.round(baseW * s);
    baseH = Math.round(baseH * s);
  } else {
    // Non-weapons: keep a compact footprint.
    baseW = 32;
    baseH = 32;
  }

  const s2 = scale || 1;
  const w = Math.round(baseW * s2);
  const h = Math.round(baseH * s2);

  ctx.drawImage(img, Math.round(x - w / 2), Math.round(y - h), w, h);
}


/* ======================
   MOB HP BAR
====================== */
function drawHpBarWorld(x, y, hp, maxHp, spriteH = MOB_FRAME_H) {
  const w = 34, h = 6;
  const pct = clamp((maxHp ? hp / maxHp : 0), 0, 1);
  const bx = Math.round(x - w/2);
  const by = Math.round(y - spriteH/2 - 10);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(bx, by, w, h);
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(bx + 1, by + 1, Math.round((w - 2) * pct), h - 2);
}

/* ======================
   NPC INTERACTION
====================== */
let cachedNearestNpc = null;

function computeNearestNpc() {
  const me = getMyPos();
  if (!me) return null;

  let best = null;
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    const d = dist(me.x, me.y, pos.x, pos.y);
    if (d <= INTERACT_DIST && (!best || d < best.d)) best = { id, d, x: pos.x, y: pos.y, name: n.name || id };
  }
  return best;
}

function tryInteract() {
  if (!cachedNearestNpc) return;
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "interact", npcId: cachedNearestNpc.id }));
}

function drawDialogueBubble(d) {
  if (!d) return;
  if (performance.now() > d.untilMs) { activeDialogue = null; return; }

  const npcRaw = worldNpcs[d.npcId];
  if (!npcRaw) return;

  const npcPosF = getSmoothedPos(d.npcId, npcRaw.x, npcRaw.y);
  const npcPos = snap2(npcPosF.x, npcPosF.y);

  const lines = [`${d.npcName}:`, d.text];

  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";

  const padding = 8;
  let w = 0;
  for (const line of lines) w = Math.max(w, ctx.measureText(line).width);
  w = Math.ceil(w);

  const lineH = 18;
  const h = padding*2 + lineH*lines.length;

  let x = clamp(npcPos.x - w/2 - padding, camX + 8, camX + canvas.width - (w + padding*2) - 8);
  let y = clamp(npcPos.y - NPC_DRAW_H/2 - h - 18, camY + 8, camY + canvas.height - h - 8);

  x = Math.round(x);
  y = Math.round(y);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(x, y, w + padding*2, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w + padding*2 - 1, h - 1);

  ctx.fillStyle = "#fff";
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], x + padding, y + padding + i*lineH);
  }
}

/* ======================
   HUD
====================== */


function drawSkillHotbar() {
  // Bottom-left hotbar slots for Skill 1 and Skill 2
  const now = serverNowMs();
  const nowUi = performance.now();

  const slot = 48;
  const pad = 14;
  const gap = 10;

  const x0 = pad;
  const y0 = Math.round(canvas.height - pad - slot);

  function drawSlot(opts) {
    const {
      x0, y0,
      keyLabel,
      iconImg,
      isActive,
      activeUntilMs,
      activeTotalMs,
      cdUntilMs,
      cdTotalMs,
      nackUntilMs,
      shakeUntilMs,
      shakeSeed,
    } = opts;

    // Shake feedback
    let x = x0, y = y0;
    if (nowUi < shakeUntilMs) {
      const t = (shakeUntilMs - nowUi) / 1000;
      const amp = 4 * Math.min(1, t * 3); // px
      const sx = Math.sin((nowUi * 0.05) + shakeSeed) * amp;
      const sy = Math.cos((nowUi * 0.06) + shakeSeed * 2) * amp;
      x = x0 + sx;
      y = y0 + sy;
    }

    const isCd = now < cdUntilMs;
    const activeRem = Math.max(0, activeUntilMs - now);
    const cdRem = Math.max(0, cdUntilMs - now);

    // Base slot
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(x, y, slot, slot);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(x + 0.5, y + 0.5, slot - 1, slot - 1);

    // Icon
    const img = iconImg;
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.imageSmoothingEnabled = false;
      const iw = 32, ih = 32;
      ctx.drawImage(img, x + Math.round((slot - iw) / 2), y + Math.round((slot - ih) / 2), iw, ih);
    } else {
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(x + 14, y + 14, 20, 20);
    }

    // Key label
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(x + 2, y + 2, 14, 14);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.strokeRect(x + 2.5, y + 2.5, 13, 13);
    ctx.fillStyle = "#fff";
    ctx.font = "12px system-ui";
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillText(String(keyLabel), x + 9, y + 9);

    // State overlays
    if (isActive || isCd) {
      const rem = isActive ? activeRem : cdRem;
      const total = isActive ? (activeTotalMs || rem) : (cdTotalMs || rem);
      const frac = clamp(total ? rem / total : 1, 0, 1);

      ctx.fillStyle = "rgba(0,0,0,0.60)";
      ctx.fillRect(x, y, slot, Math.round(slot * frac));

      const s = Math.ceil(rem / 1000);
      ctx.fillStyle = "#fff";
      ctx.font = "14px system-ui";
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.fillText(String(s), x + slot / 2, y + slot / 2);
    } else {
      // Red blink feedback when pressed on cooldown/active
      if (nowUi < nackUntilMs) {
        const p = (nackUntilMs - nowUi) / 420; // 1..0
        const blink = (Math.floor(nowUi / 80) % 2) === 0;
        if (blink) {
          ctx.fillStyle = `rgba(255, 60, 60, ${0.25 + 0.35 * (1 - p)})`;
          ctx.fillRect(x, y, slot, slot);
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(255, 60, 60, ${0.85})`;
          ctx.strokeRect(x + 2, y + 2, slot - 4, slot - 4);
        }
      }
      ctx.lineWidth = 1;
    }

    ctx.restore();
  }

  // Skill 1 slot (active or cooldown)
  drawSlot({
    x0: x0,
    y0: y0,
    keyLabel: "1",
    iconImg: skill1IconImg,
    isActive: now < skill1ActiveUntilMs,
    activeUntilMs: skill1ActiveUntilMs,
    activeTotalMs: skill1ActiveTotalMs,
    cdUntilMs: skill1CdUntilMs,
    cdTotalMs: skill1CdTotalMs,
    nackUntilMs: skill1HotbarNackUntilMs,
    shakeUntilMs: skill1HotbarShakeUntilMs,
    shakeSeed: skill1HotbarShakeSeed,
  });

  // Skill 2 slot (cooldown only)
  drawSlot({
    x0: x0 + slot + gap,
    y0: y0,
    keyLabel: "2",
    iconImg: skill2IconImg,
    isActive: false,
    activeUntilMs: 0,
    activeTotalMs: 0,
    cdUntilMs: skill2CdUntilMs,
    cdTotalMs: skill2CdTotalMs,
    nackUntilMs: skill2HotbarNackUntilMs,
    shakeUntilMs: skill2HotbarShakeUntilMs,
    shakeSeed: skill2HotbarShakeSeed,
  });
}




function isMobileHud() {
  try {
    const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ("ontouchstart" in window);
    const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
    const small = window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
    return hasTouch && (coarse || small);
  } catch (e) {
    return false;
  }
}

function getSafeInsetsPx() {
  const el = document.getElementById("gameWrap") || document.documentElement;
  const cs = getComputedStyle(el);
  const px = (v) => {
    const n = parseFloat(v || "0");
    return Number.isFinite(n) ? n : 0;
  };
  return {
    top: px(cs.paddingTop),
    right: px(cs.paddingRight),
    bottom: px(cs.paddingBottom),
    left: px(cs.paddingLeft),
  };
}

function getHotbarLayout() {
  if (typeof canvas === "undefined") {
    const box = 44, gap = 6;
    const totalW = HOTBAR_SIZE * box + (HOTBAR_SIZE - 1) * gap;
    return { x0: 0, y0: 0, box, gap, totalW };
  }

  const box = 44, gap = 6;
  const totalW = HOTBAR_SIZE * box + (HOTBAR_SIZE - 1) * gap;

  let x0, y0;
  if (hotbarPos && typeof hotbarPos.x === "number" && typeof hotbarPos.y === "number") {
    x0 = hotbarPos.x;
    y0 = hotbarPos.y;
  } else {
    if (isMobileHud()) {
      const safe = getSafeInsetsPx();
      const padR = safe.right + 10;
      const padB = safe.bottom + 8;
      x0 = Math.round(canvas.width - totalW - padR);
      y0 = Math.round(canvas.height - box - padB);
    } else {
      x0 = Math.round(canvas.width / 2 - totalW / 2);
      y0 = Math.round(canvas.height - box - 12);
    }
  }
  return { x0, y0, box, gap, totalW };
}

function getHotbarBounds() {
  if (typeof canvas === "undefined") return null;
  const layout = getHotbarLayout();
  return {
    x: layout.x0,
    y: layout.y0,
    w: layout.totalW,
    h: layout.box,
  };
}

function getHotbarSlotHit(mx, my) {
  if (typeof canvas === "undefined") return null;
  const layout = getHotbarLayout();
  const box = layout.box, gap = layout.gap;
  const x0 = layout.x0;
  const y0 = layout.y0;
  const totalW = layout.totalW;

  for (let i = 0; i < HOTBAR_SIZE; i++) {
    const x = x0 + i * (box + gap);
    const y = y0;
    if (mx >= x && mx <= x + box && my >= y && my <= y + box) {
      return { index: i, x, y, w: box, h: box };
    }
  }
  return null;
}

function drawDraggingIcon() {
  if (typeof ctx === "undefined" || !uiMouse || !uiMouse.has) return;

  const mx = uiMouse.mx;
  const my = uiMouse.my;
  const ICON = 36;

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.globalAlpha = 0.9;

  // Dragging from inventory
  if (draggingInv) {
    const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
      ? worldPlayers?.[myId]
      : null;
    const slots = me?.inventory?.slots || [];
    const slot = slots[draggingInv.fromSlot];
    const itemId = slot?.id || draggingInv.itemId;
    if (itemId) {
      const img = getItemIconImage(itemId) || equipIcons[itemId];
      if (img && img.complete && img.naturalWidth > 0) {
        const ix = Math.round(mx - ICON / 2);
        const iy = Math.round(my - ICON / 2);
        ctx.drawImage(img, ix, iy, ICON, ICON);
      }
    }
  }
  // Dragging from hotbar
  else if (draggingHotbar) {
    const slot = hotbarSlots[draggingHotbar.index];
    if (slot) {
      if (slot.type === "skill") {
        const iconImg = hotbarSkillIcons?.[slot.id] || null;
        if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
          const ix = Math.round(mx - ICON / 2);
          const iy = Math.round(my - ICON / 2);
          ctx.drawImage(iconImg, ix, iy, ICON, ICON);
        }
      } else if (slot.type === "item") {
        const me = (typeof worldPlayers !== "undefined" && typeof myId !== "undefined")
          ? worldPlayers?.[myId]
          : null;
        const invSlots = me?.inventory?.slots || [];
        const si = resolveInventorySlotIndex(slot.itemId, slot.preferSlot);
        const it = (si >= 0) ? invSlots[si] : null;
        const itemId = it?.id || slot.itemId;
        const img = getItemIconImage(itemId);
        if (img && img.complete && img.naturalWidth > 0) {
          const ix = Math.round(mx - ICON / 2);
          const iy = Math.round(my - ICON / 2);
          ctx.drawImage(img, ix, iy, ICON, ICON);
        }
      }
    }
  }

  ctx.restore();
}

function getHudLayout() {
  const w = 170;
  const hpH = 14;
  const xpH = 7;
  const padding = 4;

  if (typeof canvas === "undefined") {
    return { x: 0, y: 0, w, hpH, xpH, padding };
  }

  let x, y;
  if (hudPos && typeof hudPos.x === "number" && typeof hudPos.y === "number") {
    x = hudPos.x;
    y = hudPos.y;
  } else {
    // Default position:
    // - Desktop: centered above the hotbar.
    // - Mobile: centered at the bottom (above safe inset), with overlap-avoidance vs hotbar.
    if (isMobileHud()) {
      const safe = getSafeInsetsPx();
      const padB = safe.bottom + 8;
      x = canvas.width / 2 - w / 2;
      y = Math.max(14, Math.round(canvas.height - (hpH + xpH + padding * 3) - padB));

      // If this would overlap the hotbar (now bottom-right on mobile), nudge HUD upward.
      const hb = getHotbarLayout();
      const hudH = hpH + xpH + padding * 2;
      const hudRect = { x, y, w, h: hudH };
      const hotRect = { x: hb.x0, y: hb.y0, w: hb.totalW, h: hb.box };
      const overlaps = !(hudRect.x + hudRect.w < hotRect.x || hotRect.x + hotRect.w < hudRect.x ||
                         hudRect.y + hudRect.h < hotRect.y || hotRect.y + hotRect.h < hudRect.y);
      if (overlaps) {
        y = Math.max(14, hotRect.y - hudH - 8);
      }
    } else {
      const hotbarBoxH = 44; // must match drawHotbar()
      const hotbarPadBottom = 12; // must match drawHotbar()
      const hudClearance = hotbarBoxH + hotbarPadBottom + 10;
      x = canvas.width / 2 - w / 2;
      y = Math.max(14, canvas.height - (hpH + xpH + padding * 3) - hudClearance);
    }
}

  return { x, y, w, hpH, xpH, padding };
}

function getHudHitRect() {
  if (typeof canvas === "undefined") return null;
  const { x, y, w, hpH, xpH, padding } = getHudLayout();
  return {
    x: Math.round(x - 4),
    y: Math.round(y - 4),
    w: Math.round(w + 8),
    h: Math.round(hpH + xpH + padding * 2),
  };
}

function drawHud() {
  const { hp, maxHp, xp, xpNext } = getMyStats();
  const hpPct = clamp(maxHp ? hp / maxHp : 0, 0, 1);
  const xpPct = clamp(xpNext ? xp / xpNext : 0, 0, 1);

  const { x, y, w, hpH, xpH, padding } = getHudLayout();

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 4, y - 4, w + 8, hpH + xpH + padding * 2);

  // HP BAR
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y, w, hpH);
  ctx.fillStyle = "#ff4757";
  ctx.fillRect(x, y, Math.round(w * hpPct), hpH);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, hpH - 1);

  ctx.fillStyle = "#fff";
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.fillText(`HP ${hp}/${maxHp}`, x + w / 2, y + hpH / 2);

  // XP BAR
  const y2 = y + hpH;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y2, w, xpH);
  ctx.fillStyle = "#4dabf7";
  ctx.fillRect(x, y2, Math.round(w * xpPct), xpH);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y2 + 0.5, w - 1, xpH - 1);

  ctx.fillStyle = "#fff";
  ctx.font = "10px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.fillText(`XP ${xp}/${xpNext}`, x + w / 2, y2 + xpH / 2);

  ctx.restore();
}



/* ======================
   DEBUG EDITOR OVERLAY
====================== */
function drawEditorOverlay() {
  if (!editorOpen || !map) return;

  // World-space overlays (grid/collision/hover). We keep the editor panel in screen-space,
  // but these need to align to the tilemap, so apply the camera offset here.
  ctx.save();
  ctx.translate(-camX, -camY);

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE));
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE));

  // Height / Z-Gate visualization when those editor layers are active.
  // This makes it obvious what's stored in zMap / zGateMap without changing gameplay rendering.
  if (editorLayer === "height" || editorLayer === "zgate") {
    for (let y = startTy; y <= endTy; y++) {
      for (let x = startTx; x <= endTx; x++) {
        const px = x * TILE_SIZE;
        const py = y * TILE_SIZE;

        if (editorLayer === "height") {
          const z = (zMap && zMap[y]) ? (zMap[y][x] | 0) : 0;

          // Tint: higher = darker.
          const a = (z === 0) ? 0.04 : Math.min(0.28, 0.06 + z * 0.08);
          ctx.fillStyle = `rgba(80, 180, 255, ${a.toFixed(3)})`;
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

          // Number label (centered)
          ctx.save();
          ctx.font = "18px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.lineWidth = 4;
          ctx.strokeStyle = "rgba(0,0,0,0.55)";
          ctx.fillStyle = (z === 0) ? "rgba(255,255,255,0.45)" : "rgba(255,255,255,0.92)";
          const cx = px + TILE_SIZE / 2;
          const cy = py + TILE_SIZE / 2;
          const t = String(z);
          ctx.strokeText(t, cx, cy);
          ctx.fillText(t, cx, cy);
          ctx.restore();
        } else if (editorLayer === "zgate") {
          const zg = (zGateMap && zGateMap[y]) ? (zGateMap[y][x] ? 1 : 0) : 0;
          if (!zg) continue;

          // Green tint for gate tiles
          ctx.fillStyle = "rgba(80, 220, 120, 0.22)";
          ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

          // Simple label so it pops
          ctx.save();
          ctx.font = "16px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.lineWidth = 4;
          ctx.strokeStyle = "rgba(0,0,0,0.60)";
          ctx.fillStyle = "rgba(255,255,255,0.95)";
          ctx.strokeText("G", px + TILE_SIZE / 2, py + TILE_SIZE / 2);
          ctx.fillText("G", px + TILE_SIZE / 2, py + TILE_SIZE / 2);
          ctx.restore();
        }
      }
    }
  }

  // Mob spawn visualization (editor-only) when the mobs layer is active.
  if (editorLayer === "mobs") {
    const id = (typeof currentMapId !== "undefined") ? currentMapId
             : (typeof currentMap !== "undefined" && currentMap?.id != null) ? currentMap.id
             : 1;
    const spawns = getEditorMobSpawnsFor(id);

    for (const sp of spawns) {
      if (!sp) continue;
      const x = sp.x | 0;
      const y = sp.y | 0;
      if (x < startTx || x > endTx || y < startTy || y > endTy) continue;

      const px = x * TILE_SIZE;
      const py = y * TILE_SIZE;

      ctx.fillStyle = "rgba(150, 90, 255, 0.18)";
      ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.strokeRect(px + 0.5, py + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);

      const mobType = String(sp.type || "");
      const ct = (sp.count | 0) || 1;

      // Draw mob icon (same spritesheets used by the mob picker).
      const imgM = (typeof mobSprites !== "undefined" && mobSprites) ? (mobSprites[mobType] || null) : null;
      if (imgM && imgM.complete && imgM.naturalWidth > 0) {
        const fs = getMobFrameSize(imgM);
        const fw = (fs && fs.w) ? fs.w : TILE_SIZE;
        const fh = (fs && fs.h) ? fs.h : TILE_SIZE;

        // Backing so it reads on bright tiles
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(px + 6, py + 6, TILE_SIZE - 12, TILE_SIZE - 12);
        ctx.restore();

        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(imgM, 0, 0, fw, fh, px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
      } else {
        // Fallback: short text label if sprite not loaded
        const nm = mobCatalog?.[mobType]?.name || mobType || "mob";
        ctx.save();
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,0.65)";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        const t = (nm.length > 10 ? nm.slice(0, 10) + "…" : nm);
        ctx.strokeText(t, px + TILE_SIZE / 2, py + TILE_SIZE / 2);
        ctx.fillText(t, px + TILE_SIZE / 2, py + TILE_SIZE / 2);
        ctx.restore();
      }

      // Count badge (bottom-right)
      if (ct > 1) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.70)";
        ctx.fillRect(px + TILE_SIZE - 16, py + TILE_SIZE - 14, 14, 12);
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.strokeRect(px + TILE_SIZE - 16 + 0.5, py + TILE_SIZE - 14 + 0.5, 13, 11);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = "10px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(ct), px + TILE_SIZE - 9, py + TILE_SIZE - 8);
        ctx.restore();
      }
    }
  }



  if (editorShowGrid) {
    // Grid should be in world-space (aligned to tiles), so we draw it using world coords.
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    for (let x = startTx; x <= endTx + 1; x++) {
      const px = x * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(px, startTy * TILE_SIZE);
      ctx.lineTo(px, (endTy + 1) * TILE_SIZE);
      ctx.stroke();
    }
    for (let y = startTy; y <= endTy + 1; y++) {
      const py = y * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(startTx * TILE_SIZE, py);
      ctx.lineTo((endTx + 1) * TILE_SIZE, py);
      ctx.stroke();
    }
  }

  // Collision overlay (neutral): shows tiles that currently block movement based on your real collision rules
  // (ground: isSolid(tile), objects: isObjSolid(objTile)). No hard-coded tile IDs.
  if (editorShowColl) {
    for (let y = startTy; y <= endTy; y++) {
      for (let x = startTx; x <= endTx; x++) {
        const g = map[y][x] | 0;
        const o = (objMap && objMap[y] ? (objMap[y][x] | 0) : 0);

        const blocked = isSolid(g) || isObjSolid(o);
        if (!blocked) continue;

        ctx.fillStyle = "rgba(0,0,0,0.14)";
        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.strokeRect(x * TILE_SIZE + 0.5, y * TILE_SIZE + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
      }
    }
  }


  // Hover highlight
  if (editorMouseHas) {
    const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
    const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
    if (tx >= 0 && ty >= 0 && ty < map.length && tx < map[0].length) {
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.strokeRect(tx * TILE_SIZE + 0.5, ty * TILE_SIZE + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
    }
  }

  // Keep sidebar status in sync even if the camera moves while the mouse is stationary.
  editorUpdateDomStatus();

  ctx.restore();
}

/* ======================
   INVENTORY UI (MapleStory-style)
====================== */

function drawInventory(inv, equipment) {
  const cols = 6;
  const rows = 4;
  const slotSize = 48;

  const HEADER_H = 26;
  const PAD = 14;

  const panelW = cols * slotSize + PAD * 2;

  // If this is the first draw after opening, center it.
  if (invWinX == null || invWinY == null) {
    invWinX = Math.floor(canvas.width / 2 - panelW / 2);
    invWinY = Math.floor(canvas.height / 2 - 230);
  }

  let startX = invWinX;
  let startY = invWinY;

  const eqY = startY + HEADER_H + 18;
  const eqX = startX + PAD;
  const eqGap = 12;

  const equipSlots = {
    weapon:    { x: eqX + 0 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    armor:     { x: eqX + 1 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    hat:       { x: eqX + 2 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    accessory: { x: eqX + 3 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
  };

  // ---- Tabs (3x inventory pages) ----
  const TAB_H = 20;
  const TAB_GAP = 6;
  const tabsY = eqY + slotSize + 12;
  const tabsX = startX + PAD;
  const tabsW = panelW - PAD * 2;
  const tabW = Math.floor((tabsW - TAB_GAP * 2) / 3);

  const tabRects = {
    equipment:  { x: tabsX + 0 * (tabW + TAB_GAP), y: tabsY, w: tabW, h: TAB_H },
    consumable: { x: tabsX + 1 * (tabW + TAB_GAP), y: tabsY, w: tabW, h: TAB_H },
    other:      { x: tabsX + 2 * (tabW + TAB_GAP), y: tabsY, w: tabW, h: TAB_H },
  };

  // Inventory grid layout (shows one tab/page at a time)
  const gridLabelY = tabsY + TAB_H + 4;
  const gridX = startX + PAD;
  const gridY = gridLabelY + 18;

  const panelH = (gridY + rows * slotSize + PAD) - startY;

  // cache window size for clamping drag
  invWinW = panelW;
  invWinH = panelH;

  // keep within canvas (in case screen size changed)
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
  startX = invWinX;
  startY = invWinY;

  // Close button + header rects
  const closeSize = 18;
  invCloseRect = {
    x: startX + panelW - closeSize - 8,
    y: startY + 4,
    w: closeSize,
    h: closeSize
  };
  invHeaderRect = {
    x: startX,
    y: startY,
    w: panelW,
    h: HEADER_H
  };

  const tabOffset = (Math.max(0, Math.min(INV_TAB_COUNT - 1, invActiveTab)) * INV_TAB_SIZE);

  // Cache layout for click handling
  invUI = {
    equipSlots,
    tabs: tabRects,
    grid: {
      x: gridX,
      y: gridY,
      cols,
      rows,
      slotSize,
      w: cols * slotSize,
      h: rows * slotSize,
      offset: tabOffset
    }
  };

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.fillRect(startX, startY, panelW, panelH);

  // header bar (drag handle)
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(startX, startY, panelW, HEADER_H);

  // header title
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Inventory", startX + PAD, startY + Math.floor(HEADER_H / 2));

  // close button
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(invCloseRect.x, invCloseRect.y, invCloseRect.w, invCloseRect.h);
  ctx.fillStyle = "#ddd";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("X", invCloseRect.x + invCloseRect.w / 2, invCloseRect.y + invCloseRect.h / 2 + 0.5);
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.font = "12px system-ui";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Equipment", startX + PAD, startY + HEADER_H + 2);

  // Draw equipment slots
  const eq = equipment || {};
  const labels = { weapon: "Wpn", armor: "Arm", hat: "Hat", accessory: "Acc" };

  for (const slotName of ["weapon", "armor", "hat", "accessory"]) {
    const r = equipSlots[slotName];
    ctx.strokeStyle = "#aaa";
    ctx.strokeRect(r.x, r.y, r.w, r.h);

    // label
    ctx.fillStyle = "#bbb";
    ctx.fillText(labels[slotName], r.x + 6, r.y + r.h + 2);

    const itemId = eq[slotName];
    if (itemId) {
      const drew = drawItemIcon(itemId, r.x, r.y, r.w);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(itemId, r.x + 4, r.y + 16);
      }
    }
  }

  // ---- Tabs UI ----
  ctx.save();
  ctx.font = "12px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const tabKeys = ["equipment", "consumable", "other"];
  const tabLabels = ["Equip", "Use", "Other"];

  for (let ti = 0; ti < 3; ti++) {
    const key = tabKeys[ti];
    const r = tabRects[key];
    const active = (invActiveTab === ti);

    ctx.fillStyle = active ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.05)";
    ctx.fillRect(r.x, r.y, r.w, r.h);

    ctx.strokeStyle = active ? "rgba(255,255,255,0.34)" : "rgba(255,255,255,0.18)";
    ctx.strokeRect(r.x + 0.5, r.y + 0.5, r.w - 1, r.h - 1);

    ctx.fillStyle = active ? "#fff" : "rgba(255,255,255,0.75)";
    ctx.fillText(tabLabels[ti], r.x + r.w / 2, r.y + r.h / 2 + 0.5);
  }
  ctx.restore();

  const activeLabel = INV_TABS?.[invActiveTab]?.label || "Items";
  ctx.fillStyle = "#ddd";
  ctx.font = "12px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(`Items (${activeLabel})`, startX + PAD, gridLabelY);

  // Draw inventory grid (one page at a time)
  const slots = inv?.slots || [];
  for (let i = 0; i < cols * rows; i++) {
    const x = gridX + (i % cols) * slotSize;
    const y = gridY + Math.floor(i / cols) * slotSize;

    ctx.strokeStyle = "#888";
    ctx.strokeRect(x, y, slotSize, slotSize);

    const absIndex = tabOffset + i;
    const slot = slots[absIndex];
    const isDraggingThisSlot = draggingInv && draggingInv.fromSlot === absIndex;

    if (slot && !isDraggingThisSlot) {
      const drew = drawItemIcon(slot.id, x, y, slotSize);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(slot.id, x + 4, y + 6);
      }

      // stack count
      if (slot.qty > 1) {
        const txt = String(slot.qty);
        ctx.save();
        ctx.font = "12px system-ui";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + slotSize - 6;
        const ty = y + slotSize - 6;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.strokeText(txt, tx, ty);
        ctx.fillStyle = "#fff";
        ctx.fillText(txt, tx, ty);
        ctx.restore();
      }
    }
  }

  // ---- Item submenu (Use / Bind to hotbar) ----
  if (invItemMenu) {
    const cur = slots?.[invItemMenu.slotIndex];
    if (!cur || cur.id !== invItemMenu.itemId) {
      invItemMenu = null;
      invItemMenuUI = null;
    } else {
      const menuW = 170;
      const pad = 8;
      const rowH = 22;
      const gap = 6;
      const menuH = pad * 2 + rowH * 2 + gap;

      let mx = invItemMenu.x;
      let my = invItemMenu.y;

      if (mx + menuW > canvas.width - 8) {
        mx = (invItemMenu.x - menuW) - 16;
      }

      mx = clamp(mx, 8, canvas.width - menuW - 8);
      my = clamp(my, 8, canvas.height - menuH - 8);

      const panel = { x: mx, y: my, w: menuW, h: menuH };
      const btnUse  = { x: mx + pad, y: my + pad, w: menuW - pad * 2, h: rowH };
      const btnBind = { x: mx + pad, y: my + pad + rowH + gap, w: menuW - pad * 2, h: rowH };

      invItemMenuUI = { panel, btnUse, btnBind };

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.88)";
      ctx.fillRect(panel.x, panel.y, panel.w, panel.h);
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.strokeRect(panel.x, panel.y, panel.w, panel.h);

      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(btnUse.x, btnUse.y, btnUse.w, btnUse.h);
      ctx.fillRect(btnBind.x, btnBind.y, btnBind.w, btnBind.h);

      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.strokeRect(btnUse.x, btnUse.y, btnUse.w, btnUse.h);
      ctx.strokeRect(btnBind.x, btnBind.y, btnBind.w, btnBind.h);

      ctx.font = "12px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ddd";
      ctx.fillText("Use item", btnUse.x + 10, btnUse.y + Math.floor(btnUse.h / 2));
      ctx.fillText("Bind to hotbar", btnBind.x + 10, btnBind.y + Math.floor(btnBind.h / 2));

      ctx.restore();
    }
  } else {
    invItemMenuUI = null;
  }

  // Bind hint (shows inside the inventory window)
  if (pendingItemBind) {
    ctx.save();
    ctx.font = "12px system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("Press 1–6 to bind item to hotbar (Esc to cancel)", startX + PAD, startY + panelH - 10);
    ctx.restore();
  }

  ctx.restore();
}


/* ======================
   INVENTORY TOOLTIP (hover)
====================== */
// Keep this in sync with server.js ITEMS for names. Desc is client-only flavor.
const ITEM_INFO = {
  coin:            { name: "Coin",            desc: "Currency picked up from mobs." },
  orange_flan:     { name: "Orange Flan",     desc: "A wobbly snack. Looks suspiciously delicious." },
  potion_small:    { name: "Small Potion",    desc: "Restores 25 HP." },
  potion_green:    { name: "Green Slime Tonic",    desc: "Restores 50 HP." },
  potion_purple:    { name: "Purple Slime Tonic",    desc: "Restores 300 HP." },


  training_sword:  { name: "Training Sword",  desc: "A basic sword for practice." },
  branch_sword:  { name: "Tree Branch",  desc: "Poke an eye out." },
  bone_sword:     { name: "Bone Club",      desc: "A heavy club carved from bone." },
  training_spear:  { name: "Hunting Spear",  desc: "A basic spear for practice." },
  blue_umbrella_spear: { name: "Sky Blue Umbrella", desc: "A sky-blue umbrella repurposed into a spear." },
  candy_cane_spear:{ name: "North Pole",desc: "Festive… and pointy." },
  fang_spear:      { name: "Twin Fang",      desc: "A spear tipped with a wicked fang." },
  trident_spear:  { name: "Trident",        desc: "A three-pronged spear that bites deep." },
  training_wand:   { name: "Training Wand",   desc: "A simple wand for new mages." },
  bone_wand:       { name: "Bone Wand",       desc: "A wand carved from bone. Feels oddly warm." },

  cloth_armor:     { name: "Apprentice Robe",     desc: "Light protection." },
  charger_suit:    { name: "Charger Suit",    desc: "Sturdy armor with a metallic sheen." },
  cloth_hat:       { name: "Apprentice Hat",       desc: "Keeps the sun out of your eyes." },
  charger_helmet:  { name: "Charger Helmet",  desc: "A helmet with a solid visor." },
  red_duke: { name: "Red Duke", type: "hat", stats: "", desc: "A duke’s helm, dyed crimson." },
  lucky_charm:     { name: "Four-Leaf",     desc: "Maybe it really is lucky." },
};

// Minimal item meta for tooltip "splash" lines (type + weapon speed).
// Keep these in sync with server.js ITEMS where applicable.
const ITEM_META = {
  // Weapon speed is a multiplier; 1.00x means "normal".
  training_sword:   { slot: "weapon", kind: "Sword", weaponSpeed: 1.00 },
  branch_sword:     { slot: "weapon", kind: "Sword", weaponSpeed: 1.00 },
  bone_sword:       { slot: "weapon", kind: "Sword", weaponSpeed: 1.00 },
  training_wand:    { slot: "weapon", kind: "Wand",  weaponSpeed: 1.00 },
  bone_wand:        { slot: "weapon", kind: "Wand",  weaponSpeed: 1.00 },
  training_spear:   { slot: "weapon", kind: "Spear", weaponSpeed: 1.00 },
  blue_umbrella_spear:{ slot: "weapon", kind: "Spear", weaponSpeed: 1.00 },
  candy_cane_spear: { slot: "weapon", kind: "Spear", weaponSpeed: 1.00 },
  fang_spear:       { slot: "weapon", kind: "Spear", weaponSpeed: 1.00 },
  trident_spear:    { slot: "weapon", kind: "Spear", weaponSpeed: 1.00 },
  cloth_armor:      { slot: "armor", kind: "Armor" },
  charger_suit:     { slot: "armor", kind: "Armor" },
  cloth_hat:        { slot: "hat",   kind: "Hat"   },
  charger_helmet:   { slot: "hat",   kind: "Hat"   },
  lucky_charm:      { slot: "accessory", kind: "Accessory", speedBonus: 50 },
};

function getItemTooltipData(itemId, qty = 1, hover = null) {
  const info = ITEM_INFO[itemId] || null;
  const name = (info && info.name) ? info.name : String(itemId || "Unknown");
  const desc = (info && info.desc) ? info.desc : "";
  const metaLines = [];

  const meta = ITEM_META[itemId] || null;
  if (meta) {
    if (meta.slot === "weapon") {
      const kind = meta.kind ? ` (${meta.kind})` : "";
      metaLines.push(`Type: Weapon${kind}`);
      if (typeof meta.weaponSpeed === "number") {
        const s = (Math.round(meta.weaponSpeed * 100) / 100).toString();
        metaLines.push(`Speed: ${s}x`);
      }

      // If we have hover context with rolled stats, surface them
      if (hover && typeof hover.weaponBonus === "number") {
        const wb = hover.weaponBonus;
        if (wb > 0) {
          metaLines.push(`Attack Bonus: +${wb}`);
        } else if (wb < 0) {
          metaLines.push(`Attack Bonus: ${wb}`);
        } else {
          metaLines.push("Attack Bonus: +0");
        }
      }
      if (hover && typeof hover.totalAttack === "number") {
        metaLines.push(`Attack with this weapon: ${hover.totalAttack}`);
      }
    } else if (meta.slot === "armor") {
      metaLines.push("Type: Armor");
    } else if (meta.slot === "hat") {
      metaLines.push("Type: Hat");
    } else if (meta.slot === "accessory") {
      metaLines.push("Type: Accessory");
      if (typeof meta.speedBonus === "number") {
        const sb = meta.speedBonus;
        metaLines.push(`Speed: ${sb >= 0 ? "+" : ""}${sb}`);
      }
    }
  }

  if (qty > 1) metaLines.push(`x${qty}`);
  return { name, desc, metaLines };
}

function wrapTooltipText(text, maxWidthPx, font = "12px system-ui") {
  if (!text) return [];
  ctx.save();
  ctx.font = font;
  const words = String(text).split(/\s+/).filter(Boolean);
  const lines = [];
  let line = "";
  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxWidthPx) line = test;
    else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);
  ctx.restore();
  return lines;
}

function getInventoryHover(mx, my, inv, equipment, player) {
  if (!invUI) return null;

  // Equipment slots (only if occupied)
  const eq = equipment || {};
  for (const [slotName, r] of Object.entries(invUI.equipSlots || {})) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      const itemId = eq[slotName];
      if (!itemId) return null;

      let weaponBonus = null;
      let totalAttack = null;
      let baseAtk = null;

      if (slotName === "weapon" && player) {
        if (typeof player.weaponBonus === "number") {
          weaponBonus = player.weaponBonus;
        }
        if (typeof player.baseAtk === "number") {
          baseAtk = player.baseAtk;
        }
        // fall back if baseAtk isn't present yet
        if (baseAtk == null && typeof player.atk === "number") {
          const wBonus = (typeof player.weaponBonus === "number") ? player.weaponBonus : 0;
          baseAtk = player.atk - wBonus;
        }
        if (baseAtk != null) {
          totalAttack = baseAtk + (weaponBonus || 0);
        }
      }

      return {
        id: itemId,
        qty: 1,
        source: "equip",
        rect: r,
        slotName,
        weaponBonus,
        totalAttack,
        baseAtk
      };
    }
  }

  // Inventory grid slots
  const g = invUI.grid;
  if (!g) return null;
  if (mx < g.x || my < g.y || mx > g.x + g.w || my > g.y + g.h) return null;

  const sx = Math.floor((mx - g.x) / g.slotSize);
  const sy = Math.floor((my - g.y) / g.slotSize);
  if (sx < 0 || sy < 0 || sx >= g.cols || sy >= g.rows) return null;

  const relIndex = sy * g.cols + sx;
  const slotIndex = (Number.isFinite(g.offset) ? g.offset : 0) + relIndex;
  const slot = inv?.slots ? inv.slots[slotIndex] : null;
  if (!slot) return null;

  const rect = {
    x: g.x + sx * g.slotSize,
    y: g.y + sy * g.slotSize,
    w: g.slotSize,
    h: g.slotSize
  };

  let weaponBonus = null;
  let totalAttack = null;
  let baseAtk = null;

  // If this slot is a weapon, try to expose its rolled bonus + preview total attack
  if (slot && slot.id && ITEM_META[slot.id] && ITEM_META[slot.id].slot === "weapon") {
    if (typeof slot.weaponBonus === "number") {
      weaponBonus = slot.weaponBonus;
    }
    if (player) {
      if (typeof player.baseAtk === "number") {
        baseAtk = player.baseAtk;
      } else if (typeof player.atk === "number") {
        const wBonus = (typeof player.weaponBonus === "number") ? player.weaponBonus : 0;
        baseAtk = player.atk - wBonus;
      }
      if (baseAtk != null && weaponBonus != null) {
        totalAttack = baseAtk + weaponBonus;
      }
    }
  }

  return {
    id: slot.id,
    qty: slot.qty || 1,
    source: "grid",
    slotIndex,
    rect,
    weaponBonus,
    totalAttack,
    baseAtk
  };
}
function drawInventoryTooltip(hover, preferX, preferY) {
  if (!hover || !hover.id) return;

  const { name, desc, metaLines } = getItemTooltipData(hover.id, hover.qty, hover);

  const PAD = 10;
  const GAP = 8;
  const ICON = 56; // slightly larger than the 32px inventory icon
  const W = 240;

  // Wrap description
  const descLines = wrapTooltipText(desc, W - PAD * 2, "12px system-ui");

  // Compute height
  const nameH = 16;
  const metaH = metaLines.length ? (metaLines.length * 14 + 4) : 0;
  const descH = descLines.length ? (descLines.length * 14 + 2) : 0;
  const H = PAD + nameH + GAP + ICON + (metaH ? GAP + metaH : 0) + (descH ? GAP + descH : 0) + PAD;

  // Position & clamp inside canvas
  let x = Math.round(preferX);
  let y = Math.round(preferY);
  x = clamp(x, 8, canvas.width - W - 8);
  y = clamp(y, 8, canvas.height - H - 8);

  // Background
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.88)";
  ctx.fillRect(x, y, W, H);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(x + 0.5, y + 0.5, W - 1, H - 1);

  // Name
  ctx.font = "bold 13px system-ui";
  ctx.fillStyle = "#fff";
  ctx.textBaseline = "top";
  ctx.textAlign = "left";
  ctx.fillText(name, x + PAD, y + PAD);

  // Image (left-justified)
  const img = equipIcons[hover.id];
  const ix = Math.round(x + PAD); // left align with text
  const iy = Math.round(y + PAD + nameH + GAP);
if (img && img.complete && img.naturalWidth > 0) {
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, ix, iy, ICON, ICON);
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(ix, iy, ICON, ICON);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(ix + 0.5, iy + 0.5, ICON - 1, ICON - 1);
  }

  // Meta
  let cy = iy + ICON + GAP;
  if (metaLines.length) {
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    for (const t of metaLines) {
      ctx.fillText(t, x + PAD, cy);
      cy += 14;
    }
    cy += 4;
  }

  // Desc
  if (descLines.length) {
    ctx.font = "12px system-ui";
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    for (const t of descLines) {
      ctx.fillText(t, x + PAD, cy);
      cy += 14;
    }
  }

  ctx.restore();
}

function drawLootPops() {
  const now = performance.now();
  for (let i = lootPops.length - 1; i >= 0; i--) {
    const p = lootPops[i];
    if (now > p.untilMs) { lootPops.splice(i, 1); continue; }
    const t = 1 - ((p.untilMs - now) / 700);
    const y = p.y - Math.round(t * 14);

    ctx.save();
    ctx.font = "14px system-ui";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ffd966";
    ctx.fillText(p.text, Math.round(p.x), Math.round(y));
    ctx.restore();
  }
}

/* ======================
   DAMAGE POPUPS DRAW
====================== */
function drawDamagePops() {
  const now = performance.now();
  for (let i = damagePops.length - 1; i >= 0; i--) {
    const d = damagePops[i];
    if (now > d.untilMs) { damagePops.splice(i, 1); continue; }

    const life = 650;
    const t = 1 - ((d.untilMs - now) / life);
    const rise = Math.round(t * 18);
    const alpha = clamp(1 - t, 0, 1);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = "bold 20px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.lineWidth = 5;
    ctx.strokeStyle = "rgba(0,0,0,0.7)";
    ctx.strokeText(d.text, Math.round(d.x), Math.round(d.y - rise));

    ctx.fillStyle = d.color || "#fff";
    ctx.fillText(d.text, Math.round(d.x), Math.round(d.y - rise));
    ctx.restore();
  }
}

/* ======================
   LEVEL TOAST
====================== */
function drawLevelToast() {
  if (performance.now() > levelToastUntilMs) return;

  ctx.save();
  ctx.font = "24px system-ui";
  ctx.textBaseline = "middle";

  const text = levelToastText || "LEVEL UP!";
  const w = Math.ceil(ctx.measureText(text).width);
  const x = Math.round(canvas.width / 2 - w / 2);
  const y = Math.round(canvas.height * 0.18);

  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 12, y - 18, w + 24, 36);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x - 11.5, y - 17.5, w + 23, 35);

  ctx.fillStyle = "#fff";
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawDropConfirm() {
  if (!dropConfirm) return;

  const layout = getDropConfirmLayout();
  if (!layout) return;

  const { panel, btnYes, btnNo } = layout;

  ctx.save();

  // Slight dim behind panel so it stands out but doesn't fully hide the game.
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Panel
  ctx.fillStyle = "rgba(0,0,0,0.92)";
  ctx.fillRect(panel.x, panel.y, panel.w, panel.h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(panel.x + 0.5, panel.y + 0.5, panel.w - 1, panel.h - 1);

  ctx.font = "14px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#fff";

  const line1 = "Drop this item?";
  const line2 = "Are you sure?";
  ctx.fillText(line1, panel.x + panel.w / 2, panel.y + 28);
  ctx.fillText(line2, panel.x + panel.w / 2, panel.y + 48);

  // Buttons
  ctx.font = "13px system-ui";
  function drawBtn(r, label) {
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(r.x, r.y, r.w, r.h);
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.strokeRect(r.x + 0.5, r.y + 0.5, r.w - 1, r.h - 1);
    ctx.fillStyle = "#fff";
    ctx.fillText(label, r.x + r.w / 2, r.y + r.h / 2 + 1);
  }

  drawBtn(btnYes, "Drop");
  drawBtn(btnNo, "Cancel");

  ctx.restore();
}

function getDropConfirmLayout() {
  if (!dropConfirm || typeof canvas === "undefined") return null;

  const panelW = 260;
  const panelH = 110;
  const x = Math.round(canvas.width / 2 - panelW / 2);
  const y = Math.round(canvas.height / 2 - panelH / 2);

  const pad = 16;
  const btnW = 90;
  const btnH = 28;
  const btnY = y + panelH - pad - btnH;

  const btnYes = { x: x + pad, y: btnY, w: btnW, h: btnH };
  const btnNo  = { x: x + panelW - pad - btnW, y: btnY, w: btnW, h: btnH };
  const panel  = { x, y, w: panelW, h: panelH };

  return { panel, btnYes, btnNo };
}


/* ======================
   NAMEPLATE
====================== */
function drawNameplate(x, y, level, name, spriteH = PLAYER_FRAME_H) {
  if (!name) return;

  const lvl = String(level ?? 1);
  const nameText = String(name);

  ctx.save();
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  const padX = 6;
  const h = 18;

  // measure pieces
  const badgePad = 8;
  const badgeW = Math.max(18, Math.ceil(ctx.measureText(lvl).width + badgePad));
  const gap = 6;
  const nameW = Math.ceil(ctx.measureText(nameText).width);

  const w = padX + badgeW + gap + nameW + padX;

  const bx = Math.round(x - w / 2);
  // closer to player (was -20)
  const by = Math.round(y - spriteH / 2 - 20);

  // main plate (dark, subtle)
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(bx, by, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(bx + 0.5, by + 0.5, w - 1, h - 1);

  // level badge: white with black text (black-on-white)
  const badgeX = bx + padX;
  const badgeY = by + 2;
  const badgeH = h - 4;

  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.fillRect(badgeX, badgeY, badgeW, badgeH);
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.strokeRect(badgeX + 0.5, badgeY + 0.5, badgeW - 1, badgeH - 1);

  // level text centered inside badge
  ctx.fillStyle = "rgba(0,0,0,0.95)";
  ctx.textAlign = "center";
  ctx.fillText(lvl, badgeX + badgeW / 2, by + h / 2);

  // name text to the right (no bleeding into badge)
  ctx.textAlign = "left";
  ctx.fillStyle = "#fff";
  ctx.fillText(nameText, badgeX + badgeW + gap, by + h / 2);

  ctx.restore();
}



/* ======================
   MAIN LOOP
====================== */
let last = performance.now();

function recoverFromBackgroundResume(reason = "resume") {
  // Reset frame timer to avoid giant dt after backgrounding.
  last = performance.now();

  // Reconnect socket if mobile browser suspended/killed it.
  if (!ws || ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
    connectWs();
    return;
  }

  // If socket is open, re-send current input state so controls don't feel stuck.
  if (ws.readyState === WebSocket.OPEN) {
    try { sendInput(); } catch {}
  }
}

window.addEventListener("pageshow", () => {
  recoverFromBackgroundResume("pageshow");
}, { passive: true });

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    recoverFromBackgroundResume("visibilitychange");
  } else {
    last = performance.now();
  }
}, { passive: true });

window.addEventListener("focus", () => {
  recoverFromBackgroundResume("focus");
}, { passive: true });

window.addEventListener("blur", () => {
  last = performance.now();
}, { passive: true });

window.addEventListener("pagehide", () => {
  last = performance.now();
}, { passive: true });


function drawPortals() {
  if (!Array.isArray(portals) || portals.length === 0) return;

  // Slower, gentler pulse than the old circle marker.
  const t = performance.now() * 0.0024;
  const pulse = (Math.sin(t) + 1) * 0.5; // 0..1

  // Local player tile using feet anchor (same logic as portal checks/collision feel).
  let activeTx = null, activeTy = null;
  const me = getMyPos();
  if (me) {
    activeTx = Math.floor(me.x / TILE_SIZE);
    activeTy = Math.floor((me.y + DBG_PLAYER_FOOT_Y) / TILE_SIZE);
    if (!Number.isFinite(activeTx) || !Number.isFinite(activeTy)) {
      activeTx = activeTy = null;
    }
  }

  for (const p of portals) {
    if (!p) continue;
    const x = p.x * TILE_SIZE;
    const y = p.y * TILE_SIZE;
    const isActive = (p.x === activeTx && p.y === activeTy);
    const isHidden = !!p.hidden;

    // Secret/hidden portals should not show their idle marker.
    // They only reveal themselves when the player is standing on the tile.
    if (isHidden && !isActive) continue;

    ctx.save();

    if (isActive) {
      // Full-tile pulsing highlight while standing on portal.
      const fillA = 0.10 + pulse * 0.12;
      ctx.fillStyle = `rgba(255,255,255,${fillA})`;
      ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

      // Outer border (softly breathing).
      ctx.strokeStyle = `rgba(255,255,255,${0.55 + pulse * 0.20})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);

      // Subtle inner shimmer border for clarity without being flashy.
      const shimmer = (Math.sin(t * 1.8 + (p.x + p.y) * 0.7) + 1) * 0.5;
      ctx.strokeStyle = `rgba(255,255,255,${0.20 + shimmer * 0.28})`;
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
    } else {
      // Gentle white square marker when idle.
      const size = TILE_SIZE * (0.72 + pulse * 0.05);
      const inset = (TILE_SIZE - size) * 0.5;

      ctx.fillStyle = `rgba(255,255,255,${0.08 + pulse * 0.06})`;
      ctx.fillRect(x + inset, y + inset, size, size);

      ctx.strokeStyle = `rgba(255,255,255,${0.30 + pulse * 0.12})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(x + inset, y + inset, size, size);
    }

    ctx.restore();
  }
}



      function updateClientSkillCasts(nowMs) {
        // Handle delayed firing of Healing Cloud after its cast time completes.
        if (skill6CastArmed && nowMs >= skill6CastEndClientMs) {
          skill6CastArmed = false;
          if (typeof sendSkill6HealingCloud === "function") {
            sendSkill6HealingCloud();
          }
        }
      }

function loop(nowMs) {
        updateClientSkillCasts(nowMs);
  let dt = (nowMs - last) / 1000;
  last = nowMs;
  if (!Number.isFinite(dt) || dt < 0) dt = 0;
  if (dt > 0.1) dt = 1 / 60;

  try {

  updateCamera();
  updateFade(dt);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw nameplates last (above canopies)
  const nameplates = [];

  const shake = getShakeOffset();

  ctx.save();
  ctx.translate(-camX + shake.x, -camY + shake.y);

  drawMap();
  drawPortals();
  drawPortals();
  // drawObjects("below"); // non-canopy objects are now depth-sorted with entities

  // drops behind entities
  // Draw in ascending y so objects lower on the screen appear "in front".
  const dropEntries = Object.entries(worldDrops);
  dropEntries.sort(([, a], [, b]) => {
    const ay = (a && typeof a.y === "number") ? a.y : 0;
    const by = (b && typeof b.y === "number") ? b.y : 0;
    return ay - by;
  });

  for (const [id, d] of dropEntries) {
    const itemId = d.itemId || "coin";

    // Base ground contact point from the server.
    const gx = Math.round(d.x);
    const gy = Math.round(d.y);

    // Animate only the sprite (hop + bob), not the shadow.
    const { offsetY, scale } = getDropAnimState(id, d);
    const spriteY = Math.round(gy - offsetY); // positive offsetY lifts the sprite up

    // Simple per-drop shadow that stays anchored to the ground.
    ctx.save();
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.ellipse(gx, gy + 3, 10, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    if (itemId === "coin") {
      drawCoin(gx, spriteY, d.amount || d.qty || 1);
    } else {
      drawItemDrop(itemId, gx, spriteY, scale);
    }
  }

  // projectiles behind entities (feels good for bolts)
  for (const pr of Object.values(worldProjectiles)) {
    drawProjectile(pr);
  }

  const me = getMyPos();

  // Defer world-space prompts until after objects/canopies + nameplates so they never render under the object layer.
  const portalPrompt = (me && isOnPortal()) ? { near: me, text: "Press E to travel", spriteH: PLAYER_FRAME_H } : null;

  cachedNearestNpc = computeNearestNpc();
  const npcPrompt = cachedNearestNpc ? { near: cachedNearestNpc, text: "Press E", spriteH: NPC_DRAW_H } : null;
  const entities = [];
const cloudEntities = [];

  // object-layer solids (stumps/rocks) depth-sort with entities so you can walk behind them
  if (objMap) {
    const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
    const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
    const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
    const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

    for (let oy = startTy; oy <= endTy; oy++) {
      for (let ox = startTx; ox <= endTx; ox++) {
        const ot = objMap[oy][ox];
        if (!ot) continue;
        if (isObjCanopy(ot)) continue; // canopies are drawn in a separate pass on top
        const px = ox * TILE_SIZE;
        const py = oy * TILE_SIZE;
        entities.push({
          kind: "obj",
          id: `obj:${ox},${oy}:${ot}`,
          tile: ot,
          px,
          py,
          // sort by bottom of tile so players can walk "in front of" or "behind" the base
          sortY: py + TILE_SIZE,
        });
      }
    }
  }

  for (const [id, p] of Object.entries(worldPlayers)) {
    const pos = getSmoothedPos(id, p.x, p.y);
    // IMPORTANT: use a feet anchor for depth sorting (keep render position unchanged)
    // 64x64 sprites: feet are ~22px below the sprite center.
    entities.push({ kind:"player", id, x: pos.x, y: pos.y, sortY: pos.y + 22 });

    // Skill 5: familiar visual (depth-sorted with entities)
    if (p && p.familiarActive) {
      const tid = p.familiarTargetId;
      const tm = (tid && worldMobs) ? worldMobs[tid] : null;
      let mpos = null;
      if (tm && !tm.dead && !(tm.corpseMs > 0)) {
        mpos = getSmoothedPos(tid, tm.x, tm.y);
      }

      const fam = getFamiliarRenderState(id, pos, tm, mpos, dt);

      entities.push({
        kind: "fam",
        id: `fam:${id}`,
        ownerId: id,
        x: fam.x,
        y: fam.y,
        sortY: fam.y + 4,
        isTargeting: fam.isTargeting,
        tX: fam.tX,
        tY: fam.tY,
      });
    }

    // Skill 6: Healing Cloud visual (depth-sorted with entities)
    if (p && typeof p.healingCloudUntilMs === "number" && p.healingCloudUntilMs > 0) {
      const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
      if (nowAbs < p.healingCloudUntilMs &&
          typeof p.healingCloudX === "number" &&
          typeof p.healingCloudY === "number") {
        const cx = p.healingCloudX;
        const cy = p.healingCloudY;
        entities.push({
          kind: "cloud",
          id: `cloud:${id}`,
          ownerId: id,
          x: cx,
          y: cy,
          sortY: cy - HEALING_CLOUD_OFFSET_FINAL,
          endAbsMs: p.healingCloudUntilMs,
        });
      }
    }
  }
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    entities.push({ kind:"npc", id, x: pos.x, y: pos.y, sortY: pos.y + NPC_SORT_Y_OFFSET });
  }
  for (const [id, m0] of Object.entries(worldMobs)) {
    const pos = getSmoothedPos(id, m0.x, m0.y);
    entities.push({ kind:"mob", id, x: pos.x, y: pos.y, sortY: pos.y });
  }

  // Depth sort using an explicit anchor when provided.
  entities.sort((a,b) => (a.sortY ?? a.y) - (b.sortY ?? b.y));

  for (const e of entities) {
    if (e.kind === "obj") {
      drawObjectTile(e.tile, e.px, e.py);
      continue;
    }

    if (e.kind === "fam") {
      // Update / draw a faint trailing sparkle behind the familiar
      const key = e.ownerId || e.id || "fam";
      let trail = familiarTrails.get(key);
      if (!trail) {
        trail = [];
        familiarTrails.set(key, trail);
      }
      const now = performance.now();
      trail.push({ x: e.x, y: e.y, t: now });
      if (trail.length > 7) {
        trail.splice(0, trail.length - 7);
      }

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (let i = 0; i < trail.length; i++) {
        const p = trail[i];
        const age = now - p.t;
        const life = 260;
        if (age > life) continue;
        const t = 1 - age / life;
        const r = 2 + 2 * t;
        ctx.globalAlpha = 0.28 * t;
        ctx.beginPath();
        ctx.arc(Math.round(p.x), Math.round(p.y), r, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(180,230,255,1)";
        ctx.fill();
      }
      ctx.restore();

      drawFamiliarOrb(e.x, e.y, !!e.isTargeting, e.tX, e.tY);
      continue;
    }

    if (e.kind === "cloud") {
      const nowAbs = (typeof serverNowMs === "function") ? serverNowMs() : Date.now();
      cloudEntities.push({ e, nowAbs });
      continue;
    }

    const st = updateAnim(e.id, e.x, e.y, dt);

    const fx = hitFx.get(e.id);
    let bumpX = 0, bumpY = 0;
    if (fx && performance.now() < fx.untilMs) {
      const t = (fx.untilMs - performance.now()) / 220;
      bumpX = (fx.bumpX || 0) * t;
      bumpY = (fx.bumpY || 0) * t;
    } else if (fx) {
      hitFx.delete(e.id);
    }

    const drawX = e.x + bumpX;
    const drawY = e.y + bumpY;


    // Static NPC rendering (single-image NPCs)
    if (e.kind === "npc") {
      const n = worldNpcs[e.id] || {};
      const key = n.sprite || null;
      const img = key ? (npcImages[key] || null) : null;

      if (img && img.complete && img.naturalWidth > 0) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, Math.round(drawX - NPC_DRAW_W/2), Math.round(drawY - NPC_DRAW_H/2), NPC_DRAW_W, NPC_DRAW_H);
      } else {
        // Fallback: draw default npc sheet if image not loaded yet
        drawSprite(npcSprite, drawX, drawY, st.dir, st.frame, NPC_FRAME_W, NPC_FRAME_H);
      }
      continue;
    }

    if (e.kind === "mob") {
      const mob = worldMobs[e.id];
      const type = mob?.mobType || "purple";
      const sprite = mobSprites[type] || mobSprites.purple;
      const { w: mobFW, h: mobFH } = getMobFrameSize(sprite);


      // Death "corpse" animation (no new sprites): persist 2s, slight shrink + fade at the end.
      const isCorpse = !!mob?.dead && (mob.corpseMs > 0);
      if (isCorpse) {
        const elapsed = clamp((CORPSE_TOTAL_MS - mob.corpseMs) / CORPSE_TOTAL_MS, 0, 1);
        const s = 1 - 0.12 * elapsed; // subtle shrink
        const alpha = (mob.corpseMs <= CORPSE_FADE_MS) ? clamp(mob.corpseMs / CORPSE_FADE_MS, 0, 1) : 1;

        // Draw with transform so shrink is centered on the mob.
        if (sprite.complete && sprite.naturalWidth) {
          const dirRow = st.dir, frameCol = st.frame;
          const sx = frameCol * mobFW;
          const sy = dirRow * mobFH;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.translate(Math.round(drawX), Math.round(drawY));
          ctx.scale(s, s);
          ctx.drawImage(sprite, sx, sy, mobFW, mobFH, -mobFW/2, -mobFH/2, mobFW, mobFH);
          ctx.restore();
        }

        // Keep HP bar at 0 HP while the corpse is still fully visible,
        // but hide it the moment the corpse starts fading out.
        // (Fade begins during the last CORPSE_FADE_MS.)
        if (mob && mob.corpseMs > CORPSE_FADE_MS) {
          const me = getMyPos();
          if (shouldShowMobHp(mob, me, drawX, drawY)) {
            drawHpBarWorld(drawX, drawY, 0, mob.maxHp ?? 1, mobFH);
          }
        }

        if (debugHitboxes && mob) {
          drawDebugCircle(drawX, drawY, (mob.radius ?? DBG_MOB_R), "rgba(255,60,60,0.95)");
        }
        continue;
      }
      // Fade-in when a mob spawns/respawns
      const spawnAt = mobSpawnAtMs.get(e.id) ?? 0;
      const spawnAlpha = spawnAt ? clamp((performance.now() - spawnAt) / MOB_SPAWN_FADE_MS, 0, 1) : 1;

      ctx.save();
      ctx.globalAlpha = spawnAlpha;

      drawSprite(sprite, drawX, drawY, st.dir, st.frame, mobFW, mobFH);

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(sprite, drawX, drawY, st.dir, st.frame, fx.color || "rgba(255,255,255,0.45)", mobFW, mobFH);
      }
      if (mob) {
        const me = getMyPos();
        if (shouldShowMobHp(mob, me, drawX, drawY)) {
          drawHpBarWorld(drawX, drawY, mob.hp ?? 0, mob.maxHp ?? 1, mobFH);
        }
      }
      if (debugHitboxes && mob) {
        drawDebugCircle(drawX, drawY, (mob.radius ?? DBG_MOB_R), "rgba(255,60,60,0.95)");
      }
      ctx.restore();
      continue;
    }

    const isNpc = (e.kind === "npc");
    const p = isNpc ? null : worldPlayers[e.id];

    // attack-active flag (used to suppress idle pose while swinging)
    // Also honor the server-authoritative basic-attack lock so the client doesn't
    // "walk in place" or turn early while the server is freezing movement/facing.
    const serverAtkAnim = p ? (p.atkAnim || 0) : 0;
    const lockUntilMs = (!isNpc && p && typeof p.basicAtkLockUntilMs === "number") ? p.basicAtkLockUntilMs : 0;
    const lockActive = (!isNpc && lockUntilMs > serverNowMs());
    const attacking = (serverAtkAnim > 0) || lockActive;

    // match the movement test used by updateAnim()
    let movingNow = (e.id === myId)
      ? (keys.left || keys.right || keys.up || keys.down)
      : (st.sinceMove < 0.22);

    // While channeling Healing Cloud, force local player to appear stationary
    if (!isNpc && typeof myId !== "undefined" && e.id === myId && skill6CastArmed) {
      if (typeof performance !== "undefined") {
        const nowUi = performance.now();
        if (nowUi < skill6CastEndClientMs) {
          movingNow = false;
        }
      }
    }

    // While basic-attack locked, force local player to appear stationary
    if (!isNpc && e.id === myId && lockActive) {
      movingNow = false;
    }

    const idlePose = (!isNpc) && (!movingNow) && (!attacking);

    // choose base sprite (idle uses a 2-col sheet)
    let bodySprite = npcSprite;
    let bodyFrame = st.frame;
    let bodyFW = NPC_FRAME_W, bodyFH = NPC_FRAME_H;
    if (!isNpc) {
      bodySprite = idlePose ? playerIdleSprite : playerSprite;
      bodyFrame = idlePose ? (st.idleFrame || 0) : st.frame;
      bodyFW = PLAYER_FRAME_W; bodyFH = PLAYER_FRAME_H;
    }

    // Weapon visuals: draw UP swings *behind* the player so they don't sit on top of the sprite.
    // (Left/Right/Down stay in front as before.)
    let weapon = null;
    let hasEquippedWeapon = false;
    const p2 = (!isNpc) ? worldPlayers[e.id] : null;
    let weaponActive = false;
    let weaponPhase01 = 0;
    let weaponDrawnBehind = false;
    let heldWeaponDrawnBehind = false;
    let renderDir = st.dir;  // direction used for rendering (locks during attack)
    if (!isNpc) {
      weapon = (p2 && p2.weapon && p2.weapon !== "none" && p2.weapon !== "unarmed") ? p2.weapon : null;
      hasEquippedWeapon = !!(p2 && p2.equipment && p2.equipment.weapon);
      if (!hasEquippedWeapon) weapon = null;

      const serverAnim = p2 ? (p2.atkAnim || 0) : 0;
      weaponActive = (serverAnim > 0) && hasEquippedWeapon && !!weapon;
      if (weaponActive) {
        const swingDur = getSwingDurByWeaponId(p2?.equipment?.weapon);
        // serverAnim counts down from swingDur
        weaponPhase01 = clamp(1 - (serverAnim / swingDur), 0, 1);

        // Use an attack-locked direction while the weapon animation is active.
renderDir = st.dir;
if (!isNpc && (weaponActive || lockActive)) {
  const wp = worldPlayers[e.id];
    const atkDirStr = wp && wp.atkDir;
    if (atkDirStr) {
      renderDir = (atkDirStr === "up") ? DIR.UP : (atkDirStr === "down") ? DIR.DOWN : (atkDirStr === "left") ? DIR.LEFT : DIR.RIGHT;
    } else if (wp && wp.facing && Number.isFinite(wp.facing.x) && Number.isFinite(wp.facing.y)) {
      const d = dirFromVector(wp.facing.x, wp.facing.y);
      if (d != null) renderDir = d;
    }
  }

const weaponBehind = (renderDir === DIR.UP) && (weapon === "sword" || weapon === "spear");
            // Wand attacks while facing UP should render behind the player sprite.
            if (renderDir === DIR.UP && weapon === "wand" && weaponActive && !weaponDrawnBehind) {
              drawWandCast(drawX, drawY, renderDir, weaponPhase01, getWandSpriteForPlayer(p));
              weaponDrawnBehind = true;
            }
        if (weaponBehind) {
          if (weapon === "sword") drawSwordSlash(drawX, drawY, renderDir, weaponPhase01, getSwordSpriteForPlayer(p2), p2?.atkKind || null);
          else if (weapon === "spear") drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p2), e.id);
          weaponDrawnBehind = true;
        }
      }
    }

    

    // Persistent spear when equipped (not attacking).
    // IMPORTANT: while weaponActive is true, we only draw the thrust (using the attack-locked renderDir).
    // This prevents the “held” spear from popping to a new facing direction mid-animation (no double-spears).
    // Persistent held weapon when equipped (UP-facing, drawn behind the player).
    if (!isNpc && renderDir === DIR.UP && !heldWeaponDrawnBehind && !weaponActive) {
      if (weapon === "wand") {
        drawWandHeld(drawX, drawY, renderDir, getWandSpriteForPlayer(p2));
        heldWeaponDrawnBehind = true;
      } else if (weapon === "spear") {
        drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p2));
        heldWeaponDrawnBehind = true;
      } else if (weapon === "sword") {
        drawSwordHeld(drawX, drawY, renderDir, getSwordSpriteForPlayer(p2));
        heldWeaponDrawnBehind = true;
      }
    }
    // Wand casting pose for local player (visual only: pulsing circle, no bob)
    let bodyX = drawX;
    let bodyY = drawY;

    if (!isNpc && typeof myId !== "undefined") {
      const isLocalPlayer = (e.id === myId);
      const nowUi = performance.now();
      if (isLocalPlayer && weapon === "wand" && nowUi < castingPoseUntilMs) {
        const total = castingPoseDurationMs || CASTING_POSE_MS;
        const remaining = Math.max(0, castingPoseUntilMs - nowUi);
        const t = 1 - Math.min(1, remaining / total);

        // Glowing pulsing circle, higher and larger behind the player
        const baseY = bodyY + PLAYER_FRAME_H * 0.18;
        const radius = 28 + 8 * Math.sin(t * Math.PI * 2);
        ctx.save();
        const grad = ctx.createRadialGradient(
          bodyX, baseY, 4,
          bodyX, baseY, radius
        );
        // White-ish magic glow
        grad.addColorStop(0, "rgba(255,255,255,0.95)");
        grad.addColorStop(0.4, "rgba(255,255,255,0.55)");
        grad.addColorStop(1, "rgba(255,255,255,0.0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(bodyX, baseY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Draw body at possibly adjusted position
    drawSprite(bodySprite, bodyX, bodyY, renderDir, bodyFrame, bodyFW, bodyFH);

    // paper-doll overlays (armor + hat)
// paper-doll overlays (armor + hat)
    let armorSprite = null;
    let hatSprite = null;
    if (!isNpc) {
      const armorId = p?.equipment?.armor;
      if (armorId) {
        const aImg = idlePose ? armorIdleOverlays[armorId] : armorOverlays[armorId];
        const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
        if (aImg) {
          armorSprite = aImg;
          drawSprite(aImg, drawX, drawY, renderDir, aFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      const hatId = p?.equipment?.hat;
      const hFrame = idlePose ? (st.idleFrame || 0) : st.frame;
      let hImg = null;

      if (hatId) {
        hImg = idlePose ? hatIdleOverlays[hatId] : hatOverlays[hatId];
      } else {
        // No hat equipped: draw default hair paper-doll overlay instead.
        hImg = idlePose ? defaultHairIdleOverlays.default : defaultHairOverlays.default;
      }

      if (hImg) {
        hatSprite = hImg;
        drawSprite(hImg, drawX, drawY, renderDir, hFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
      }

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(bodySprite, drawX, drawY, st.dir, bodyFrame, fx.color || "rgba(255,0,0,0.45)", bodyFW, bodyFH);
        if (armorSprite) {
          const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
          drawHitTintOnTop(armorSprite, drawX, drawY, st.dir, aFrame, fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
        if (hatSprite) {
          drawHitTintOnTop(hatSprite, drawX, drawY, st.dir, (st.idleFrame || 0), fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      // Soft white casting glow for local player while channeling Healing Cloud
      if (typeof myId !== "undefined" && e.id === myId && skill6CastArmed) {
        const nowUi = performance.now();
        if (nowUi < skill6CastEndClientMs) {
          const glowColor = "rgba(255,255,255,0.45)";
          drawHitTintOnTop(bodySprite, bodyX, bodyY, st.dir, bodyFrame, glowColor, bodyFW, bodyFH);
          if (armorSprite) {
            const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
            drawHitTintOnTop(armorSprite, bodyX, bodyY, st.dir, aFrame, glowColor, PLAYER_FRAME_W, PLAYER_FRAME_H);
          }
          if (hatSprite) {
            const hFrame = idlePose ? (st.idleFrame || 0) : st.frame;
            drawHitTintOnTop(hatSprite, bodyX, bodyY, st.dir, hFrame, glowColor, PLAYER_FRAME_W, PLAYER_FRAME_H);
          }
        }
      }
    }
    // name + level above players (all clients) - queued to draw after canopy pass
    if (!isNpc) {
      const p = worldPlayers[e.id];
      if (p) nameplates.push({ x: drawX, y: drawY, level: p.level, name: p.name, spriteH: PLAYER_FRAME_H });
    }


    // debug collision overlays
    if (debugHitboxes && !isNpc) {
      // Player foot hitbox (matches server)
      drawDebugCircle(drawX, drawY + DBG_PLAYER_FOOT_Y, DBG_PLAYER_R, "rgba(80,160,255,0.95)");

      // Weapon hitbox (only while attacking)
      if (weaponActive) {
        const p0 = worldPlayers[e.id];
        const wid = p0?.equipment?.weapon;
        const wkey = p0?.weapon || weaponKeyFromEquippedId(wid);
        const d = dirVecFromAtkDir(p0?.atkDir, p0?.facing);
        if (wkey === "sword") {
				  const f = d; // already normalized dir vec
		  const perp = { x: -f.y, y: f.x };

		  const tests = [
			{ forward: 32, side: 0,  rad: 38 },
			{ forward: 28, side: 14, rad: 34 },
			{ forward: 28, side: -14, rad: 34 },
		  ];

		  for (const t of tests) {
			const cx = drawX + f.x * t.forward + perp.x * t.side;
			const cy = drawY + f.y * t.forward + perp.y * t.side;
			drawDebugCircle(cx, cy, t.rad, "rgba(255,220,40,0.95)");
		  }
		
        } else if (wkey === "spear") {
          drawDebugCircle(drawX + d.x * DBG_SPEAR_OFFSET, drawY + d.y * DBG_SPEAR_OFFSET, DBG_SPEAR_R, "rgba(255,220,40,0.95)");
        } else if (wkey === "wand") {
          // show your projectiles as the active weapon hitboxes
          for (const pr of Object.values(worldProjectiles || {})) {
            if (pr.mapId !== currentMapId) continue;
            if (pr.ownerId && pr.ownerId !== e.id) continue;
            const r = pr.rad ?? 10;
            drawDebugCircle(pr.x, pr.y, r, "rgba(255,220,40,0.95)");
          }
        }
      }
    }
    // weapon visuals for players (front pass)
    if (!isNpc && weaponActive && !weaponDrawnBehind) {
      if (weapon === "sword") {
        drawSwordSlash(drawX, drawY, renderDir, weaponPhase01, getSwordSpriteForPlayer(p2), p2?.atkKind || null);
      } else if (weapon === "spear") {
        drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p), e.id);
      } else if (weapon === "wand") {
        drawWandCast(drawX, drawY, renderDir, weaponPhase01, getWandSpriteForPlayer(p));
      }
    }

    // Persistent weapon when equipped (not attacking) — front pass (Left/Right/Down).
    if (!isNpc && !weaponActive && !heldWeaponDrawnBehind) {
      if (weapon === "spear") {
        drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p));
      } else if (weapon === "sword") {
        drawSwordHeld(drawX, drawY, renderDir, getSwordSpriteForPlayer(p));
      } else if (weapon === "wand") {
        drawWandHeld(drawX, drawY, renderDir, getWandSpriteForPlayer(p));
      }
    }
  }

  drawObjects("canopy");

  // draw healing clouds above tree canopies
  for (const { e, nowAbs } of cloudEntities) {
    drawHealingCloud(e, nowAbs);
  }

  // nameplates last so they never sort under canopies
  for (const np of nameplates) {
    drawNameplate(np.x, np.y, np.level, np.name, np.spriteH);
  }

  // prompts after canopies + nameplates so they're always visible
  if (portalPrompt) drawPrompt(portalPrompt.near, portalPrompt.text, portalPrompt.spriteH);
  if (npcPrompt) drawPrompt(npcPrompt.near, npcPrompt.text, npcPrompt.spriteH);

  drawDialogueBubble(activeDialogue);

  // world-space impact sparks (follow camera)
  drawHitSparks();

  // world-space popups (follow camera)
  drawDamagePops();
  drawLootPops();

  // Skill overlays (world-space, includes Skill 1 targeting + active whirlpools)
  drawSkill1Overlays();
  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();

  drawFadeOverlay();
  drawSkill3Trails();
  drawHud();
  drawHotbar();

  if (inventoryOpen) {
    const me = worldPlayers[myId];
    drawInventory(me?.inventory, me?.equipment);

    // Tooltip (on hover)
    if (uiMouse.has && invUI) {
      invHover = getInventoryHover(uiMouse.mx, uiMouse.my, me?.inventory, me?.equipment, me);
      if (invHover) {
        // Prefer to the right/bottom of the cursor.
        drawInventoryTooltip(invHover, uiMouse.mx + 18, uiMouse.my + 18);
      }
    }
  } else {
    invUI = null;
    invHover = null;
  }
  if (draggingInv || draggingHotbar) {
    drawDraggingIcon();
  }

  if (dropConfirm) {
    drawDropConfirm();
  }

  if (skillsOpen) {
    drawSkillsMenu();
  } else {
    skillsUI = null;
  }


  if (monsterBookOpen) {
    drawMonsterBook();
  } else {
    bookUI = null;
  }
  drawLevelToast();

  }
  catch (err) {
    console.error('Render loop error:', err);
  }

  requestAnimationFrame(loop);

}

requestAnimationFrame(loop);
</script>
<script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(() => {});
      });
    }
    </script></body>
</html>