<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini MMO</title>
  <style>
    body { background:#222; color:#ddd; font-family: system-ui, sans-serif; }
    canvas { border: 1px solid #555; image-rendering: pixelated; }
  </style>
</head>
<body>
  <h1>Mini MMO</h1>
  <p>WASD / Arrow keys • Press <b>E</b> near NPC / portal • Left-click to attack • Press <b>I</b> for inventory</p>
  <canvas id="c" width="800" height="600"></canvas>

<script>
/* ======================
   CONFIG
====================== */
let TILE_SIZE = 64;
let PORTAL_TILE = 3;
// Debug: collision visuals (client-only). Toggle with F3.
let debugHitboxes = false;
const DBG_PLAYER_R = 14;       // matches server PLAYER_FOOT_RADIUS
const DBG_PLAYER_FOOT_Y = 22;  // matches server PLAYER_FOOT_OFFSET_Y
const DBG_MOB_R = 16;          // matches server MOB_RADIUS
const DBG_SWORD_OFFSET = 40;   // matches server melee constants
const DBG_SWORD_R = 55;
const DBG_SPEAR_OFFSET = 58;
const DBG_SPEAR_R = 40;

// Corpse animation
const CORPSE_TOTAL_MS = 2000;
const CORPSE_FADE_MS = 650; // last part fades out


const PLAYER_FRAME_W = 64;
const PLAYER_FRAME_H = 64;

// Most existing spritesheets in this project are still 48x48.
// We keep their sizes separate so changing the player doesn't break NPCs/mobs/tiles.
const NPC_FRAME_W = 48;
const NPC_FRAME_H = 48;
const MOB_FRAME_W = 48;
const MOB_FRAME_H = 48;

const COLS = 3; // columns per row in your 3-frame spritesheets
const WALK_SEQ = [0, 1, 0, 2]; // frame order: 1,2,1,3 (0-based cols)
const IDLE_FRAME_TIME = 0.7; // seconds per idle frame (~1.4 FPS)

const SNAPSHOT_HZ = 30;
const SNAPSHOT_DT = 1 / SNAPSHOT_HZ;
const INTERP_DELAY = SNAPSHOT_DT * 1.5;

const INTERACT_DIST = 80;
const MOB_HPBAR_DIST = 220; // px: only show enemy HP bars within this distance
const TILE_PAD = 1;
const TILESET_COLS = 5; // tiles per row in tiles.png and tiles_objects.png

const LOCAL_SWING_DUR = 0.18; // must match server p.atkAnim start value
const ATTACK_DELAY_MS = 300; // local input throttle (server also enforces)

let nextAttackAtMs = 0; // local send throttle (server also enforces)


let inventoryOpen = false; // I key toggles inventory UI

/* ======================
   DEBUG MAP EDITOR
   F1: toggle editor
   TAB: switch layer (ground/object)
   [ / ]: cycle tile id
   Left click: paint, Right click: erase
   Ctrl+E: export current map+objects to clipboard/console
====================== */
let editorOpen = false;
let editorLayer = "ground"; // "ground" | "object"
let editorShowGrid = true;
let editorShowColl = true;
let editorMouseX = 0, editorMouseY = 0; let editorMouseHas = false;

// Allowed tiles to keep you from accidentally breaking portals/statues.
// You can expand these later.
const EDIT_GROUND_TILES = [0, 1];          // grass, wall (keep portals/statues unchanged for now)
let EDIT_OBJECT_TILES = [0, 1, 2, 6];    // will expand automatically based on tiles_objects.png
function rebuildEditorObjectTiles() {
  // Allow painting any tile that exists in tiles_objects.png (0 = empty)
  if (!objTileImage.complete || objTileImage.naturalHeight <= 0) return;
  const cell = TILE_SIZE + TILE_PAD;
  const rows = Math.floor((objTileImage.naturalHeight + TILE_PAD) / cell);
  const maxId = Math.max(0, rows * TILESET_COLS);
  const list = [0];
  for (let i = 1; i <= maxId; i++) list.push(i);
  EDIT_OBJECT_TILES = list;
  editorTileIndex = clamp(editorTileIndex, 0, EDIT_OBJECT_TILES.length - 1);
}

let editorTileIndex = 0; // index into allowed list for current layer

function editorAllowedList() {
  return (editorLayer === "ground") ? EDIT_GROUND_TILES : EDIT_OBJECT_TILES;
}
function editorSelectedTile() {
  const list = editorAllowedList();
  return list[clamp(editorTileIndex, 0, list.length - 1)];
}
function editorSetTileIndexByValue(v) {
  const list = editorAllowedList();
  const idx = list.indexOf(v);
  if (idx !== -1) editorTileIndex = idx;
}

// send tile edit to server (server will validate)
function sendEditTile(layer, tx, ty, tile) {
  if (!ws || ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "editTile", layer, x: tx, y: ty, tile }));
}

async function exportCurrentMapToClipboard() {
  if (!map) return;
  const payload =
`// Ground (map)\nconst map_tiles = ${JSON.stringify(map)};\n\n// Objects (objMap)\nconst map_objects = ${JSON.stringify(objMap || [])};\n`;
  console.log(payload);
  try {
    await navigator.clipboard.writeText(payload);
    levelToastText = "Exported map to clipboard (also logged to console)";
    levelToastUntilMs = performance.now() + 2500;
  } catch {
    levelToastText = "Map printed to console (clipboard blocked)";
    levelToastUntilMs = performance.now() + 2500;
  }
}
let invUI = null; // cached inventory UI layout for click handling

// Inventory window (draggable)
let invWinX = null;
let invWinY = null;
let invWinW = 0;
let invWinH = 0;
let invDragging = false;
let invDragOffX = 0;
let invDragOffY = 0;
let invCloseRect = null;
let invHeaderRect = null;

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function easeInOut(t) { return t * t * (3 - 2 * t); }
function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
function snap2(x, y) { return { x: Math.round(x), y: Math.round(y) }; }

/* ======================
   ASSETS
====================== */
const tileImage    = new Image(); tileImage.src = "/assets/tiles.png";
const objTileImage = new Image();
objTileImage.onload = rebuildEditorObjectTiles;
objTileImage.src = "/assets/tiles_objects.png";
// In case the image is already cached/complete
setTimeout(rebuildEditorObjectTiles, 0);
const playerSprite = new Image(); playerSprite.src = "/assets/player_image.png";
const playerIdleSprite = new Image(); playerIdleSprite.src = "/assets/player_idle.png";
const npcSprite    = new Image(); npcSprite.src = "/assets/npc.png";

// Static NPC images (new system)
const NPC_DRAW_W = 64;
const NPC_DRAW_H = 64;
const NPC_SORT_Y_OFFSET = 22;

const npcImages = {
  "npcs/npc_crystal.png": new Image(),
  "npcs/npc_girl.png": new Image(),
};
npcImages["npcs/npc_crystal.png"].src = "/assets/npcs/npc_crystal.png";
npcImages["npcs/npc_girl.png"].src    = "/assets/npcs/npc_girl.png";


// Attack weapon sprites (spears can swap art based on equipped spear item)
const spearSprites = {
  training_spear: new Image(),
  candy_cane_spear: new Image(),
  fang_spear: new Image(),
};
spearSprites.training_spear.src = "/assets/basic_spear.png";
spearSprites.candy_cane_spear.src = "/assets/candy_cane_spear.png";
spearSprites.fang_spear.src = "/assets/fang_spear.png";

function getSpearSpriteForPlayer(p) {
  const wid = p?.equipment?.weapon;
  if (!wid) return null;
  return spearSprites[wid] || null;
}

function drawDebugCircle(x, y, r, stroke) {
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();
}

function weaponKeyFromEquippedId(wid) {
  if (!wid) return null;
  if (wid.includes("spear")) return "spear";
  if (wid.includes("wand")) return "wand";
  if (wid.includes("sword")) return "sword";
  return null;
}

function dirVecFromAtkDir(atkDir, facing) {
  if (atkDir === "left") return { x: -1, y: 0 };
  if (atkDir === "right") return { x: 1, y: 0 };
  if (atkDir === "up") return { x: 0, y: -1 };
  if (atkDir === "down") return { x: 0, y: 1 };
  const fx = facing?.x ?? 0;
  const fy = facing?.y ?? 0;
  const ax = Math.abs(fx), ay = Math.abs(fy);
  if (ax > ay) return { x: fx >= 0 ? 1 : -1, y: 0 };
  if (ay > 0) return { x: 0, y: fy >= 0 ? 1 : -1 };
  return { x: 0, y: 1 };
}
const mobSprites = {
  purple: new Image(),
  orange: new Image(),
};
mobSprites.purple.src = "/assets/mobs/slime_purple.png";
mobSprites.orange.src = "/assets/mobs/slime_orange.png";

/* ======================
   EQUIPMENT ICONS (32x32)
====================== */
const equipIcons = {
  training_sword: new Image(),
  training_spear: new Image(),
  training_wand:  new Image(),
  cloth_armor:    new Image(),
  cloth_hat:      new Image(),
  lucky_charm:    new Image(),
  candy_cane_spear: new Image(),
  fang_spear:       new Image(),
  charger_helmet: new Image(),
  charger_suit: new Image(),
  orange_flan: new Image(),
};

equipIcons.training_sword.src = "/assets/equipment/training_sword.png";
equipIcons.training_spear.src = "/assets/equipment/training_spear.png";
equipIcons.training_wand.src  = "/assets/equipment/training_wand.png";
equipIcons.cloth_armor.src    = "/assets/equipment/cloth_armor.png";
equipIcons.cloth_hat.src      = "/assets/equipment/cloth_hat.png";
equipIcons.charger_helmet.src = "/assets/equipment/charger_helmet.png";
equipIcons.charger_suit.src = "/assets/equipment/charger_suit.png";
equipIcons.orange_flan.src = "/assets/items/orange_flan.png";
equipIcons.lucky_charm.src    = "/assets/equipment/lucky_charm.png";
equipIcons.candy_cane_spear.src = "/assets/candy_cane_spear.png";
equipIcons.fang_spear.src       = "/assets/fang_spear.png";

function drawItemIcon(itemId, x, y, slotSize) {
  const img = equipIcons[itemId];
  if (!img || !img.complete || img.naturalWidth === 0) return false;

  const ICON = 32;
  const ix = Math.round(x + (slotSize - ICON) / 2);
  const iy = Math.round(y + (slotSize - ICON) / 2);
  ctx.drawImage(img, ix, iy, ICON, ICON);
  return true;
}

/* ======================
   PAPER-DOLL OVERLAYS (48x48 frames)
====================== */
const armorOverlays = {
  cloth_armor: new Image(),
  charger_suit: new Image(),
};
armorOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_cloth_armor.png";

armorOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_charger_suit.png";
// Hat overlays for walking/moving (3 cols x 4 rows, 64x64 frames)
const hatOverlays = { cloth_hat: new Image(), charger_helmet: new Image() };
hatOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_cloth_hat.png";


hatOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_charger_helmet.png";
// Idle overlays (2 cols x 4 rows, 64x64 frames)
const armorIdleOverlays = { cloth_armor: new Image(), charger_suit: new Image() };
armorIdleOverlays.cloth_armor.src = "/assets/equipment/overlays/overlay_idle_cloth_armor.png";
armorIdleOverlays.charger_suit.src = "/assets/equipment/overlays/overlay_idle_charger_suit.png";
const hatIdleOverlays = { cloth_hat: new Image(), charger_helmet: new Image() };
hatIdleOverlays.cloth_hat.src = "/assets/equipment/overlays/overlay_idle_cloth_hat.png";




hatIdleOverlays.charger_helmet.src = "/assets/equipment/overlays/overlay_idle_charger_helmet.png";
/* ======================
   CANVAS
====================== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// Hit-flash uses an offscreen canvas; cache per sprite size.
const fxCache = new Map(); // key: "{w}x{h}" => { c, ctx }
function getFxCtx(w, h) {
  const key = `${w}x${h}`;
  let entry = fxCache.get(key);
  if (!entry) {
    const c = document.createElement("canvas");
    c.width = w;
    c.height = h;
    const ctx2 = c.getContext("2d");
    ctx2.imageSmoothingEnabled = false;
    entry = { c, ctx: ctx2 };
    fxCache.set(key, entry);
  }
  return entry;
}


/* ======================
   FADE TRANSITION
====================== */
let fadeState = "none";
let fadeA = 0;
let fadeTimer = 0;
let portalSent = false;
let portalWaitTimer = 0;

// Small local throttle to avoid spamming portal requests (server also enforces its own cooldown)
let nextPortalAtMs = 0;
const PORTAL_COOLDOWN_MS = 450;

const FADE_OUT_DUR = 0.18;
const FADE_IN_DUR  = 0.18;

function startPortalFade() {
  if (fadeState !== "none") return;

  const nowMs = performance.now();
  if (nowMs < nextPortalAtMs) return;
  nextPortalAtMs = nowMs + PORTAL_COOLDOWN_MS;

  fadeState = "fadingOut";
  fadeTimer = 0;
  fadeA = 0;
  portalSent = false;
  portalWaitTimer = 0;

  // Send portal request immediately
  portalSent = true;
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "portal" }));

  // Freeze movement instantly
  keys.up = keys.down = keys.left = keys.right = false;
  sendInput();
}

function updateFade(dt) {
  if (fadeState === "none") return;
  fadeTimer += dt;

  if (fadeState === "fadingOut") {
    fadeA = Math.min(fadeTimer / FADE_OUT_DUR, 1);
    if (fadeTimer >= FADE_OUT_DUR) {
      fadeState = "waitingMap";
      fadeA = 1;
      portalWaitTimer = 0;
    }
  } else if (fadeState === "waitingMap") {
    fadeA = 1;
    portalWaitTimer += dt;

    // Safety fallback — never stay black forever
    if (portalWaitTimer > 1.2) {
      fadeState = "fadingIn";
      fadeTimer = 0;
      levelToastText = "Portal failed — stand fully on portal and press E";
      levelToastUntilMs = performance.now() + 2400;
    }
  } else if (fadeState === "fadingIn") {
    fadeA = 1 - Math.min(fadeTimer / FADE_IN_DUR, 1);
    if (fadeTimer >= FADE_IN_DUR) {
      fadeState = "none";
      fadeA = 0;
    }
  }
}

function drawFadeOverlay() {
  if (fadeA <= 0) return;
  ctx.save();
  ctx.globalAlpha = fadeA;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
/* ======================
   NETWORK
====================== */
const WS_PROTO = (location.protocol === "https:") ? "wss" : "ws";
const ws = new WebSocket(`${WS_PROTO}://${location.host}`);


let myName = null;
let nameSent = false;

function promptForName() {
  // Only prompt once per page load unless rejected.
  while (true) {
    const raw = window.prompt("Enter your name (letters only, 4-8 chars):", myName || "") || "";
    const name = raw.trim();
    if (/^[A-Za-z]{4,8}$/.test(name)) {
      myName = name;
      if (ws.readyState === 1) {
        ws.send(JSON.stringify({ type: "setName", name }));
        nameSent = true;
      }
      break;
    }
    alert("Name must be letters only, 4-6 characters.");
  }
}

ws.addEventListener("open", () => {
  promptForName();
});


let myId = null;
let map = null;
let objMap = null;
let currentMapId = null;
let portals = []; // [{x,y,to,...}] current map portal positions

let worldPlayers = {};
let worldNpcs = {};
let worldMobs = {};

// Spawn fade-in tracking (client-side)
const MOB_SPAWN_FADE_MS = 200; // how long mobs fade in after spawning/respawning
const mobSpawnAtMs = new Map(); // mobId -> performance.now() when it became alive
let worldDrops = {};
let worldProjectiles = {};

const netState = new Map();

/* --- HIT FX STATE --- */
const hitFx = new Map();
let screenShakeUntilMs = 0;
let screenShakeMag = 0;

function startScreenShake(mag = 4, ms = 140) {
  screenShakeMag = Math.max(screenShakeMag, mag);
  screenShakeUntilMs = Math.max(screenShakeUntilMs, performance.now() + ms);
}

/* --- DAMAGE POPUPS --- */
const damagePops = []; // {x,y,text,color,untilMs}

/* --- LOOT POPUPS --- */
const lootPops = []; // {x,y,text,untilMs}

function upsertNet(id, x, y, now) {
  const WARP_DIST = TILE_SIZE * 3;

  if (!netState.has(id)) {
    netState.set(id, {
      prev: { x, y, t: now },
      curr: { x, y, t: now },
      vx: 0, vy: 0,
      smoothX: x, smoothY: y
    });
    return;
  }

  const s = netState.get(id);

  const dxWarp = x - s.curr.x;
  const dyWarp = y - s.curr.y;
  if (Math.hypot(dxWarp, dyWarp) > WARP_DIST) {
    s.prev = { x, y, t: now };
    s.curr = { x, y, t: now };
    s.vx = 0; s.vy = 0;
    s.smoothX = x; s.smoothY = y;
    return;
  }

  const old = s.curr;
  s.prev = s.curr;
  s.curr = { x, y, t: now };

  const dt = s.curr.t - old.t;
  if (dt > 0.0001) {
    s.vx = (s.curr.x - old.x) / dt;
    s.vy = (s.curr.y - old.y) / dt;
  }
}

let activeDialogue = null;

// level toast
let levelToastUntilMs = 0;
let levelToastText = "";

ws.onmessage = (e) => {
  const msg = JSON.parse(e.data);

  if (msg.type === "nameRejected") {
    // Re-prompt (server-side validation is source of truth)
    nameSent = false;
    setTimeout(promptForName, 0);
    return;
  }
  if (msg.type === "nameAccepted") {
    myName = msg.name || myName;
    return;
  }


  if (msg.type === "welcome") {
    myId = msg.id;
    map = msg.map;
    objMap = msg.objMap || objMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    currentMapId = msg.mapId ?? currentMapId;

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;
    return;
  }

  if (msg.type === "snapshot") {
    const now = performance.now() / 1000;

    const newMapId = msg.mapId ?? currentMapId;
    const mapChanged = (currentMapId != null && newMapId !== currentMapId);
    currentMapId = newMapId;

    if (msg.map) map = msg.map;
    if (msg.objMap) objMap = msg.objMap;
    objMap = msg.objMap || objMap;
    if (Array.isArray(msg.portals)) portals = msg.portals;

    if (typeof msg.tileSize === "number") TILE_SIZE = msg.tileSize;
    if (typeof msg.portalTile === "number") PORTAL_TILE = msg.portalTile;

    worldPlayers = msg.players || {};
    worldNpcs = msg.npcs || {};
    const prevMobs = worldMobs;
    worldMobs = msg.mobs || {};
    worldDrops = msg.drops || {};
	worldProjectiles = msg.projectiles || {};
    // Track mob spawn/respawn so we can fade them in smoothly
    const nowMs = performance.now();
    for (const [id, mob] of Object.entries(worldMobs)) {
      const prev = prevMobs ? prevMobs[id] : undefined;
      const wasDead = !!prev?.dead;
      const isAliveNow = !mob?.dead;
      const isNew = !prev;
      if (isAliveNow && (isNew || wasDead)) {
        mobSpawnAtMs.set(id, nowMs);
      }
    }
    // Clean up spawn timestamps for mobs that no longer exist
    for (const id of Array.from(mobSpawnAtMs.keys())) {
      if (!worldMobs[id]) mobSpawnAtMs.delete(id);
    }


    for (const [id, p] of Object.entries(worldPlayers)) upsertNet(id, p.x, p.y, now);
    for (const [id, n] of Object.entries(worldNpcs)) upsertNet(id, n.x, n.y, now);
    for (const [id, m0] of Object.entries(worldMobs)) upsertNet(id, m0.x, m0.y, now);

    const alive = new Set([
      ...Object.keys(worldPlayers),
      ...Object.keys(worldNpcs),
      ...Object.keys(worldMobs),
    ]);
    for (const id of Array.from(netState.keys())) if (!alive.has(id)) netState.delete(id);

	if (mapChanged) {
	  // Always resolve fade if map actually changed
	  fadeState = "fadingIn";
	  fadeTimer = 0;
	}

    return;
  }


  if (msg.type === "mapPatch") {
    // Small server-authoritative map edit (used by the in-game editor)
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    if (!Number.isInteger(tx) || !Number.isInteger(ty) || !Number.isInteger(tile)) return;
    if (!map || ty < 0 || tx < 0 || ty >= map.length || tx >= map[0].length) return;

    if (layer === "ground") {
      map[ty][tx] = tile;
    } else if (layer === "object") {
      if (!objMap) objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
      objMap[ty][tx] = tile;
    }
    return;
  }


  if (msg.type === "editAck") {
    // Server response for editor edits (helps diagnose why something "didn't work")
    const ok = !!msg.ok;
    const layer = String(msg.layer || "");
    const tx = Number(msg.x), ty = Number(msg.y), tile = Number(msg.tile);
    const reason = msg.reason ? String(msg.reason) : "";
    if (ok) {
      levelToastText = `Edit OK: ${layer} (${tx},${ty}) = ${tile}`;
    } else {
      levelToastText = `Edit REJECTED: ${layer} (${tx},${ty}) = ${tile}${reason ? ` (${reason})` : ""}`;
    }
    levelToastUntilMs = performance.now() + 2500;
    return;
  }


  if (msg.type === "dialogue") {
    activeDialogue = {
      npcId: msg.npcId,
      npcName: msg.npcName || msg.npcId,
      text: msg.text || "",
      untilMs: performance.now() + 4000
    };
    return;
  }

  if (msg.type === "hit") {
    const targetId = String(msg.targetId || "");
    const kind = msg.targetKind || "mob";
    const amount = Number(msg.amount || 0);

    const srcX = +msg.srcX || 0;
    const srcY = +msg.srcY || 0;

    let tx = 0, ty = 0;
    const rawP = worldPlayers[targetId];
    const rawM = worldMobs[targetId];

    if (rawP) { tx = rawP.x; ty = rawP.y; }
    else if (rawM) { tx = rawM.x; ty = rawM.y; }

    if (amount > 0 && (rawP || rawM)) {
      damagePops.push({
        x: tx,
        y: ty - 10,
        text: `-${amount}`,
        color: (kind === "player") ? "#ff6b6b" : "#ffffff",
        untilMs: performance.now() + 650
      });
    }

    const dx = tx - srcX;
    const dy = ty - srcY;
    const l = Math.hypot(dx, dy) || 1;
    const ax = dx / l, ay = dy / l;

    const isMe = (targetId === myId);

    hitFx.set(targetId, {
      untilMs: performance.now() + 220,
      color: (kind === "player") ? "rgba(255,0,0,0.45)" : "rgba(255,255,255,0.45)",
      bumpX: ax * 6,
      bumpY: ay * 6,
    });

    if (isMe) startScreenShake(5, 160);
    return;
  }

  if (msg.type === "levelup") {
    levelToastText = `LEVEL UP!  Lv ${msg.level}`;
    levelToastUntilMs = performance.now() + 1600;
    return;
  }

  if (msg.type === "loot") {
    const me = getMyPos();
    if (me && msg.kind === "gold") {
      lootPops.push({
        x: me.x,
        y: me.y - 18,
        text: `+${msg.amount}g`,
        untilMs: performance.now() + 700
      });
    }
    return;
  }
};

/* ======================
   INPUT
====================== */
const keys = { up:false, down:false, left:false, right:false };
let lastEPressed = 0;

function sendInput() {
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "input", ...keys }));
}

function setMoveKey(e, down) {
  if (fadeState !== "none") return;
  const k = e.key.toLowerCase();
  if (k === "w" || e.key === "ArrowUp") keys.up = down;
  if (k === "s" || e.key === "ArrowDown") keys.down = down;
  if (k === "a" || e.key === "ArrowLeft") keys.left = down;
  if (k === "d" || e.key === "ArrowRight") keys.right = down;
  sendInput();
}

function getMouseWorldFromEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  return { mx, my, wx: camX + mx, wy: camY + my };
}

function dirFromVector(dx, dy) {
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);
  if (ax < 1e-3 && ay < 1e-3) return null;
  if (ax > ay) return dx >= 0 ? DIR.RIGHT : DIR.LEFT;
  return dy >= 0 ? DIR.DOWN : DIR.UP;
}

function sendAttackAtWorld(wx, wy, mx = null, my = null) {
  const me = getMyPos();
  if (!me) return;

  // Derive aim direction from screen-space (mouse relative to the player's rendered position).
  // This avoids "opposite direction" when camera smoothing lags behind the server position.
  let dx = wx - me.x;
  let dy = wy - me.y;

  if (mx != null && my != null) {
    const px = (me.x - camX);
    const py = (me.y - camY);
    dx = mx - px;
    dy = my - py;
  }

  const d = dirFromVector(dx, dy);

  // drive local attack animation direction immediately
  if (d != null) {
    // Update facing immediately so the server sees your intended direction,
    // but DO NOT start a local swing animation here. We only animate when the server accepts the attack.
    const st = getAnim(myId, me.x, me.y);
    st.dir = d;
  }

  // normalized aim direction for the server (independent of camera lag)
  const len = Math.hypot(dx, dy) || 1;
  const aimDirX = dx / len;
  const aimDirY = dy / len;
  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "attack", aimX: wx, aimY: wy, aimDirX, aimDirY }));
}

function sendAttack() {
  const me = worldPlayers[myId];
  const wid = me?.equipment?.weapon;
  if (!wid) {
    levelToastText = "Equip a weapon to attack";
    levelToastUntilMs = performance.now() + 1800;
    return;
  }
  // fallback: attack in current facing (server will use last facing)
  const nowMs = performance.now();
  if (nowMs < nextAttackAtMs) return;
  nextAttackAtMs = nowMs + ATTACK_DELAY_MS;
  // Do not play local swing instantly; wait for server snapshot (p.atkAnim) so cooldown-rejected attacks don't animate.
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: "attack" }));
}

function sendInvClick(slot) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "invClick", slot }));
}

function sendUnequip(slotName) {
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "unequip", slot: slotName }));
}




window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();

  // Debug editor hotkeys
  if (e.key === "F1") {
    e.preventDefault();
    if (!e.repeat) {
      editorOpen = !editorOpen;
      // reset selection for layer
      editorTileIndex = 0;
      editorSetTileIndexByValue(0);
      levelToastText = editorOpen ? "Editor ON (TAB layer, [ ] tile, Ctrl+E export)" : "Editor OFF";
      levelToastUntilMs = performance.now() + 2200;
    }
    return;
  }

  // Debug collision overlay
  if (e.key === "F3") {
    e.preventDefault();
    if (!e.repeat) {
      debugHitboxes = !debugHitboxes;
      levelToastText = debugHitboxes ? "Hitboxes ON" : "Hitboxes OFF";
      levelToastUntilMs = performance.now() + 1600;
    }
    return;
  }

  if (editorOpen) {
    // Don't let movement keys interfere while editing unless you want them.
    if (e.key === "Tab") {
      e.preventDefault();
      editorLayer = (editorLayer === "ground") ? "object" : "ground";
      editorTileIndex = 0;
      editorSetTileIndexByValue(0);
      return;
    }

    if (e.key === "[") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex - 1 + list.length) % list.length;
      return;
    }
    if (e.key === "]") {
      e.preventDefault();
      const list = editorAllowedList();
      editorTileIndex = (editorTileIndex + 1) % list.length;
      return;
    }

    if (k === "g") {
      e.preventDefault();
      editorShowGrid = !editorShowGrid;
      return;
    }

    if (k === "c") {
      e.preventDefault();
      editorShowColl = !editorShowColl;
      return;
    }

    if (e.ctrlKey && k === "e") {
      e.preventDefault();
      exportCurrentMapToClipboard();
      return;
    }
  }



if (k === "i") {
  e.preventDefault();
  if (!e.repeat) {
    inventoryOpen = !inventoryOpen;
    // lazy init window position
    if (inventoryOpen && (invWinX == null || invWinY == null)) {
      // will be centered using current invWinW/H once drawInventory runs the first time
      invWinX = Math.floor(canvas.width / 2 - 180);
      invWinY = Math.floor(canvas.height / 2 - 180);
    }
  }
  return;
}
  if (k === "e") {
    e.preventDefault();
    const now = performance.now();
    if (!e.repeat && now - lastEPressed > 200) {
      lastEPressed = now;
      if (isOnPortal()) startPortalFade();
      else tryInteract();
    }
    return;
  }

  setMoveKey(e, true);
});
window.addEventListener("keyup", (e) => setMoveKey(e, false));

// Editor painting
canvas.addEventListener("contextmenu", (e) => {
  if (!editorOpen) return;
  e.preventDefault();
});

canvas.addEventListener("mousemove", (e) => {
  if (!editorOpen) return;
  const rect = canvas.getBoundingClientRect();
  editorMouseX = e.clientX - rect.left;
  editorMouseY = e.clientY - rect.top;
  editorMouseHas = true;
});

canvas.addEventListener("mouseleave", () => { editorMouseHas = false; });

canvas.addEventListener("mousedown", (e) => {
  if (!editorOpen) return;

  // If inventory is open and click is inside it, let inventory handle it.
  if (inventoryOpen && invUI) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // treat inventory window as a block region
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory mousedown run
    }
  }

  e.preventDefault();
  e.stopImmediatePropagation();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (!map) return;
  const tx = Math.floor((camX + mx) / TILE_SIZE);
  const ty = Math.floor((camY + my) / TILE_SIZE);
  if (tx < 0 || ty < 0 || ty >= map.length || tx >= map[0].length) return;

  const isRight = (e.button === 2);
  const tile = isRight ? 0 : editorSelectedTile();

  if (editorLayer === "ground") {
    // keep portals/statues intact (server also validates)
    const curr = map[ty][tx];
    if (curr === PORTAL_TILE) return;
    map[ty][tx] = tile;
    sendEditTile("ground", tx, ty, tile);
  } else {
    if (!objMap) {
      objMap = Array.from({length: map.length}, () => Array(map[0].length).fill(0));
    }
    objMap[ty][tx] = tile;
    sendEditTile("object", tx, ty, tile);
  }
});

// Inventory click handling (equip / use / consume)
canvas.addEventListener("mousedown", (e) => {
  if (!inventoryOpen || !invUI) return;

  // Inventory consumes clicks (including the close X) so they don't trigger attacks.
  e.preventDefault();
  e.stopImmediatePropagation();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // close button
  if (invCloseRect && mx >= invCloseRect.x && mx <= invCloseRect.x + invCloseRect.w && my >= invCloseRect.y && my <= invCloseRect.y + invCloseRect.h) {
    e.preventDefault();
    e.stopImmediatePropagation();
    inventoryOpen = false;
    invDragging = false;
    return;
  }

  // drag header (but not when clicking inside slots)
  if (invHeaderRect && mx >= invHeaderRect.x && mx <= invHeaderRect.x + invHeaderRect.w && my >= invHeaderRect.y && my <= invHeaderRect.y + invHeaderRect.h) {
    invDragging = true;
    invDragOffX = mx - invWinX;
    invDragOffY = my - invWinY;
    return;
  }

  // equipment slots
  for (const [slotName, r] of Object.entries(invUI.equipSlots)) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
      // If it is already equipped, unequip. If empty, server will ignore.
      sendUnequip(slotName);
      return;
    }
  }

  // inventory grid
  const g = invUI.grid;
  if (mx < g.x || my < g.y || mx > g.x + g.w || my > g.y + g.h) return;

  const sx = Math.floor((mx - g.x) / g.slotSize);
  const sy = Math.floor((my - g.y) / g.slotSize);
  if (sx < 0 || sy < 0 || sx >= g.cols || sy >= g.rows) return;

  const slotIndex = sy * g.cols + sx;
  sendInvClick(slotIndex);
});

window.addEventListener("mousemove", (e) => {
  if (!inventoryOpen || !invDragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  invWinX = Math.round(mx - invDragOffX);
  invWinY = Math.round(my - invDragOffY);

  // keep on-screen
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
});


// Click-to-attack (left mouse button). Determines attack direction by click quadrant.
// For wand, the click position determines projectile trajectory (server computes direction).
canvas.addEventListener("mousedown", (e) => {
  if (e.button !== 0) return; // left click only
  if (editorOpen) return; // editor uses clicks for painting
  if (inventoryOpen && invUI) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (mx >= invWinX && mx <= invWinX + invWinW && my >= invWinY && my <= invWinY + invWinH) {
      return; // let inventory consume the click
    }
  }

  // avoid selecting text / dragging
  e.preventDefault();

  const { mx, my, wx, wy } = getMouseWorldFromEvent(e);
  sendAttackAtWorld(wx, wy, mx, my);
});


window.addEventListener("mouseup", () => {
  invDragging = false;
});

/* ======================
   SMOOTH POS
====================== */
function getSmoothedPos(id, rawX, rawY) {
  const s = netState.get(id);
  if (!s) return { x: rawX, y: rawY };

  const renderTime = performance.now() / 1000 - INTERP_DELAY;

  const t0 = s.prev.t;
  const t1 = s.curr.t;

  let alpha = 0;
  if (t1 > t0) alpha = clamp((renderTime - t0) / (t1 - t0), 0, 1);
  alpha = easeInOut(alpha);

  let x = lerp(s.prev.x, s.curr.x, alpha);
  let y = lerp(s.prev.y, s.curr.y, alpha);

  if (renderTime > t1) {
    const extra = clamp(renderTime - t1, 0, 0.10);
    x = s.curr.x + s.vx * extra;
    y = s.curr.y + s.vy * extra;
  }

  const SMOOTHING = 0.15;
  s.smoothX = lerp(s.smoothX, x, SMOOTHING);
  s.smoothY = lerp(s.smoothY, y, SMOOTHING);

  return { x: s.smoothX, y: s.smoothY };
}

function getMyPos() {
  if (!myId) return null;
  const raw = worldPlayers[myId];
  if (!raw) return null;
  return getSmoothedPos(myId, raw.x, raw.y);
}

function getMyStats() {
  const raw = myId ? worldPlayers[myId] : null;
  return {
    hp: raw?.hp ?? 0,
    maxHp: raw?.maxHp ?? 1,
    level: raw?.level ?? 1,
    xp: raw?.xp ?? 0,
    xpNext: raw?.xpNext ?? 1,
    gold: raw?.gold ?? 0,
    equippedWeaponId: raw?.equipment?.weapon ?? null,
  };
}


/* ======================
   CAMERA + SHAKE
====================== */
let camX = 0;
let camY = 0;

function getWorldSize() {
  if (!map) return { w: 0, h: 0 };
  return { w: map[0].length * TILE_SIZE, h: map.length * TILE_SIZE };
}

function updateCamera() {
  const me = getMyPos();
  if (!me || !map) return;

  const viewW = canvas.width;
  const viewH = canvas.height;
  const world = getWorldSize();

  let targetX = me.x - viewW / 2;
  let targetY = me.y - viewH / 2;

  targetX = clamp(targetX, 0, Math.max(0, world.w - viewW));
  targetY = clamp(targetY, 0, Math.max(0, world.h - viewH));

  const CAM_SMOOTH = 0.18;
  camX = lerp(camX, targetX, CAM_SMOOTH);
  camY = lerp(camY, targetY, CAM_SMOOTH);

  camX = Math.round(camX);
  camY = Math.round(camY);
}

function getShakeOffset() {
  if (performance.now() > screenShakeUntilMs) return { x: 0, y: 0 };
  const t = (screenShakeUntilMs - performance.now()) / 160;
  const mag = Math.max(0, screenShakeMag) * clamp(t, 0, 1);
  return {
    x: Math.round((Math.random() * 2 - 1) * mag),
    y: Math.round((Math.random() * 2 - 1) * mag)
  };
}

/* ======================
   DRAW MAP
====================== */
function drawMap() {
  if (!map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const tile = map[y][x];
      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);

      if (tileImage.complete && tileImage.naturalWidth > 0) {
        const cell = TILE_SIZE + TILE_PAD;
        const col = tile % TILESET_COLS;
        const row = Math.floor(tile / TILESET_COLS);
        const sx = col * cell;
        const sy = row * cell;
        ctx.drawImage(tileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
      }



 else {
        ctx.fillStyle = tile === 1 ? "#555" : "#2b2b2b";
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}


/* ======================
   OBJECT LAYER (tiles_objects.png)
====================== */
function objTileRow1Based(objTile) {
  // objTile is 1-based for tiles_objects.png (0 = empty)
  if (!objTile) return 0;
  const idx0 = objTile - 1; // 0-based index in the sheet
  const row0 = Math.floor(idx0 / TILESET_COLS);
  return row0 + 1; // 1-based row
}

// Odd rows (1,3,5,...) are canopy: passable, drawn in the canopy pass on top of players
function isObjCanopy(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 1);
}

// Even rows (2,4,6,...) are solid: blocks movement and is depth-sorted with entities
function isObjSolid(objTile) {
  const r = objTileRow1Based(objTile);
  return r > 0 && (r % 2 === 0);
} // 1=tree canopy

function drawObjectTile(objTile, px, py) {
  if (!objTile) return;
  const cell = TILE_SIZE + TILE_PAD;
  const idx = objTile - 1; // object tiles use 1-based ids; 0=empty
  const col = idx % TILESET_COLS;
  const row = Math.floor(idx / TILESET_COLS);
  const sx = col * cell;
  const sy = row * cell;

  if (objTileImage.complete && objTileImage.naturalWidth > 0) {
    ctx.drawImage(objTileImage, sx, sy, TILE_SIZE, TILE_SIZE, px, py, TILE_SIZE, TILE_SIZE);
  } else {
    // fallback
    ctx.fillStyle = isObjCanopy(objTile) ? "#1f6" : "#888";
    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
  }
}

function drawObjects(pass) {
  if (!objMap || !map) return;

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
  const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

  for (let y = startTy; y <= endTy; y++) {
    for (let x = startTx; x <= endTx; x++) {
      const t = objMap[y][x];
      if (!t) continue;

      const canopy = isObjCanopy(t);
      if (pass === "below" && canopy) continue;
      if (pass === "canopy" && !canopy) continue;

      const px = Math.round(x * TILE_SIZE);
      const py = Math.round(y * TILE_SIZE);
      drawObjectTile(t, px, py);
    }
  }
}

/* ======================
   PORTAL + PROMPT
====================== */
function isOnPortal() {
  const me = getMyPos();
  if (!me) return false;
  // Use the same "feet" anchor as collision/sorting so you're standing on the portal tile.
  const tx = Math.floor(me.x / TILE_SIZE);
  const ty = Math.floor((me.y + DBG_PLAYER_FOOT_Y) / TILE_SIZE);
  if (!Number.isFinite(tx) || !Number.isFinite(ty)) return false;
  return Array.isArray(portals) && portals.some(p => p && p.x === tx && p.y === ty);
}
function drawPrompt(near, text = "Press E", spriteH = PLAYER_FRAME_H) {
  const anchor = snap2(near.x, near.y);

  ctx.font = "14px system-ui";
  ctx.textBaseline = "middle";
  const padding = 6;
  const w = Math.ceil(ctx.measureText(text).width + padding * 2);
  const h = 22;

  const x = Math.round(anchor.x - w/2);
  const y = Math.round(anchor.y - spriteH/2 - 18 - h);

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + padding, y + h/2);
}

/* ======================
   SPRITE ANIM
====================== */
const DIR = { DOWN:0, LEFT:1, RIGHT:2, UP:3 };
const animState = new Map();

function getAnim(id, x, y) {
  if (!animState.has(id)) {
    animState.set(id, { lastX:x, lastY:y, dir:DIR.DOWN, frame:0, walkT:0, sinceMove:999, dirLock:0, idleT:0, idleFrame:0 });
  }
  return animState.get(id);
}

function dirFromInput() {
  const h = (keys.right ? 1 : 0) + (keys.left ? -1 : 0);
  const v = (keys.down ? 1 : 0) + (keys.up ? -1 : 0);

  if (h !== 0 && v === 0) return h > 0 ? DIR.RIGHT : DIR.LEFT;
  if (v !== 0 && h === 0) return v > 0 ? DIR.DOWN : DIR.UP;
  return null;
}

function updateAnim(id, x, y, dt) {
  const st = getAnim(id, x, y);

  const dx = x - st.lastX;
  const dy = y - st.lastY;
  const ax = Math.abs(dx);
  const ay = Math.abs(dy);

  const moved = (ax + ay) > 0.02;
  st.dirLock = Math.max(0, st.dirLock - dt);

  if (moved) {
    if (id === myId) {
      // Don't let movement inputs overwrite facing while we're in a locked swing direction.
      if (st.dirLock <= 0) {
        const d = dirFromInput();
        if (d != null) st.dir = d;
      }
    } else {
      const DOM = 1.6;
      const LOCK = 0.14;

      let cand = st.dir;
      if (ax > ay * DOM) cand = dx >= 0 ? DIR.RIGHT : DIR.LEFT;
      else if (ay > ax * DOM) cand = dy >= 0 ? DIR.DOWN : DIR.UP;

      if (cand !== st.dir && st.dirLock <= 0) {
        st.dir = cand;
        st.dirLock = LOCK;
      }
    }
  }

  if (moved) st.sinceMove = 0;
  else st.sinceMove += dt;

  const moving = (id === myId)
    ? (keys.left || keys.right || keys.up || keys.down)
    : (st.sinceMove < 0.22);

  if (moving) {
    st.walkT += dt;
    // 4-step cadence: 1,2,1,3
    st.frame = WALK_SEQ[Math.floor(st.walkT * 8) % WALK_SEQ.length];
    st.idleT = 0;
    st.idleFrame = 0;
  } else {
    st.frame = 0;
    st.walkT = 0;

    // idle cadence (2 frames, slow)
    st.idleT += dt;
    if (st.idleT >= IDLE_FRAME_TIME) {
      st.idleT = 0;
      st.idleFrame = 1 - (st.idleFrame || 0);
    }
  }

  st.lastX = x;
  st.lastY = y;
  return st;
}

function drawSprite(img, x, y, dirRow, frameCol, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;
  x = Math.round(x); y = Math.round(y);
  const sx = frameCol * frameW;
  const sy = dirRow * frameH;
  const dx = x - frameW / 2;
  const dy = y - frameH / 2;
  ctx.drawImage(img, sx, sy, frameW, frameH, dx, dy, frameW, frameH);
}

/* ======================
   HIT FLASH (sprite-only)
====================== */
function drawHitTintOnTop(img, x, y, dirRow, frameCol, rgbaColor, frameW = NPC_FRAME_W, frameH = NPC_FRAME_H) {
  if (!img.complete || img.naturalWidth === 0) return;

  x = Math.round(x); y = Math.round(y);

  const sx = frameCol * frameW;
  const sy = dirRow * frameH;

  const { c: fxCanvas, ctx: fxCtx } = getFxCtx(frameW, frameH);

  // draw sprite frame into offscreen
  fxCtx.clearRect(0, 0, frameW, frameH);
  fxCtx.drawImage(img, sx, sy, frameW, frameH, 0, 0, frameW, frameH);

  // tint only the non-transparent pixels
  fxCtx.globalCompositeOperation = "source-atop";
  fxCtx.fillStyle = rgbaColor;
  fxCtx.fillRect(0, 0, frameW, frameH);
  fxCtx.globalCompositeOperation = "source-over";

  const dx = x - frameW / 2;
  const dy = y - frameH / 2;

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(fxCanvas, 0, 0, frameW, frameH, dx, dy, frameW, frameH);
  ctx.restore();
}

/* ======================
   ATTACK VISUALS
====================== */
function drawSwordSwing(x, y, dir, phase01) {
  x = Math.round(x); y = Math.round(y);
  const f = (phase01 < 0.33) ? 0 : (phase01 < 0.66 ? 1 : 2);

  const sets = {
    [DIR.RIGHT]: [
      // Closer to the body + slightly lower so side-swings don't "float".
      { blade:[12, -6, 16, 4], hilt:[10, -5, 4, 6] },
      { blade:[14,  4, 18, 4], hilt:[10,  3, 4, 6] },
      { blade:[12, 14, 16, 4], hilt:[10, 13, 4, 6] },
    ],
    [DIR.LEFT]: [
      { blade:[-28, -6, 16, 4], hilt:[-14, -5, 4, 6] },
      { blade:[-32,  4, 18, 4], hilt:[-14,  3, 4, 6] },
      { blade:[-28, 14, 16, 4], hilt:[-14, 13, 4, 6] },
    ],
    [DIR.DOWN]: [
      { blade:[-12, 18, 4, 16], hilt:[-14, 14, 6, 4] },
      { blade:[ -2, 22, 4, 18], hilt:[ -6, 14, 6, 4] },
      { blade:[  8, 18, 4, 16], hilt:[  4, 14, 6, 4] },
    ],
    [DIR.UP]: [
      { blade:[-12,-32, 4, 16], hilt:[-14,-20, 6, 4] },
      { blade:[ -2,-36, 4, 18], hilt:[ -6,-20, 6, 4] },
      { blade:[  8,-32, 4, 16], hilt:[  4,-20, 6, 4] },
    ],
  };

  const s = (sets[dir] || sets[DIR.DOWN])[f];

  ctx.save();
  ctx.fillStyle = "#111";
  ctx.fillRect(x + s.blade[0] - 1, y + s.blade[1] - 1, s.blade[2] + 2, s.blade[3] + 2);
  ctx.fillRect(x + s.hilt[0] - 1, y + s.hilt[1] - 1, s.hilt[2] + 2, s.hilt[3] + 2);

  ctx.fillStyle = "#e6e6e6";
  ctx.fillRect(x + s.blade[0], y + s.blade[1], s.blade[2], s.blade[3]);
  ctx.fillStyle = "#c9a227";
  ctx.fillRect(x + s.hilt[0], y + s.hilt[1], s.hilt[2], s.hilt[3]);
  ctx.restore();
}

function drawSpearThrust(x, y, dir, phase01, spearImg) {
  // Image-based spear thrust. Uses /assets/basic_spear.png (16x32, centered).
  // Visual-only; does not affect hit/collision logic.
  x = Math.round(x); y = Math.round(y);

  // --- Motion profile ---
  // Idea 1) "Slow start" (ease-in) so the first part feels weighted.
  // Idea 2) Brief linger at max extension, then retract a touch.
  const t = clamp(phase01, 0, 1);

  const OUT  = 0.55; // time to extend
  const HOLD = 0.18; // linger at full extension
  const BACK = 1 - OUT - HOLD; // time to retract

  function easeInCubic(u) { return u * u * u; }
  function easeSmooth(u) { return u * u * (3 - 2 * u); } // same as easeInOut()

  let prog = 0; // 0..1 extension amount
  if (t < OUT) {
    const u = clamp(t / OUT, 0, 1);
    prog = easeInCubic(u);          // slow start, fast finish
  } else if (t < OUT + HOLD) {
    prog = 1;                       // linger at max
  } else {
    const u = clamp((t - OUT - HOLD) / BACK, 0, 1);
    prog = 1 - 0.18 * easeSmooth(u); // retract ~18% so it doesn't "snap off"
  }

  const MAX_THRUST = 18;            // pixels pushed outward
  const thrust = Math.round(prog * MAX_THRUST);

  // Hand anchors (relative to player's 64x64 sprite top-left).
  // Per-direction (because each facing pose holds the "hands" differently).
  const hand = ({
    [DIR.RIGHT]: { x: -10, y: 15 },
    [DIR.LEFT]:  { x: 10, y: 15 }, // (you tuned this; keeping as-is)
    [DIR.DOWN]:  { x: -10, y: 5 },
    [DIR.UP]:    { x: 10, y: 25 },
  }[dir] || { x: 32, y: 32 });

  const px = x + hand.x;
  const py = y + hand.y;

  // If the sprite isn't loaded yet, fall back to a simple rectangle spear so nothing breaks.
  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  // Move outward along the facing direction (in world space).
  // We apply thrust before rotation by translating in direction coords.
  if (dir === DIR.RIGHT) ctx.translate(thrust, 0);
  if (dir === DIR.LEFT)  ctx.translate(-thrust, 0);
  if (dir === DIR.DOWN)  ctx.translate(0, thrust);
  if (dir === DIR.UP)    ctx.translate(0, -thrust);

  ctx.rotate(ang);

  // Make the spear longer without needing new art.
  // The base sprite is vertical, so scaleY extends length (after rotation it extends along the thrust direction).
  const SPEAR_SCALE_Y = 2.5; // (you tuned this; keeping as-is)
  ctx.scale(1, SPEAR_SCALE_Y);

  if (ready) {
    // The spear is centered in a 16x32 image with trim. We anchor the "grip" near the bottom center.
    const gripX = 8;   // center of 16px
    const gripY = 26;  // near bottom where hands hold it (before scaling)
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, 16, 32);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}



function drawSpearHeld(x, y, dir, spearImg) {
  // Persistent spear when equipped (not attacking).
  // Uses the same /assets/basic_spear.png sprite as the thrust, but with no thrust motion.
  x = Math.round(x); y = Math.round(y);

  // Same hand anchors as the thrust so it stays “in the hands”
  const hand = ({
    [DIR.RIGHT]: { x: -10, y: 15 },
    [DIR.LEFT]:  { x: 10, y: 15 },
    [DIR.DOWN]:  { x: -10, y: 5 },
    [DIR.UP]:    { x: 10, y: 25 },
  }[dir] || { x: 32, y: 32 });

  const px = x + hand.x;
  const py = y + hand.y;

  const img = spearImg;
  const ready = img && img.complete && img.naturalWidth > 0;

  ctx.save();
  ctx.translate(px, py);

  // Rotate the vertical sprite (tip-up) to match direction.
  let ang = 0;
  if (dir === DIR.RIGHT) ang = Math.PI / 2;
  else if (dir === DIR.LEFT) ang = -Math.PI / 2;
  else if (dir === DIR.DOWN) ang = Math.PI;
  // DIR.UP stays 0

  ctx.rotate(ang);

  // Slightly shorter than the attack extension so it reads as “held”
  const SPEAR_HELD_SCALE_Y = 2.0;
  ctx.scale(1, SPEAR_HELD_SCALE_Y);

  if (ready) {
    const gripX = 8;
    const gripY = 26;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, -gripX, -gripY, 16, 32);
  } else {
    // Fallback: simple spear (same anchor idea)
    ctx.fillStyle = "#7a5a2a";
    ctx.fillRect(-2, -24, 4, 28);
    ctx.fillStyle = "#cfd2d6";
    ctx.fillRect(-3, -28, 6, 6);
  }

  ctx.restore();
}


function drawWandCastSpark(x, y, dir, phase01) {
  // tiny “spark” near hand to show casting
  x = Math.round(x); y = Math.round(y);
  const a = 1 - Math.abs(phase01 - 0.5) * 2;
  if (a <= 0) return;

  let sx = x, sy = y;
  if (dir === DIR.RIGHT) { sx = x + 16; sy = y - 4; }
  if (dir === DIR.LEFT)  { sx = x - 16; sy = y - 4; }
  if (dir === DIR.DOWN)  { sx = x + 6;  sy = y + 12; }
  if (dir === DIR.UP)    { sx = x - 6;  sy = y - 18; }

  ctx.save();
  ctx.globalAlpha = clamp(a, 0, 1);
  ctx.fillStyle = "#bde0fe";
  ctx.fillRect(sx - 2, sy - 2, 4, 4);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(sx - 1, sy - 1, 2, 2);
  ctx.restore();
}

/* ======================
   PROJECTILE DRAW
====================== */
function drawProjectile(pr) {
  const x = Math.round(pr.x);
  const y = Math.round(pr.y);

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x - 5, y - 5, 10, 10);

  ctx.fillStyle = "#9bf6ff";
  ctx.fillRect(x - 3, y - 3, 6, 6);

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(x - 1, y - 1, 2, 2);
  ctx.restore();
}

/* ======================
   COIN DRAW
====================== */
function drawCoin(x, y, amount) {
  x = Math.round(x); y = Math.round(y);

  const cx = x - 5;
  const cy = y + 10;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(cx - 1, cy - 1, 12, 12);

  ctx.fillStyle = "#f1c40f";
  ctx.fillRect(cx + 2, cy + 1, 6, 8);
  ctx.fillStyle = "#ffd966";
  ctx.fillRect(cx + 3, cy + 2, 4, 6);

  if (amount >= 4) {
    ctx.font = "10px system-ui";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#fff";
    ctx.fillText(String(amount), cx + 12, cy + 1);
  }
  ctx.restore();
}

const itemSprites = {
  orange_flan: new Image(),
};
itemSprites.orange_flan.src = "/assets/items/orange_flan.png";

function drawItemDrop(itemId, x, y) {
  const img = itemSprites[itemId];
  if (!img) return;
  if (!img.complete) return;
  const w = 24, h = 24;
  ctx.drawImage(img, Math.round(x - w/2), Math.round(y - h/2), w, h);
}


/* ======================
   MOB HP BAR
====================== */
function drawHpBarWorld(x, y, hp, maxHp, spriteH = MOB_FRAME_H) {
  const w = 34, h = 6;
  const pct = clamp((maxHp ? hp / maxHp : 0), 0, 1);
  const bx = Math.round(x - w/2);
  const by = Math.round(y - spriteH/2 - 10);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(bx, by, w, h);
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(bx + 1, by + 1, Math.round((w - 2) * pct), h - 2);
}

/* ======================
   NPC INTERACTION
====================== */
let cachedNearestNpc = null;

function computeNearestNpc() {
  const me = getMyPos();
  if (!me) return null;

  let best = null;
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    const d = dist(me.x, me.y, pos.x, pos.y);
    if (d <= INTERACT_DIST && (!best || d < best.d)) best = { id, d, x: pos.x, y: pos.y, name: n.name || id };
  }
  return best;
}

function tryInteract() {
  if (!cachedNearestNpc) return;
  if (ws.readyState !== 1) return;
  ws.send(JSON.stringify({ type: "interact", npcId: cachedNearestNpc.id }));
}

function drawDialogueBubble(d) {
  if (!d) return;
  if (performance.now() > d.untilMs) { activeDialogue = null; return; }

  const npcRaw = worldNpcs[d.npcId];
  if (!npcRaw) return;

  const npcPosF = getSmoothedPos(d.npcId, npcRaw.x, npcRaw.y);
  const npcPos = snap2(npcPosF.x, npcPosF.y);

  const lines = [`${d.npcName}:`, d.text];

  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";

  const padding = 8;
  let w = 0;
  for (const line of lines) w = Math.max(w, ctx.measureText(line).width);
  w = Math.ceil(w);

  const lineH = 18;
  const h = padding*2 + lineH*lines.length;

  let x = clamp(npcPos.x - w/2 - padding, camX + 8, camX + canvas.width - (w + padding*2) - 8);
  let y = clamp(npcPos.y - NPC_DRAW_H/2 - h - 18, camY + 8, camY + canvas.height - h - 8);

  x = Math.round(x);
  y = Math.round(y);

  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(x, y, w + padding*2, h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w + padding*2 - 1, h - 1);

  ctx.fillStyle = "#fff";
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], x + padding, y + padding + i*lineH);
  }
}

/* ======================
   HUD
====================== */
function drawHud() {
  const { hp, maxHp, xp, xpNext } = getMyStats();
  const hpPct = clamp(maxHp ? hp / maxHp : 0, 0, 1);
  const xpPct = clamp(xpNext ? xp / xpNext : 0, 0, 1);

  const x = 14, y = 14, w = 170, h = 14;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 10, y - 10, w + 20, 78);

  // HP
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = "#ff4757";
  ctx.fillRect(x, y, Math.round(w * hpPct), h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

  // XP
  const y2 = y + 22;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y2, w, h);
  ctx.fillStyle = "#4dabf7";
  ctx.fillRect(x, y2, Math.round(w * xpPct), h);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x + 0.5, y2 + 0.5, w - 1, h - 1);

  ctx.fillStyle = "#fff";
  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";
  ctx.fillText(`XP ${xp}/${xpNext}`, x, y2 + h + 6);
  ctx.fillText(`(I) Inventory`, x, y2 + h + 26);

  ctx.restore();
}


/* ======================
   DEBUG EDITOR OVERLAY
====================== */
function drawEditorOverlay() {
  if (!editorOpen || !map) return;

  // World-space overlays (grid/collision/hover). We keep the editor panel in screen-space,
  // but these need to align to the tilemap, so apply the camera offset here.
  ctx.save();
  ctx.translate(-camX, -camY);

  const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
  const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
  const endTx = Math.min(map[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE));
  const endTy = Math.min(map.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE));

  if (editorShowGrid) {
    // Grid should be in world-space (aligned to tiles), so we draw it using world coords.
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    for (let x = startTx; x <= endTx + 1; x++) {
      const px = x * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(px, startTy * TILE_SIZE);
      ctx.lineTo(px, (endTy + 1) * TILE_SIZE);
      ctx.stroke();
    }
    for (let y = startTy; y <= endTy + 1; y++) {
      const py = y * TILE_SIZE + 0.5;
      ctx.beginPath();
      ctx.moveTo(startTx * TILE_SIZE, py);
      ctx.lineTo((endTx + 1) * TILE_SIZE, py);
      ctx.stroke();
    }
  }

  // Collision overlay (helps distinguish floor vs wall even if tiles look similar)
  if (editorShowColl) {
    for (let y = startTy; y <= endTy; y++) {
      for (let x = startTx; x <= endTx; x++) {
        const g = map[y][x];
        const o = (objMap && objMap[y] ? objMap[y][x] : 0);

        if (g === 1) {
          ctx.strokeStyle = "rgba(255,80,80,0.70)";
          ctx.strokeRect(x * TILE_SIZE + 1.5, y * TILE_SIZE + 1.5, TILE_SIZE - 3, TILE_SIZE - 3);
        } else if (o === 2 || o === 6) {
          ctx.strokeStyle = "rgba(255,190,80,0.65)";
          ctx.strokeRect(x * TILE_SIZE + 3.5, y * TILE_SIZE + 3.5, TILE_SIZE - 7, TILE_SIZE - 7);
        }
      }
    }
  }


  // Hover highlight
  if (editorMouseHas) {
    const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
    const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
    if (tx >= 0 && ty >= 0 && ty < map.length && tx < map[0].length) {
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.strokeRect(tx * TILE_SIZE + 0.5, ty * TILE_SIZE + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
    }
  }

  ctx.restore();

  // Screen-space panel
  const list = editorAllowedList();
  const sel = editorSelectedTile();
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.65)";
  ctx.fillRect(14, canvas.height - 110, 360, 96);
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(14.5, canvas.height - 109.5, 359, 95);

  ctx.fillStyle = "#fff";
  ctx.font = "14px system-ui";
  ctx.textBaseline = "top";

  const y = canvas.height - 102;
  ctx.fillText("EDITOR (F1)", 26, y);
  ctx.fillText(`Layer: ${editorLayer.toUpperCase()} (TAB)`, 26, y + 20);
  ctx.fillText(`Tile: ${sel}  Allowed: [${list.join(", ")}]  ([ / ])`, 26, y + 40);

  // Tile preview (shows the currently selected brush)
  const prevX = 26 + 360;
  const prevY = y + 8;
  const prevS = 48; // preview size (1x tile)
  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(prevX - 6, prevY - 6, prevS + 12, prevS + 12);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(prevX - 6, prevY - 6, prevS + 12, prevS + 12);

  // If object layer and sel==0, draw a simple checker (empty)
  if (editorLayer === "object" && sel === 0) {
    const cs = 8;
    for (let yy = 0; yy < prevS; yy += cs) {
      for (let xx = 0; xx < prevS; xx += cs) {
        ctx.fillStyle = ((xx / cs + yy / cs) % 2 === 0) ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.08)";
        ctx.fillRect(prevX + xx, prevY + yy, cs, cs);
      }
    }
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.fillText("EMPTY", prevX + 6, prevY + prevS - 8);
  } else {
    const img = (editorLayer === "object") ? objTileImage : tileImage;
    const tileIndex = (editorLayer === "object") ? (Math.max(1, sel) - 1) : sel;
    const col = tileIndex % TILESET_COLS;
    const row = Math.floor(tileIndex / TILESET_COLS);
    const sx = col * (TILE_SIZE + TILE_PAD);
    const sy = row * (TILE_SIZE + TILE_PAD);
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, sx, sy, TILE_SIZE, TILE_SIZE, prevX, prevY, prevS, prevS);
    } else {
      // fallback if image not loaded yet
      ctx.fillStyle = "rgba(255,255,255,0.15)";
      ctx.fillRect(prevX, prevY, prevS, prevS);
    }
  }
  ctx.restore();
  let under = "";
  if (editorMouseHas) {
    const tx = Math.floor((camX + editorMouseX) / TILE_SIZE);
    const ty = Math.floor((camY + editorMouseY) / TILE_SIZE);
    if (tx >= 0 && ty >= 0 && ty < map.length && tx < map[0].length) {
      const g = map[ty][tx];
      const o = (objMap && objMap[ty] ? objMap[ty][tx] : 0);
      under = ` | Under cursor: G=${g} O=${o} @(${tx},${ty})`;
    }
  }
  ctx.fillText(`Left=paint  Right=erase  G=grid  C=coll  Ctrl+E=export${under}`, 26, y + 60);
  ctx.restore();
}

/* ======================
   INVENTORY UI (MapleStory-style)
====================== */
function drawInventory(inv, equipment) {
  const cols = 6;
  const rows = 4;
  const slotSize = 48;

  const HEADER_H = 26;
  const PAD = 14;

  const panelW = cols * slotSize + PAD * 2;

  // Equipment row layout
  // (we compute panelH from where the grid ends so nothing gets cut off)

  // Equipment row layout
  // position (draggable)
  // If this is the first draw after opening, center it.
  if (invWinX == null || invWinY == null) {
    invWinX = Math.floor(canvas.width / 2 - panelW / 2);
    invWinY = Math.floor(canvas.height / 2 - 220);
  }

  let startX = invWinX;
  let startY = invWinY;

  const eqY = startY + HEADER_H + 18;
  const eqX = startX + PAD;
  const eqGap = 12;

  const equipSlots = {
    weapon:    { x: eqX + 0 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    armor:     { x: eqX + 1 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    hat:       { x: eqX + 2 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
    accessory: { x: eqX + 3 * (slotSize + eqGap), y: eqY, w: slotSize, h: slotSize },
  };

  // Inventory grid layout
  const gridX = startX + PAD;
  const gridY = eqY + slotSize + 26;

  const panelH = (gridY + rows * slotSize + PAD) - startY;

  // cache window size for clamping drag
  invWinW = panelW;
  invWinH = panelH;

  // keep within canvas (in case screen size changed)
  invWinX = clamp(invWinX, 8, canvas.width - invWinW - 8);
  invWinY = clamp(invWinY, 8, canvas.height - invWinH - 8);
  startX = invWinX;
  startY = invWinY;

  // Close button + header rects
  const closeSize = 18;
  invCloseRect = {
    x: startX + panelW - closeSize - 8,
    y: startY + 4,
    w: closeSize,
    h: closeSize
  };
  invHeaderRect = {
    x: startX,
    y: startY,
    w: panelW,
    h: HEADER_H
  };

  // Cache layout for click handling
  invUI = {
    equipSlots,
    grid: {
      x: gridX,
      y: gridY,
      cols,
      rows,
      slotSize,
      w: cols * slotSize,
      h: rows * slotSize
    }
  };

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.fillRect(startX, startY, panelW, panelH);

  // header bar (drag handle)
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(startX, startY, panelW, HEADER_H);

  // header title
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Inventory", startX + PAD, startY + Math.floor(HEADER_H / 2));

  // close button
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(invCloseRect.x, invCloseRect.y, invCloseRect.w, invCloseRect.h);
  ctx.fillStyle = "#ddd";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("X", invCloseRect.x + invCloseRect.w / 2, invCloseRect.y + invCloseRect.h / 2 + 0.5);
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.font = "12px system-ui";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ddd";
  ctx.fillText("Equipment", startX + PAD, startY + HEADER_H + 2);

  // Draw equipment slots
  const eq = equipment || {};
  const labels = { weapon: "Wpn", armor: "Arm", hat: "Hat", accessory: "Acc" };

  for (const slotName of ["weapon", "armor", "hat", "accessory"]) {
    const r = equipSlots[slotName];
    ctx.strokeStyle = "#aaa";
    ctx.strokeRect(r.x, r.y, r.w, r.h);

    // label
    ctx.fillStyle = "#bbb";
    ctx.fillText(labels[slotName], r.x + 6, r.y + r.h + 2);

    const itemId = eq[slotName];
    if (itemId) {
      // icon first, fallback to text if unknown
      const drew = drawItemIcon(itemId, r.x, r.y, r.w);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(itemId, r.x + 4, r.y + 16);
      }
    }
  }

  ctx.fillStyle = "#ddd";
  ctx.fillText("Items", startX + PAD, gridY - 18);

  // Draw inventory grid
  const slots = inv?.slots || [];
  for (let i = 0; i < cols * rows; i++) {
    const x = gridX + (i % cols) * slotSize;
    const y = gridY + Math.floor(i / cols) * slotSize;

    ctx.strokeStyle = "#888";
    ctx.strokeRect(x, y, slotSize, slotSize);

    const slot = slots[i];
    if (slot) {
      // highlight if this exact item is equipped in any slot
      const isEquipped = (slot.id === eq.weapon || slot.id === eq.armor || slot.id === eq.hat || slot.id === eq.accessory);
      if (isEquipped) {
        ctx.save();
        ctx.globalAlpha = 0.20;
        ctx.fillStyle = "#fff";
        ctx.fillRect(x, y, slotSize, slotSize);
        ctx.restore();
      }

      // icon first, fallback to text if unknown
      const drew = drawItemIcon(slot.id, x, y, slotSize);
      if (!drew) {
        ctx.fillStyle = "#fff";
        ctx.fillText(slot.id, x + 4, y + 6);
      }

      // stack count
      if (slot.qty > 1) {
        const txt = String(slot.qty);
        ctx.save();
        ctx.font = "12px system-ui";
        ctx.textAlign = "right";
        ctx.textBaseline = "bottom";
        const tx = x + slotSize - 6;
        const ty = y + slotSize - 6;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.strokeText(txt, tx, ty);
        ctx.fillStyle = "#fff";
        ctx.fillText(txt, tx, ty);
        ctx.restore();
      }
    }
  }

  ctx.restore();
}

function drawLootPops() {
  const now = performance.now();
  for (let i = lootPops.length - 1; i >= 0; i--) {
    const p = lootPops[i];
    if (now > p.untilMs) { lootPops.splice(i, 1); continue; }
    const t = 1 - ((p.untilMs - now) / 700);
    const y = p.y - Math.round(t * 14);

    ctx.save();
    ctx.font = "14px system-ui";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ffd966";
    ctx.fillText(p.text, Math.round(p.x), Math.round(y));
    ctx.restore();
  }
}

/* ======================
   DAMAGE POPUPS DRAW
====================== */
function drawDamagePops() {
  const now = performance.now();
  for (let i = damagePops.length - 1; i >= 0; i--) {
    const d = damagePops[i];
    if (now > d.untilMs) { damagePops.splice(i, 1); continue; }

    const life = 650;
    const t = 1 - ((d.untilMs - now) / life);
    const rise = Math.round(t * 18);
    const alpha = clamp(1 - t, 0, 1);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = "bold 14px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.7)";
    ctx.strokeText(d.text, Math.round(d.x), Math.round(d.y - rise));

    ctx.fillStyle = d.color || "#fff";
    ctx.fillText(d.text, Math.round(d.x), Math.round(d.y - rise));
    ctx.restore();
  }
}

/* ======================
   LEVEL TOAST
====================== */
function drawLevelToast() {
  if (performance.now() > levelToastUntilMs) return;

  ctx.save();
  ctx.font = "24px system-ui";
  ctx.textBaseline = "middle";

  const text = levelToastText || "LEVEL UP!";
  const w = Math.ceil(ctx.measureText(text).width);
  const x = Math.round(canvas.width / 2 - w / 2);
  const y = Math.round(canvas.height * 0.18);

  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(x - 12, y - 18, w + 24, 36);
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.strokeRect(x - 11.5, y - 17.5, w + 23, 35);

  ctx.fillStyle = "#fff";
  ctx.fillText(text, x, y);
  ctx.restore();
}


/* ======================
   NAMEPLATE
====================== */
function drawNameplate(x, y, level, name, spriteH = PLAYER_FRAME_H) {
  if (!name) return;

  const lvl = String(level ?? 1);
  const nameText = String(name);

  ctx.save();
  ctx.font = "12px system-ui";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  const padX = 6;
  const h = 18;

  // measure pieces
  const badgePad = 8;
  const badgeW = Math.max(18, Math.ceil(ctx.measureText(lvl).width + badgePad));
  const gap = 6;
  const nameW = Math.ceil(ctx.measureText(nameText).width);

  const w = padX + badgeW + gap + nameW + padX;

  const bx = Math.round(x - w / 2);
  // closer to player (was -20)
  const by = Math.round(y - spriteH / 2 - 20);

  // main plate (dark, subtle)
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(bx, by, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.22)";
  ctx.strokeRect(bx + 0.5, by + 0.5, w - 1, h - 1);

  // level badge: white with black text (black-on-white)
  const badgeX = bx + padX;
  const badgeY = by + 2;
  const badgeH = h - 4;

  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.fillRect(badgeX, badgeY, badgeW, badgeH);
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.strokeRect(badgeX + 0.5, badgeY + 0.5, badgeW - 1, badgeH - 1);

  // level text centered inside badge
  ctx.fillStyle = "rgba(0,0,0,0.95)";
  ctx.textAlign = "center";
  ctx.fillText(lvl, badgeX + badgeW / 2, by + h / 2);

  // name text to the right (no bleeding into badge)
  ctx.textAlign = "left";
  ctx.fillStyle = "#fff";
  ctx.fillText(nameText, badgeX + badgeW + gap, by + h / 2);

  ctx.restore();
}



/* ======================
   MAIN LOOP
====================== */
let last = performance.now();


function drawPortals() {
  if (!portals) return;

  const t = performance.now() * 0.004;
  const pulse = (Math.sin(t) + 1) * 0.5;

  for (const p of portals) {
    const x = p.x * TILE_SIZE;
    const y = p.y * TILE_SIZE;

    ctx.save();
    ctx.globalAlpha = 0.4 + pulse * 0.3;
    ctx.strokeStyle = "#7fffd4";
    ctx.lineWidth = 3;

    const r = TILE_SIZE * (0.35 + pulse * 0.05);
    ctx.beginPath();
    ctx.arc(
      x + TILE_SIZE / 2,
      y + TILE_SIZE / 2,
      r,
      0,
      Math.PI * 2
    );
    ctx.stroke();
    ctx.restore();
  }
}


function loop(nowMs) {
  const dt = (nowMs - last) / 1000;
  last = nowMs;

  try {

  updateCamera();
  updateFade(dt);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw nameplates last (above canopies)
  const nameplates = [];

  const shake = getShakeOffset();

  ctx.save();
  ctx.translate(-camX + shake.x, -camY + shake.y);

  drawMap();
  drawPortals();
  drawPortals();
  // drawObjects("below"); // non-canopy objects are now depth-sorted with entities

  // drops behind entities
  for (const d of Object.values(worldDrops)) {
    const itemId = d.itemId || "coin";
    if (itemId === "coin") drawCoin(d.x, d.y, d.amount || d.qty || 1);
    else drawItemDrop(itemId, d.x, d.y);
  }

  // projectiles behind entities (feels good for bolts)
  for (const pr of Object.values(worldProjectiles)) {
    drawProjectile(pr);
  }

  const me = getMyPos();
  if (me && isOnPortal()) drawPrompt(me, "Press E to travel");

  cachedNearestNpc = computeNearestNpc();
  if (cachedNearestNpc) drawPrompt(cachedNearestNpc, "Press E", NPC_DRAW_H);

  const entities = [];

  // object-layer solids (stumps/rocks) depth-sort with entities so you can walk behind them
  if (objMap) {
    const startTx = Math.max(0, Math.floor(camX / TILE_SIZE));
    const startTy = Math.max(0, Math.floor(camY / TILE_SIZE));
    const endTx = Math.min(objMap[0].length - 1, Math.floor((camX + canvas.width) / TILE_SIZE) + 1);
    const endTy = Math.min(objMap.length - 1, Math.floor((camY + canvas.height) / TILE_SIZE) + 1);

    for (let oy = startTy; oy <= endTy; oy++) {
      for (let ox = startTx; ox <= endTx; ox++) {
        const ot = objMap[oy][ox];
        if (!ot) continue;
        if (isObjCanopy(ot)) continue; // canopies are drawn in a separate pass on top
        const px = ox * TILE_SIZE;
        const py = oy * TILE_SIZE;
        entities.push({
          kind: "obj",
          id: `obj:${ox},${oy}:${ot}`,
          tile: ot,
          px,
          py,
          // sort by bottom of tile so players can walk "in front of" or "behind" the base
          sortY: py + TILE_SIZE,
        });
      }
    }
  }

  for (const [id, p] of Object.entries(worldPlayers)) {
    const pos = getSmoothedPos(id, p.x, p.y);
    // IMPORTANT: use a feet anchor for depth sorting (keep render position unchanged)
    // 64x64 sprites: feet are ~22px below the sprite center.
    entities.push({ kind:"player", id, x: pos.x, y: pos.y, sortY: pos.y + 22 });
  }
  for (const [id, n] of Object.entries(worldNpcs)) {
    const pos = getSmoothedPos(id, n.x, n.y);
    entities.push({ kind:"npc", id, x: pos.x, y: pos.y, sortY: pos.y + NPC_SORT_Y_OFFSET });
  }
  for (const [id, m0] of Object.entries(worldMobs)) {
    const pos = getSmoothedPos(id, m0.x, m0.y);
    entities.push({ kind:"mob", id, x: pos.x, y: pos.y, sortY: pos.y });
  }

  // Depth sort using an explicit anchor when provided.
  entities.sort((a,b) => (a.sortY ?? a.y) - (b.sortY ?? b.y));

  for (const e of entities) {
    if (e.kind === "obj") {
      drawObjectTile(e.tile, e.px, e.py);
      continue;
    }

    const st = updateAnim(e.id, e.x, e.y, dt);

    const fx = hitFx.get(e.id);
    let bumpX = 0, bumpY = 0;
    if (fx && performance.now() < fx.untilMs) {
      const t = (fx.untilMs - performance.now()) / 220;
      bumpX = (fx.bumpX || 0) * t;
      bumpY = (fx.bumpY || 0) * t;
    } else if (fx) {
      hitFx.delete(e.id);
    }

    const drawX = e.x + bumpX;
    const drawY = e.y + bumpY;


    // Static NPC rendering (single-image NPCs)
    if (e.kind === "npc") {
      const n = worldNpcs[e.id] || {};
      const key = n.sprite || null;
      const img = key ? (npcImages[key] || null) : null;

      if (img && img.complete && img.naturalWidth > 0) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, Math.round(drawX - NPC_DRAW_W/2), Math.round(drawY - NPC_DRAW_H/2), NPC_DRAW_W, NPC_DRAW_H);
      } else {
        // Fallback: draw legacy npc sheet if image not loaded yet
        drawSprite(npcSprite, drawX, drawY, st.dir, st.frame, NPC_FRAME_W, NPC_FRAME_H);
      }
      continue;
    }

    if (e.kind === "mob") {
      const mob = worldMobs[e.id];
      const type = mob?.mobType || "purple";
      const sprite = (type === "orange") ? mobSprites.orange : mobSprites.purple;

      // Death "corpse" animation (no new sprites): persist 2s, slight shrink + fade at the end.
      const isCorpse = !!mob?.dead && (mob.corpseMs > 0);
      if (isCorpse) {
        const elapsed = clamp((CORPSE_TOTAL_MS - mob.corpseMs) / CORPSE_TOTAL_MS, 0, 1);
        const s = 1 - 0.12 * elapsed; // subtle shrink
        const alpha = (mob.corpseMs <= CORPSE_FADE_MS) ? clamp(mob.corpseMs / CORPSE_FADE_MS, 0, 1) : 1;

        // Draw with transform so shrink is centered on the mob.
        if (sprite.complete && sprite.naturalWidth) {
          const dirRow = st.dir, frameCol = st.frame;
          const sx = frameCol * MOB_FRAME_W;
          const sy = dirRow * MOB_FRAME_H;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.translate(Math.round(drawX), Math.round(drawY));
          ctx.scale(s, s);
          ctx.drawImage(sprite, sx, sy, MOB_FRAME_W, MOB_FRAME_H, -MOB_FRAME_W/2, -MOB_FRAME_H/2, MOB_FRAME_W, MOB_FRAME_H);
          ctx.restore();
        }

        // Keep HP bar at 0 HP while the corpse is still fully visible,
        // but hide it the moment the corpse starts fading out.
        // (Fade begins during the last CORPSE_FADE_MS.)
        if (mob && mob.corpseMs > CORPSE_FADE_MS) {
          const me = getMyPos();
          // Only show mob HP bars when you're close enough (reduces screen clutter)
          if (!me || dist(me.x, me.y, drawX, drawY) <= MOB_HPBAR_DIST) {
            drawHpBarWorld(drawX, drawY, 0, mob.maxHp ?? 1, MOB_FRAME_H);
          }
        }

        if (debugHitboxes && mob) {
          drawDebugCircle(drawX, drawY, DBG_MOB_R, "rgba(255,60,60,0.95)");
        }
        continue;
      }
      // Fade-in when a mob spawns/respawns
      const spawnAt = mobSpawnAtMs.get(e.id) ?? 0;
      const spawnAlpha = spawnAt ? clamp((performance.now() - spawnAt) / MOB_SPAWN_FADE_MS, 0, 1) : 1;

      ctx.save();
      ctx.globalAlpha = spawnAlpha;

      drawSprite(sprite, drawX, drawY, st.dir, st.frame, MOB_FRAME_W, MOB_FRAME_H);

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(sprite, drawX, drawY, st.dir, st.frame,...fx.color || "rgba(255,255,255,0.45)", MOB_FRAME_W, MOB_FRAME_H);
      }
      if (mob) {
        const me = getMyPos();
        // Only show mob HP bars when you're close enough (reduces screen clutter)
        if (!me || dist(me.x, me.y, drawX, drawY) <= MOB_HPBAR_DIST) {
          drawHpBarWorld(drawX, drawY, mob.hp ?? 0, mob.maxHp ?? 1, MOB_FRAME_H);
        }
      }
      if (debugHitboxes && mob) {
        drawDebugCircle(drawX, drawY, DBG_MOB_R, "rgba(255,60,60,0.95)");
      }
      ctx.restore();
      continue;
    }

    const isNpc = (e.kind === "npc");
    const p = isNpc ? null : worldPlayers[e.id];

    // attack-active flag (used to suppress idle pose while swinging)
    const serverAtkAnim = p ? (p.atkAnim || 0) : 0;
    const attacking = (serverAtkAnim > 0);

    // match the movement test used by updateAnim()
    const movingNow = (e.id === myId)
      ? (keys.left || keys.right || keys.up || keys.down)
      : (st.sinceMove < 0.22);

    const idlePose = (!isNpc) && (!movingNow) && (!attacking);

    // choose base sprite (idle uses a 2-col sheet)
    let bodySprite = npcSprite;
    let bodyFrame = st.frame;
    let bodyFW = NPC_FRAME_W, bodyFH = NPC_FRAME_H;
    if (!isNpc) {
      bodySprite = idlePose ? playerIdleSprite : playerSprite;
      bodyFrame = idlePose ? (st.idleFrame || 0) : st.frame;
      bodyFW = PLAYER_FRAME_W; bodyFH = PLAYER_FRAME_H;
    }

    // Weapon visuals: draw UP swings *behind* the player so they don't sit on top of the sprite.
    // (Left/Right/Down stay in front as before.)
    let weapon = "sword";
    const p2 = (!isNpc) ? worldPlayers[e.id] : null;
    let weaponActive = false;
    let weaponPhase01 = 0;
    let weaponDrawnBehind = false;
    let spearHeldDrawnBehind = false;
    let renderDir = st.dir;  // direction used for rendering (locks during attack)
    if (!isNpc) {
      weapon = p2?.weapon || "sword";

      const serverAnim = p2 ? (p2.atkAnim || 0) : 0;
      weaponActive = (serverAnim > 0);
      if (weaponActive) {
        // serverAnim counts down from LOCAL_SWING_DUR
        weaponPhase01 = clamp(1 - (serverAnim / LOCAL_SWING_DUR), 0, 1);

        // Use an attack-locked direction while the weapon animation is active.
renderDir = st.dir;
if (!isNpc && weaponActive) {
  const wp = worldPlayers[e.id];
    const atkDirStr = wp && wp.atkDir;
    if (atkDirStr) {
      renderDir = (atkDirStr === "up") ? DIR.UP : (atkDirStr === "down") ? DIR.DOWN : (atkDirStr === "left") ? DIR.LEFT : DIR.RIGHT;
    } else if (wp && wp.facing && Number.isFinite(wp.facing.x) && Number.isFinite(wp.facing.y)) {
      const d = dirFromVector(wp.facing.x, wp.facing.y);
      if (d != null) renderDir = d;
    }
  }

const weaponBehind = (renderDir === DIR.UP) && (weapon === "sword" || weapon === "spear");
        if (weaponBehind) {
          if (weapon === "sword") drawSwordSwing(drawX, drawY, renderDir, weaponPhase01);
          else if (weapon === "spear") drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p2));
          weaponDrawnBehind = true;
        }
      }
    }

    

    // Persistent spear when equipped (not attacking).
    // IMPORTANT: while weaponActive is true, we only draw the thrust (using the attack-locked renderDir).
    // This prevents the “held” spear from popping to a new facing direction mid-animation (no double-spears).
    if (!isNpc && !weaponActive && weapon === "spear" && renderDir === DIR.UP) {
      drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p2));
      spearHeldDrawnBehind = true;
    }
drawSprite(bodySprite, drawX, drawY, renderDir, bodyFrame, bodyFW, bodyFH);

    // paper-doll overlays (armor + hat)
    let armorSprite = null;
    let hatSprite = null;
    if (!isNpc) {
      const armorId = p?.equipment?.armor;
      if (armorId) {
        const aImg = idlePose ? armorIdleOverlays[armorId] : armorOverlays[armorId];
        const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
        if (aImg) {
          armorSprite = aImg;
          drawSprite(aImg, drawX, drawY, renderDir, aFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      const hatId = p?.equipment?.hat;
      if (hatId) {
        const hImg = idlePose ? hatIdleOverlays[hatId] : hatOverlays[hatId];
        const hFrame = idlePose ? (st.idleFrame || 0) : st.frame;
        if (hImg) {
          hatSprite = hImg;
          drawSprite(hImg, drawX, drawY, renderDir, hFrame, PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }

      if (fx && performance.now() < fx.untilMs) {
        drawHitTintOnTop(bodySprite, drawX, drawY, st.dir, bodyFrame, fx.color || "rgba(255,0,0,0.45)", bodyFW, bodyFH);
        if (armorSprite) {
          const aFrame = idlePose ? (st.idleFrame || 0) : st.frame;
          drawHitTintOnTop(armorSprite, drawX, drawY, st.dir, aFrame, fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
        if (hatSprite) {
          drawHitTintOnTop(hatSprite, drawX, drawY, st.dir, (st.idleFrame || 0), fx.color || "rgba(255,0,0,0.45)", PLAYER_FRAME_W, PLAYER_FRAME_H);
        }
      }
    }
    // name + level above players (all clients) - queued to draw after canopy pass
    if (!isNpc) {
      const p = worldPlayers[e.id];
      if (p) nameplates.push({ x: drawX, y: drawY, level: p.level, name: p.name, spriteH: PLAYER_FRAME_H });
    }


    // debug collision overlays
    if (debugHitboxes && !isNpc) {
      // Player foot hitbox (matches server)
      drawDebugCircle(drawX, drawY + DBG_PLAYER_FOOT_Y, DBG_PLAYER_R, "rgba(80,160,255,0.95)");

      // Weapon hitbox (only while attacking)
      if (weaponActive) {
        const p0 = worldPlayers[e.id];
        const wid = p0?.equipment?.weapon;
        const wkey = p0?.weapon || weaponKeyFromEquippedId(wid);
        const d = dirVecFromAtkDir(p0?.atkDir, p0?.facing);
        if (wkey === "sword") {
          drawDebugCircle(drawX + d.x * DBG_SWORD_OFFSET, drawY + d.y * DBG_SWORD_OFFSET, DBG_SWORD_R, "rgba(255,220,40,0.95)");
        } else if (wkey === "spear") {
          drawDebugCircle(drawX + d.x * DBG_SPEAR_OFFSET, drawY + d.y * DBG_SPEAR_OFFSET, DBG_SPEAR_R, "rgba(255,220,40,0.95)");
        } else if (wkey === "wand") {
          // show your projectiles as the active weapon hitboxes
          for (const pr of Object.values(worldProjectiles || {})) {
            if (pr.mapId !== currentMapId) continue;
            if (pr.ownerId && pr.ownerId !== e.id) continue;
            const r = pr.rad ?? 10;
            drawDebugCircle(pr.x, pr.y, r, "rgba(255,220,40,0.95)");
          }
        }
      }
    }
    // weapon visuals for players (front pass)
    if (!isNpc && weaponActive && !weaponDrawnBehind) {
      if (weapon === "sword") drawSwordSwing(drawX, drawY, renderDir, weaponPhase01);
      else if (weapon === "spear") drawSpearThrust(drawX, drawY, renderDir, weaponPhase01, getSpearSpriteForPlayer(p));
      else if (weapon === "wand") drawWandCastSpark(drawX, drawY, renderDir, weaponPhase01);
    }

    // Persistent spear when equipped (not attacking) — front pass (Left/Right/Down).
    if (!isNpc && !weaponActive && weapon === "spear" && !spearHeldDrawnBehind) {
      drawSpearHeld(drawX, drawY, renderDir, getSpearSpriteForPlayer(p));
    }
  }

  drawObjects("canopy");

  // nameplates last so they never sort under canopies
  for (const np of nameplates) {
    drawNameplate(np.x, np.y, np.level, np.name, np.spriteH);
  }

  drawDialogueBubble(activeDialogue);

  // world-space popups (follow camera)
  drawDamagePops();
  drawLootPops();

  ctx.restore();

  // Editor UI should be screen-space (locked to the viewport), not world-space.
  // Keeping it after ctx.restore() prevents it from drifting when the camera moves.
  drawEditorOverlay();

  drawFadeOverlay();
  drawHud();

  if (inventoryOpen) {
    const me = worldPlayers[myId];
    drawInventory(me?.inventory, me?.equipment);
  } else {
    invUI = null;
  }
  drawLevelToast();

  }
  catch (err) {
    console.error('Render loop error:', err);
  }

  requestAnimationFrame(loop);

}

requestAnimationFrame(loop);
</script>
</body>
</html>